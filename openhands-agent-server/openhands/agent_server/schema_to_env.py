"""Utility for converting JSON schemas to sample dotenv files.

This module provides functionality to generate sample .env files from JSON schemas,
particularly those generated by Pydantic models. It handles:
- Discriminated unions (oneOf with discriminator)
- Nested objects with underscore notation
- Array/list fields with indexed notation
- Field descriptions as comments
- Default values (uncommented) vs optional values (commented out)
"""

import json
from typing import Any, Dict, List, Optional, Set, Tuple, Union


class SchemaToEnvGenerator:
    """Generates sample .env files from JSON schemas."""
    
    def __init__(self, prefix: str = ""):
        """Initialize the generator.
        
        Args:
            prefix: Environment variable prefix (e.g., "OH" for OpenHands)
        """
        self.prefix = prefix
        self.generated_vars: Set[str] = set()
        self.output_lines: List[str] = []
        self.schema_definitions: Dict[str, Any] = {}
    
    def generate_env_file(self, schema: Dict[str, Any]) -> str:
        """Generate a complete .env file from a JSON schema.
        
        Args:
            schema: JSON schema dictionary
            
        Returns:
            String content for .env file
        """
        self.generated_vars.clear()
        self.output_lines.clear()
        self.schema_definitions.clear()
        
        # Extract schema definitions for $ref resolution
        if "$defs" in schema:
            self.schema_definitions.update(schema["$defs"])
        if "definitions" in schema:
            self.schema_definitions.update(schema["definitions"])
        
        # Add header comment
        self.output_lines.append("# Generated .env file from JSON schema")
        self.output_lines.append("# Uncommented values show defaults, commented values show available options")
        self.output_lines.append("")
        
        # Process the root schema
        self._process_schema(schema, self.prefix, is_root=True)
        
        return "\n".join(self.output_lines)
    
    def _resolve_ref(self, ref: str) -> Optional[Dict[str, Any]]:
        """Resolve a $ref reference to its schema definition.
        
        Args:
            ref: Reference string (e.g., "#/$defs/DatabaseConfig")
            
        Returns:
            Resolved schema dictionary or None if not found
        """
        if ref.startswith("#/$defs/"):
            def_name = ref[8:]  # Remove "#/$defs/"
            return self.schema_definitions.get(def_name)
        elif ref.startswith("#/definitions/"):
            def_name = ref[14:]  # Remove "#/definitions/"
            return self.schema_definitions.get(def_name)
        return None
    
    def _process_schema(
        self, 
        schema: Dict[str, Any], 
        env_prefix: str, 
        is_root: bool = False,
        parent_description: Optional[str] = None
    ) -> None:
        """Process a schema object and generate environment variables.
        
        Args:
            schema: JSON schema to process
            env_prefix: Current environment variable prefix
            is_root: Whether this is the root schema
            parent_description: Description from parent schema
        """
        schema_type = schema.get("type")
        
        if schema_type == "object":
            self._process_object_schema(schema, env_prefix, is_root)
        elif "oneOf" in schema:
            self._process_discriminated_union(schema, env_prefix)
        elif schema_type == "array":
            self._process_array_schema(schema, env_prefix)
        elif schema_type in ("string", "integer", "number", "boolean"):
            self._process_primitive_schema(schema, env_prefix, parent_description)
        elif "anyOf" in schema or "allOf" in schema:
            # Handle anyOf/allOf by processing the first option
            options = schema.get("anyOf", schema.get("allOf", []))
            if options:
                self._process_schema(options[0], env_prefix, parent_description=parent_description)
    
    def _process_object_schema(
        self, 
        schema: Dict[str, Any], 
        env_prefix: str, 
        is_root: bool = False
    ) -> None:
        """Process an object schema and its properties."""
        properties = schema.get("properties", {})
        required = set(schema.get("required", []))
        
        # Add object-level description if available and not root
        if not is_root and "description" in schema:
            self._add_comment(schema["description"])
        
        # Process each property
        for prop_name, prop_schema in properties.items():
            # Skip the 'kind' field for discriminated unions as it's handled separately
            if prop_name == "kind" and self._is_discriminated_union_kind(prop_schema):
                continue
                
            field_prefix = self._build_field_prefix(env_prefix, prop_name)
            is_required = prop_name in required
            
            # Add field description as comment
            if "description" in prop_schema:
                self._add_comment(f"{prop_name}: {prop_schema['description']}")
            
            # Check if field has a default value
            has_default = "default" in prop_schema
            default_value = prop_schema.get("default")
            
            # Process the field schema
            if prop_schema.get("type") == "object" or "properties" in prop_schema:
                # Nested object - process recursively
                self._process_schema(prop_schema, field_prefix)
            elif "oneOf" in prop_schema:
                # Discriminated union field
                self._process_discriminated_union(prop_schema, field_prefix)
            elif prop_schema.get("type") == "array":
                # Array field
                self._process_array_schema(prop_schema, field_prefix, has_default, default_value)
            elif "$ref" in prop_schema:
                # Reference to another schema - resolve and process
                resolved_schema = self._resolve_ref(prop_schema["$ref"])
                if resolved_schema:
                    self._process_schema(resolved_schema, field_prefix)
                else:
                    self._add_comment(f"Referenced schema: {prop_schema['$ref']}")
                    self._add_env_var(field_prefix, "example_value", commented=True)
            else:
                # Primitive field
                self._process_primitive_field(
                    field_prefix, prop_schema, has_default, default_value, is_required
                )
    
    def _process_discriminated_union(self, schema: Dict[str, Any], env_prefix: str) -> None:
        """Process a discriminated union (oneOf with discriminator)."""
        one_of = schema.get("oneOf", [])
        discriminator = schema.get("discriminator", {})
        
        if not one_of:
            return
        
        # Add comment about the discriminated union
        self._add_comment("Discriminated union - choose one of the following options:")
        
        # Get the discriminator property name (usually "kind")
        discriminator_prop = discriminator.get("propertyName", "kind")
        discriminator_mapping = discriminator.get("mapping", {})
        
        # Process each option in the union
        for i, option in enumerate(one_of):
            # Try to get the option name from discriminator mapping or $ref
            option_name = None
            if "$ref" in option:
                ref_name = option["$ref"].split("/")[-1]
                option_name = ref_name
                # Find the actual schema definition
                # For now, we'll create a placeholder
                self._add_comment(f"Option {i + 1}: {option_name}")
                self._add_env_var(f"{env_prefix}_{discriminator_prop.upper()}", option_name, commented=True)
            else:
                # Inline schema
                option_title = option.get("title", f"Option{i + 1}")
                
                # Get discriminator value
                disc_value = option_title
                if "properties" in option and discriminator_prop in option["properties"]:
                    disc_schema = option["properties"][discriminator_prop]
                    if "const" in disc_schema:
                        disc_value = disc_schema["const"]
                    elif "enum" in disc_schema and len(disc_schema["enum"]) == 1:
                        disc_value = disc_schema["enum"][0]
                
                self._add_comment(f"Option {i + 1}: {disc_value}")
                self._add_env_var(f"{env_prefix}_{discriminator_prop.upper()}", disc_value, commented=True)
                
                # Process the option's properties (excluding discriminator)
                if "properties" in option:
                    for prop_name, prop_schema in option["properties"].items():
                        if prop_name == discriminator_prop:
                            continue
                        
                        field_prefix = self._build_field_prefix(env_prefix, prop_name)
                        
                        # Check if this property has a default
                        has_default = "default" in prop_schema
                        default_value = prop_schema.get("default")
                        
                        if prop_schema.get("type") in ("string", "integer", "number", "boolean"):
                            self._process_primitive_field(field_prefix, prop_schema, has_default, default_value, False)
                        else:
                            self._process_schema(prop_schema, field_prefix)
        
        self.output_lines.append("")  # Add spacing after union options
    
    def _process_array_schema(self, schema: Dict[str, Any], env_prefix: str, has_default: bool = False, default_value: Any = None) -> None:
        """Process an array schema."""
        items_schema = schema.get("items", {})
        
        # Add comment about array format
        self._add_comment("Array field - use JSON format or indexed notation (e.g., VAR_0, VAR_1)")
        
        # Show JSON array example
        if has_default and default_value is not None:
            # Use the actual default value
            example_value = json.dumps(default_value)
            commented = False
        else:
            # Generate example based on item type
            if items_schema.get("type") == "string":
                example_value = '["item1", "item2"]'
            elif items_schema.get("type") in ("integer", "number"):
                example_value = "[1, 2, 3]"
            elif items_schema.get("type") == "boolean":
                example_value = "[true, false]"
            elif "properties" in items_schema or items_schema.get("type") == "object":
                example_value = '[{"key": "value"}]'
            else:
                example_value = '["value1", "value2"]'
            commented = True
        
        self._add_env_var(env_prefix, example_value, commented=commented)
        
        # Show indexed notation examples
        self._add_comment("Or use indexed notation:")
        for i in range(2):  # Show 2 examples
            indexed_prefix = f"{env_prefix}_{i}"
            if items_schema.get("type") in ("string", "integer", "number", "boolean"):
                self._process_primitive_schema(items_schema, indexed_prefix)
            else:
                self._process_schema(items_schema, indexed_prefix)
    
    def _process_primitive_schema(
        self, 
        schema: Dict[str, Any], 
        env_prefix: str, 
        parent_description: Optional[str] = None
    ) -> None:
        """Process a primitive schema (string, number, boolean)."""
        has_default = "default" in schema
        default_value = schema.get("default")
        
        # Use parent description if no local description
        description = schema.get("description", parent_description)
        if description:
            self._add_comment(description)
        
        self._process_primitive_field(env_prefix, schema, has_default, default_value, required=False)
    
    def _process_primitive_field(
        self,
        env_prefix: str,
        schema: Dict[str, Any],
        has_default: bool,
        default_value: Any,
        required: bool
    ) -> None:
        """Process a primitive field and add it to the output."""
        schema_type = schema.get("type", "string")
        
        # Generate example value
        if has_default:
            if default_value is None:
                value = ""
            elif isinstance(default_value, bool):
                value = "true" if default_value else "false"
            elif isinstance(default_value, (list, dict)):
                value = json.dumps(default_value)
            else:
                value = str(default_value)
        else:
            # Generate example based on type
            if schema_type == "string":
                if "enum" in schema:
                    value = schema["enum"][0]
                else:
                    value = "example_value"
            elif schema_type == "integer":
                value = "42"
            elif schema_type == "number":
                value = "3.14"
            elif schema_type == "boolean":
                value = "true"
            else:
                value = "example_value"
        
        # Add enum options as comment if available
        if "enum" in schema:
            enum_values = ", ".join(str(v) for v in schema["enum"])
            self._add_comment(f"Possible values: {enum_values}")
        
        # Comment out if no default (regardless of required status for env vars)
        commented = not has_default
        self._add_env_var(env_prefix, value, commented=commented)
    
    def _build_field_prefix(self, current_prefix: str, field_name: str) -> str:
        """Build the environment variable prefix for a field."""
        field_upper = field_name.upper()
        if current_prefix:
            return f"{current_prefix}_{field_upper}"
        return field_upper
    
    def _is_discriminated_union_kind(self, schema: Dict[str, Any]) -> bool:
        """Check if this is a discriminator kind field."""
        return (
            "const" in schema or 
            ("enum" in schema and len(schema.get("enum", [])) == 1) or
            schema.get("type") == "string" and "enum" in schema
        )
    
    def _add_comment(self, comment: str) -> None:
        """Add a comment line to the output."""
        # Split long comments into multiple lines
        max_length = 80
        if len(comment) <= max_length:
            self.output_lines.append(f"# {comment}")
        else:
            words = comment.split()
            current_line = "# "
            for word in words:
                if len(current_line + word) <= max_length:
                    current_line += word + " "
                else:
                    self.output_lines.append(current_line.rstrip())
                    current_line = f"# {word} "
            if current_line.strip() != "#":
                self.output_lines.append(current_line.rstrip())
    
    def _add_env_var(self, name: str, value: str, commented: bool = False) -> None:
        """Add an environment variable to the output."""
        if name in self.generated_vars:
            return  # Avoid duplicates
        
        self.generated_vars.add(name)
        
        # Escape value if it contains spaces or special characters
        if " " in value or any(c in value for c in '"\'\\$`'):
            value = f'"{value}"'
        
        prefix = "# " if commented else ""
        self.output_lines.append(f"{prefix}{name}={value}")


def generate_env_from_model(model_class, prefix: str = "") -> str:
    """Generate a .env file from a Pydantic model class.
    
    Args:
        model_class: Pydantic model class
        prefix: Environment variable prefix
        
    Returns:
        String content for .env file
    """
    schema = model_class.model_json_schema()
    generator = SchemaToEnvGenerator(prefix)
    return generator.generate_env_file(schema)


def generate_env_from_schema(schema: Dict[str, Any], prefix: str = "") -> str:
    """Generate a .env file from a JSON schema.
    
    Args:
        schema: JSON schema dictionary
        prefix: Environment variable prefix
        
    Returns:
        String content for .env file
    """
    generator = SchemaToEnvGenerator(prefix)
    return generator.generate_env_file(schema)