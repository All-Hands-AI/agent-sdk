## `openhands.sdk`

OpenHands SDK - Core SDK for building AI agents.

**Modules:**

- [**agent**](#openhands.sdk.agent) – Agent module - Core agent implementations.
- [**context**](#openhands.sdk.context) – Context management module - Agent context and microagents.
- [**conversation**](#openhands.sdk.conversation) – Conversation management - Agent-user interaction handling.
- [**event**](#openhands.sdk.event) – Event system for agent communication and state management.
- [**io**](#openhands.sdk.io) – File storage interfaces and implementations.
- [**llm**](#openhands.sdk.llm) – LLM integration module - Language model interfaces and utilities.
- [**logger**](#openhands.sdk.logger) – Minimal logger setup that encourages per-module loggers.
- [**mcp**](#openhands.sdk.mcp) – MCP (Model Context Protocol) integration for agent-sdk.
- [**tool**](#openhands.sdk.tool) – OpenHands runtime package.
- [**utils**](#openhands.sdk.utils) – Utility functions for the OpenHands SDK.

**Classes:**

- [**ActionBase**](#openhands.sdk.ActionBase) – Base schema for input action.
- [**Agent**](#openhands.sdk.Agent) – Main agent implementation for OpenHands.
- [**AgentBase**](#openhands.sdk.AgentBase) – Base class for all OpenHands agents.
- [**AgentContext**](#openhands.sdk.AgentContext) – Central structure for managing prompt extension.
- [**Conversation**](#openhands.sdk.Conversation) – Main conversation handler for agent interactions.
- [**EventBase**](#openhands.sdk.EventBase) – Base class for all events.
- [**FileStore**](#openhands.sdk.FileStore) – Abstract base class for file storage operations.
- [**ImageContent**](#openhands.sdk.ImageContent) – Image content for messages.
- [**LLM**](#openhands.sdk.LLM) – Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.
- [**LLMConvertibleEvent**](#openhands.sdk.LLMConvertibleEvent) – Base class for events that can be converted to LLM messages.
- [**LLMRegistry**](#openhands.sdk.LLMRegistry) – A minimal LLM registry for managing LLM instances by service ID.
- [**LocalFileStore**](#openhands.sdk.LocalFileStore) – Local file store implementation using the local filesystem.
- [**MCPClient**](#openhands.sdk.MCPClient) – Behaves exactly like fastmcp.Client (same constructor & async API).
- [**MCPTool**](#openhands.sdk.MCPTool) – MCP Tool that wraps an MCP client and provides tool functionality.
- [**Message**](#openhands.sdk.Message) – Message for LLM communication.
- [**ObservationBase**](#openhands.sdk.ObservationBase) – Base schema for output observation.
- [**RegistryEvent**](#openhands.sdk.RegistryEvent) – Event representing LLM registration or deregistration.
- [**TextContent**](#openhands.sdk.TextContent) – Text content for messages.
- [**Tool**](#openhands.sdk.Tool) – Tool that wraps an executor function with input/output validation and schema.

**Functions:**

- [**create_mcp_tools**](#openhands.sdk.create_mcp_tools) – Create MCP tools from MCP configuration.
- [**get_logger**](#openhands.sdk.get_logger) – Return a logger for the given module name.

**Attributes:**

- [**ConversationCallbackType**](#openhands.sdk.ConversationCallbackType) –
- [**Event**](#openhands.sdk.Event) – Type annotation for values that can be any implementation of EventBase.

### `openhands.sdk.ActionBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for input action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.ActionBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.ActionBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.ActionBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.ActionBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.ActionBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.ActionBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.ActionBase.model_config) –
- [**security_risk**](#openhands.sdk.ActionBase.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.ActionBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

#### `openhands.sdk.ActionBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.sdk.ActionBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.ActionBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.sdk.ActionBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.ActionBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.ActionBase.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

#### `openhands.sdk.ActionBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.ActionBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.sdk.ActionBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

### `openhands.sdk.Agent`

Bases: <code>[AgentBase](#openhands.sdk.agent.base.AgentBase)</code>

Main agent implementation for OpenHands.

**Functions:**

- [**init_state**](#openhands.sdk.Agent.init_state) – Initialize the conversation state with system prompt.
- [**model_dump_succint**](#openhands.sdk.Agent.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.Agent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.Agent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.Agent.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.Agent.step) – Execute one step of the agent conversation.
- [**target_subclass**](#openhands.sdk.Agent.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.Agent.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**cli_mode**](#openhands.sdk.Agent.cli_mode) (<code>[bool](#bool)</code>) –
- [**condenser**](#openhands.sdk.Agent.condenser) (<code>[Condenser](#openhands.sdk.context.condenser.Condenser) | None</code>) –
- [**kind**](#openhands.sdk.Agent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.Agent.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.Agent.model_config) –
- [**name**](#openhands.sdk.Agent.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.Agent.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**system_message**](#openhands.sdk.Agent.system_message) (<code>[str](#str)</code>) – Compute system message on-demand to maintain statelessness.
- [**system_prompt_filename**](#openhands.sdk.Agent.system_prompt_filename) (<code>[str](#str)</code>) –
- [**tools**](#openhands.sdk.Agent.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

#### `openhands.sdk.Agent.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

#### `openhands.sdk.Agent.cli_mode`

```python
cli_mode: bool = Field(default=True)
```

#### `openhands.sdk.Agent.condenser`

```python
condenser: Condenser | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.sdk.Agent.init_state`

```python
init_state(state, on_event)
```

Initialize the conversation state with system prompt.

#### `openhands.sdk.Agent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.Agent.llm`

```python
llm: LLM
```

#### `openhands.sdk.Agent.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.sdk.Agent.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

#### `openhands.sdk.Agent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.Agent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.Agent.name`

```python
name: str
```

Returns the name of the Agent.

#### `openhands.sdk.Agent.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

#### `openhands.sdk.Agent.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

#### `openhands.sdk.Agent.step`

```python
step(state, on_event)
```

Execute one step of the agent conversation.

#### `openhands.sdk.Agent.system_message`

```python
system_message: str
```

Compute system message on-demand to maintain statelessness.

#### `openhands.sdk.Agent.system_prompt_filename`

```python
system_prompt_filename: str = Field(default='system_prompt.j2')
```

#### `openhands.sdk.Agent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.Agent.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

### `openhands.sdk.AgentBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all OpenHands agents.

**Functions:**

- [**init_state**](#openhands.sdk.AgentBase.init_state) – Initialize the empty conversation state to prepare the agent.
- [**model_dump_succint**](#openhands.sdk.AgentBase.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.AgentBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.AgentBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.AgentBase.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.AgentBase.step) – Take a step in the conversation.
- [**target_subclass**](#openhands.sdk.AgentBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.AgentBase.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**kind**](#openhands.sdk.AgentBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.AgentBase.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.AgentBase.model_config) –
- [**name**](#openhands.sdk.AgentBase.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.AgentBase.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**tools**](#openhands.sdk.AgentBase.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

#### `openhands.sdk.AgentBase.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

#### `openhands.sdk.AgentBase.init_state`

```python
init_state(state, on_event)
```

Initialize the empty conversation state to prepare the agent.

Typically this involves adding system message

NOTE: state will be mutated in-place.

#### `openhands.sdk.AgentBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.AgentBase.llm`

```python
llm: LLM
```

#### `openhands.sdk.AgentBase.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.sdk.AgentBase.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

#### `openhands.sdk.AgentBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.AgentBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.AgentBase.name`

```python
name: str
```

Returns the name of the Agent.

#### `openhands.sdk.AgentBase.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

#### `openhands.sdk.AgentBase.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

#### `openhands.sdk.AgentBase.step`

```python
step(state, on_event)
```

Take a step in the conversation.

Typically this involves:

1. Making a LLM call
1. Executing the tool
1. Updating the conversation state with
   LLM calls (role="assistant") and tool results (role="tool")
   4.1 If conversation is finished, set state.agent_finished flag
   4.2 Otherwise, just return, Conversation will kick off the next step

NOTE: state will be mutated in-place.

#### `openhands.sdk.AgentBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.AgentBase.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

### `openhands.sdk.AgentContext`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Central structure for managing prompt extension.

AgentContext unifies all the contextual inputs that shape how the system
extends and interprets user prompts. It combines both static environment
details and dynamic, user-activated extensions from microagents.

Specifically, it provides:

- **Repository context / Repo Microagents**: Information about the active codebase,
  branches, and repo-specific instructions contributed by repo microagents.
- **Runtime context**: Current execution environment (hosts, working
  directory, secrets, date, etc.).
- **Conversation instructions**: Optional task- or channel-specific rules
  that constrain or guide the agent’s behavior across the session.
- **Knowledge Microagents**: Extensible components that can be triggered by user input
  to inject knowledge or domain-specific guidance.

Together, these elements make AgentContext the primary container responsible
for assembling, formatting, and injecting all prompt-relevant context into
LLM interactions.

**Functions:**

- [**get_system_message_suffix**](#openhands.sdk.AgentContext.get_system_message_suffix) – Get the system message with repo microagent content and custom suffix.
- [**get_user_message_suffix**](#openhands.sdk.AgentContext.get_user_message_suffix) – Augment the user’s message with knowledge recalled from microagents.

**Attributes:**

- [**microagents**](#openhands.sdk.AgentContext.microagents) (<code>[list](#list)\[[BaseMicroagent](#openhands.sdk.context.microagents.BaseMicroagent)\]</code>) –
- [**system_message_suffix**](#openhands.sdk.AgentContext.system_message_suffix) (<code>[str](#str) | None</code>) –
- [**user_message_suffix**](#openhands.sdk.AgentContext.user_message_suffix) (<code>[str](#str) | None</code>) –

#### `openhands.sdk.AgentContext.get_system_message_suffix`

```python
get_system_message_suffix()
```

Get the system message with repo microagent content and custom suffix.

Custom suffix can typically includes:

- Repository information (repo name, branch name, PR number, etc.)
- Runtime information (e.g., available hosts, current date)
- Conversation instructions (e.g., user preferences, task details)
- Repository-specific instructions (collected from repo microagents)

#### `openhands.sdk.AgentContext.get_user_message_suffix`

```python
get_user_message_suffix(user_message, skip_microagent_names)
```

Augment the user’s message with knowledge recalled from microagents.

This works by:

- Extracting the text content of the user message
- Matching microagent triggers against the query
- Returning formatted knowledge and triggered microagent names if relevant microagents were triggered

#### `openhands.sdk.AgentContext.microagents`

```python
microagents: list[BaseMicroagent] = Field(default_factory=list, description="List of available microagents that can extend the user's input.")
```

#### `openhands.sdk.AgentContext.system_message_suffix`

```python
system_message_suffix: str | None = Field(default=None, description='Optional suffix to append to the system prompt.')
```

#### `openhands.sdk.AgentContext.user_message_suffix`

```python
user_message_suffix: str | None = Field(default=None, description="Optional suffix to append to the user's message.")
```

### `openhands.sdk.Conversation`

```python
Conversation(agent, persist_filestore=None, conversation_id=None, callbacks=None, max_iteration_per_run=500, visualize=True)
```

Main conversation handler for agent interactions.

**Functions:**

- [**close**](#openhands.sdk.Conversation.close) – Close the conversation and clean up all tool executors.
- [**pause**](#openhands.sdk.Conversation.pause) – Pause agent execution.
- [**reject_pending_actions**](#openhands.sdk.Conversation.reject_pending_actions) – Reject all pending actions from the agent.
- [**run**](#openhands.sdk.Conversation.run) – Run the conversation until the agent finishes.
- [**send_message**](#openhands.sdk.Conversation.send_message) – Send messages to the agent.
- [**set_confirmation_mode**](#openhands.sdk.Conversation.set_confirmation_mode) – Enable or disable confirmation mode and store it in conversation state.

**Attributes:**

- [**agent**](#openhands.sdk.Conversation.agent) –
- [**id**](#openhands.sdk.Conversation.id) (<code>[str](#str)</code>) – Get the unique ID of the conversation.
- [**max_iteration_per_run**](#openhands.sdk.Conversation.max_iteration_per_run) –
- [**state**](#openhands.sdk.Conversation.state) –

Initialize the conversation.

**Parameters:**

- **agent** (<code>[AgentType](#openhands.sdk.agent.AgentType)</code>) – The agent to use for the conversation
- **persist_filestore** (<code>[FileStore](#openhands.sdk.io.FileStore) | None</code>) – Optional FileStore to persist conversation state
- **conversation_id** (<code>[str](#str) | None</code>) – Optional ID for the conversation. If provided, will
  be used to identify the conversation. The user might want to
  suffix their persistent filestore with this ID.
- **callbacks** (<code>[list](#list)\[[ConversationCallbackType](#openhands.sdk.conversation.types.ConversationCallbackType)\] | None</code>) – Optional list of callback functions to handle events
- **max_iteration_per_run** (<code>[int](#int)</code>) – Maximum number of iterations per run
- **visualize** (<code>[bool](#bool)</code>) – Whether to enable default visualization. If True, adds
  a default visualizer callback. If False, relies on
  application to provide visualization through callbacks.

#### `openhands.sdk.Conversation.agent`

```python
agent = agent
```

#### `openhands.sdk.Conversation.close`

```python
close()
```

Close the conversation and clean up all tool executors.

#### `openhands.sdk.Conversation.id`

```python
id: str
```

Get the unique ID of the conversation.

#### `openhands.sdk.Conversation.max_iteration_per_run`

```python
max_iteration_per_run = max_iteration_per_run
```

#### `openhands.sdk.Conversation.pause`

```python
pause()
```

Pause agent execution.

This method can be called from any thread to request that the agent
pause execution. The pause will take effect at the next iteration
of the run loop (between agent steps).

Note: If called during an LLM completion, the pause will not take
effect until the current LLM call completes.

#### `openhands.sdk.Conversation.reject_pending_actions`

```python
reject_pending_actions(reason='User rejected the action')
```

Reject all pending actions from the agent.

This is a non-invasive method to reject actions between run() calls.
Also clears the agent_waiting_for_confirmation flag.

#### `openhands.sdk.Conversation.run`

```python
run()
```

Run the conversation until the agent finishes.

In confirmation mode:

- First call: creates actions but doesn't execute them, stops and waits
- Second call: executes pending actions (implicit confirmation)

In normal mode:

- Creates and executes actions immediately

Can be paused between steps

#### `openhands.sdk.Conversation.send_message`

```python
send_message(message)
```

Send messages to the agent.

#### `openhands.sdk.Conversation.set_confirmation_mode`

```python
set_confirmation_mode(enabled)
```

Enable or disable confirmation mode and store it in conversation state.

#### `openhands.sdk.Conversation.state`

```python
state = ConversationState.create(id=desired_id, agent=agent, file_store=(self._persist_filestore))
```

### `openhands.sdk.ConversationCallbackType`

```python
ConversationCallbackType = Callable[[Event], None]
```

### `openhands.sdk.Event`

```python
Event = Annotated[EventBase, DiscriminatedUnionType[EventBase]]
```

Type annotation for values that can be any implementation of EventBase.

In most situations, this is equivalent to EventBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.

### `openhands.sdk.EventBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all events.

**Functions:**

- [**model_validate**](#openhands.sdk.EventBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.EventBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.EventBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**id**](#openhands.sdk.EventBase.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.EventBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.EventBase.model_config) –
- [**source**](#openhands.sdk.EventBase.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.EventBase.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.EventBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

#### `openhands.sdk.EventBase.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

#### `openhands.sdk.EventBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.EventBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.sdk.EventBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.EventBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.EventBase.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

#### `openhands.sdk.EventBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.EventBase.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

#### `openhands.sdk.EventBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

### `openhands.sdk.FileStore`

Abstract base class for file storage operations.

**Functions:**

- [**delete**](#openhands.sdk.FileStore.delete) – Delete a file or directory at the specified path.
- [**list**](#openhands.sdk.FileStore.list) – List files and directories at the specified path.
- [**read**](#openhands.sdk.FileStore.read) – Read contents from a file at the specified path.
- [**write**](#openhands.sdk.FileStore.write) – Write contents to a file at the specified path.

#### `openhands.sdk.FileStore.delete`

```python
delete(path)
```

Delete a file or directory at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, implementations should handle this
gracefully without raising an exception.
</details>

#### `openhands.sdk.FileStore.list`

```python
list(path)
```

List files and directories at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list.

**Returns:**

- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – A list of file and directory names. Directory names end with "/".
- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist.

#### `openhands.sdk.FileStore.read`

```python
read(path)
```

Read contents from a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string.

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

#### `openhands.sdk.FileStore.write`

```python
write(path, contents)
```

Write contents to a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to. Can be nested
  (e.g., "folder/subfolder/file.txt").
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, implementations should
create them automatically.
</details>

### `openhands.sdk.ImageContent`

Bases: <code>[ImageContent](#mcp.types.ImageContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Image content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.ImageContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.ImageContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**image_urls**](#openhands.sdk.ImageContent.image_urls) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**model_config**](#openhands.sdk.ImageContent.model_config) –
- [**type**](#openhands.sdk.ImageContent.type) (<code>[Literal](#typing.Literal)['image']</code>) –

#### `openhands.sdk.ImageContent.cache_prompt`

```python
cache_prompt: bool = False
```

#### `openhands.sdk.ImageContent.image_urls`

```python
image_urls: list[str]
```

#### `openhands.sdk.ImageContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

#### `openhands.sdk.ImageContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

#### `openhands.sdk.ImageContent.type`

```python
type: Literal['image'] = 'image'
```

### `openhands.sdk.LLM`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[RetryMixin](#openhands.sdk.llm.llm.RetryMixin)</code>, <code>[NonNativeToolCallingMixin](#openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin)</code>

Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.

**Functions:**

- [**completion**](#openhands.sdk.LLM.completion) – Single entry point for LLM completion.
- [**deserialize**](#openhands.sdk.LLM.deserialize) – Deserialize LLM from dictionary.
- [**format_messages_for_llm**](#openhands.sdk.LLM.format_messages_for_llm) – Format Message objects for LLM consumption.
- [**get_token_count**](#openhands.sdk.LLM.get_token_count) – Get token count for messages.
- [**is_caching_prompt_active**](#openhands.sdk.LLM.is_caching_prompt_active) – Check if prompt caching is supported and enabled for current model.
- [**is_function_calling_active**](#openhands.sdk.LLM.is_function_calling_active) – Check whether function calling is supported and enabled for this LLM.
- [**load_from_env**](#openhands.sdk.LLM.load_from_env) – Load LLM from environment variables.
- [**load_from_json**](#openhands.sdk.LLM.load_from_json) – Load LLM from JSON file.
- [**load_from_toml**](#openhands.sdk.LLM.load_from_toml) – Load LLM from TOML file.
- [**resolve_diff_from_deserialized**](#openhands.sdk.LLM.resolve_diff_from_deserialized) – Resolve differences between a deserialized LLM and the current instance.
- [**retry_decorator**](#openhands.sdk.LLM.retry_decorator) – Create a retry decorator with exponential backoff.
- [**serialize**](#openhands.sdk.LLM.serialize) – Serialize LLM to dictionary.
- [**vision_is_active**](#openhands.sdk.LLM.vision_is_active) – Check if vision capabilities are active.

**Attributes:**

- [**OVERRIDE_ON_SERIALIZE**](#openhands.sdk.LLM.OVERRIDE_ON_SERIALIZE) (<code>[tuple](#tuple)\[[str](#str), ...\]</code>) –
- [**api_key**](#openhands.sdk.LLM.api_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**api_version**](#openhands.sdk.LLM.api_version) (<code>[str](#str) | None</code>) –
- [**aws_access_key_id**](#openhands.sdk.LLM.aws_access_key_id) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**aws_region_name**](#openhands.sdk.LLM.aws_region_name) (<code>[str](#str) | None</code>) –
- [**aws_secret_access_key**](#openhands.sdk.LLM.aws_secret_access_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**base_url**](#openhands.sdk.LLM.base_url) (<code>[str](#str) | None</code>) –
- [**caching_prompt**](#openhands.sdk.LLM.caching_prompt) (<code>[bool](#bool)</code>) –
- [**custom_llm_provider**](#openhands.sdk.LLM.custom_llm_provider) (<code>[str](#str) | None</code>) –
- [**custom_tokenizer**](#openhands.sdk.LLM.custom_tokenizer) (<code>[str](#str) | None</code>) –
- [**disable_stop_word**](#openhands.sdk.LLM.disable_stop_word) (<code>[bool](#bool) | None</code>) –
- [**disable_vision**](#openhands.sdk.LLM.disable_vision) (<code>[bool](#bool) | None</code>) –
- [**drop_params**](#openhands.sdk.LLM.drop_params) (<code>[bool](#bool)</code>) –
- [**input_cost_per_token**](#openhands.sdk.LLM.input_cost_per_token) (<code>[float](#float) | None</code>) –
- [**log_completions**](#openhands.sdk.LLM.log_completions) (<code>[bool](#bool)</code>) –
- [**log_completions_folder**](#openhands.sdk.LLM.log_completions_folder) (<code>[str](#str)</code>) –
- [**max_input_tokens**](#openhands.sdk.LLM.max_input_tokens) (<code>[int](#int) | None</code>) –
- [**max_message_chars**](#openhands.sdk.LLM.max_message_chars) (<code>[int](#int)</code>) –
- [**max_output_tokens**](#openhands.sdk.LLM.max_output_tokens) (<code>[int](#int) | None</code>) –
- [**metrics**](#openhands.sdk.LLM.metrics) (<code>[Metrics](#openhands.sdk.llm.utils.metrics.Metrics) | None</code>) –
- [**model**](#openhands.sdk.LLM.model) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.LLM.model_config) –
- [**model_info**](#openhands.sdk.LLM.model_info) (<code>[dict](#dict) | None</code>) – Returns the model info dictionary.
- [**modify_params**](#openhands.sdk.LLM.modify_params) (<code>[bool](#bool)</code>) –
- [**native_tool_calling**](#openhands.sdk.LLM.native_tool_calling) (<code>[bool](#bool) | None</code>) –
- [**num_retries**](#openhands.sdk.LLM.num_retries) (<code>[int](#int)</code>) –
- [**ollama_base_url**](#openhands.sdk.LLM.ollama_base_url) (<code>[str](#str) | None</code>) –
- [**openrouter_app_name**](#openhands.sdk.LLM.openrouter_app_name) (<code>[str](#str)</code>) –
- [**openrouter_site_url**](#openhands.sdk.LLM.openrouter_site_url) (<code>[str](#str)</code>) –
- [**output_cost_per_token**](#openhands.sdk.LLM.output_cost_per_token) (<code>[float](#float) | None</code>) –
- [**reasoning_effort**](#openhands.sdk.LLM.reasoning_effort) (<code>[Literal](#typing.Literal)['low', 'medium', 'high', 'none'] | None</code>) –
- [**retry_listener**](#openhands.sdk.LLM.retry_listener) (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) –
- [**retry_max_wait**](#openhands.sdk.LLM.retry_max_wait) (<code>[int](#int)</code>) –
- [**retry_min_wait**](#openhands.sdk.LLM.retry_min_wait) (<code>[int](#int)</code>) –
- [**retry_multiplier**](#openhands.sdk.LLM.retry_multiplier) (<code>[float](#float)</code>) –
- [**safety_settings**](#openhands.sdk.LLM.safety_settings) (<code>[list](#list)\[[dict](#dict)\[[str](#str), [str](#str)\]\] | None</code>) –
- [**seed**](#openhands.sdk.LLM.seed) (<code>[int](#int) | None</code>) –
- [**service_id**](#openhands.sdk.LLM.service_id) (<code>[str](#str)</code>) –
- [**temperature**](#openhands.sdk.LLM.temperature) (<code>[float](#float) | None</code>) –
- [**timeout**](#openhands.sdk.LLM.timeout) (<code>[int](#int) | None</code>) –
- [**top_k**](#openhands.sdk.LLM.top_k) (<code>[float](#float) | None</code>) –
- [**top_p**](#openhands.sdk.LLM.top_p) (<code>[float](#float) | None</code>) –

#### `openhands.sdk.LLM.OVERRIDE_ON_SERIALIZE`

```python
OVERRIDE_ON_SERIALIZE: tuple[str, ...] = ('api_key', 'aws_access_key_id', 'aws_secret_access_key')
```

#### `openhands.sdk.LLM.api_key`

```python
api_key: SecretStr | None = Field(default=None, description='API key.')
```

#### `openhands.sdk.LLM.api_version`

```python
api_version: str | None = Field(default=None, description='API version (e.g., Azure).')
```

#### `openhands.sdk.LLM.aws_access_key_id`

```python
aws_access_key_id: SecretStr | None = Field(default=None)
```

#### `openhands.sdk.LLM.aws_region_name`

```python
aws_region_name: str | None = Field(default=None)
```

#### `openhands.sdk.LLM.aws_secret_access_key`

```python
aws_secret_access_key: SecretStr | None = Field(default=None)
```

#### `openhands.sdk.LLM.base_url`

```python
base_url: str | None = Field(default=None, description='Custom base URL.')
```

#### `openhands.sdk.LLM.caching_prompt`

```python
caching_prompt: bool = Field(default=True, description='Enable caching of prompts.')
```

#### `openhands.sdk.LLM.completion`

```python
completion(messages, tools=None, return_metrics=False, **kwargs)
```

Single entry point for LLM completion.

Normalize → (maybe) mock tools → transport → postprocess.

#### `openhands.sdk.LLM.custom_llm_provider`

```python
custom_llm_provider: str | None = Field(default=None)
```

#### `openhands.sdk.LLM.custom_tokenizer`

```python
custom_tokenizer: str | None = Field(default=None, description='A custom tokenizer to use for token counting.')
```

#### `openhands.sdk.LLM.deserialize`

```python
deserialize(data)
```

Deserialize LLM from dictionary.

#### `openhands.sdk.LLM.disable_stop_word`

```python
disable_stop_word: bool | None = Field(default=False, description='Disable using of stop word.')
```

#### `openhands.sdk.LLM.disable_vision`

```python
disable_vision: bool | None = Field(default=None, description='If model is vision capable, this option allows to disable image processing (useful for cost reduction).')
```

#### `openhands.sdk.LLM.drop_params`

```python
drop_params: bool = Field(default=True)
```

#### `openhands.sdk.LLM.format_messages_for_llm`

```python
format_messages_for_llm(messages)
```

Format Message objects for LLM consumption.

**Parameters:**

- **messages** (<code>[list](#list)\[[Message](#openhands.sdk.llm.message.Message)\]</code>) – List of Message objects to format.

**Returns:**

- <code>[list](#list)\[[dict](#dict)\]</code> – List of dictionaries formatted for LLM consumption.

#### `openhands.sdk.LLM.get_token_count`

```python
get_token_count(messages)
```

Get token count for messages.

#### `openhands.sdk.LLM.input_cost_per_token`

```python
input_cost_per_token: float | None = Field(default=None, description='The cost per input token. This will available in logs for user.')
```

#### `openhands.sdk.LLM.is_caching_prompt_active`

```python
is_caching_prompt_active()
```

Check if prompt caching is supported and enabled for current model.

**Returns:**

- **boolean** (<code>[bool](#bool)</code>) – True if prompt caching is supported and enabled for the given
  model.

#### `openhands.sdk.LLM.is_function_calling_active`

```python
is_function_calling_active()
```

Check whether function calling is supported and enabled for this LLM.

**Returns:**

- <code>[bool](#bool)</code> – True if function calling is active, False otherwise.

#### `openhands.sdk.LLM.load_from_env`

```python
load_from_env(prefix='LLM_')
```

Load LLM from environment variables.

#### `openhands.sdk.LLM.load_from_json`

```python
load_from_json(json_path)
```

Load LLM from JSON file.

#### `openhands.sdk.LLM.load_from_toml`

```python
load_from_toml(toml_path)
```

Load LLM from TOML file.

#### `openhands.sdk.LLM.log_completions`

```python
log_completions: bool = Field(default=False, description='Enable logging of completions.')
```

#### `openhands.sdk.LLM.log_completions_folder`

```python
log_completions_folder: str = Field(default=(os.path.join(ENV_LOG_DIR, 'completions')), description='The folder to log LLM completions to. Required if log_completions is True.')
```

#### `openhands.sdk.LLM.max_input_tokens`

```python
max_input_tokens: int | None = Field(default=None, description='The maximum number of input tokens. Note that this is currently unused, and the value at runtime is actually the total tokens in OpenAI (e.g. 128,000 tokens for GPT-4).')
```

#### `openhands.sdk.LLM.max_message_chars`

```python
max_message_chars: int = Field(default=30000, description='Approx max chars in each event/content sent to the LLM.')
```

#### `openhands.sdk.LLM.max_output_tokens`

```python
max_output_tokens: int | None = Field(default=None, description='The maximum number of output tokens. This is sent to the LLM.')
```

#### `openhands.sdk.LLM.metrics`

```python
metrics: Metrics | None = Field(default=None, exclude=True)
```

#### `openhands.sdk.LLM.model`

```python
model: str = Field(default='claude-sonnet-4-20250514', description='Model name.')
```

#### `openhands.sdk.LLM.model_config`

```python
model_config = ConfigDict(extra='forbid', arbitrary_types_allowed=True)
```

#### `openhands.sdk.LLM.model_info`

```python
model_info: dict | None
```

Returns the model info dictionary.

#### `openhands.sdk.LLM.modify_params`

```python
modify_params: bool = Field(default=True, description='Modify params allows litellm to do transformations like adding a default message, when a message is empty.')
```

#### `openhands.sdk.LLM.native_tool_calling`

```python
native_tool_calling: bool | None = Field(default=None, description='Whether to use native tool calling if supported by the model. Can be True, False, or not set.')
```

#### `openhands.sdk.LLM.num_retries`

```python
num_retries: int = Field(default=5)
```

#### `openhands.sdk.LLM.ollama_base_url`

```python
ollama_base_url: str | None = Field(default=None)
```

#### `openhands.sdk.LLM.openrouter_app_name`

```python
openrouter_app_name: str = Field(default='OpenHands')
```

#### `openhands.sdk.LLM.openrouter_site_url`

```python
openrouter_site_url: str = Field(default='https://docs.all-hands.dev/')
```

#### `openhands.sdk.LLM.output_cost_per_token`

```python
output_cost_per_token: float | None = Field(default=None, description='The cost per output token. This will available in logs for user.')
```

#### `openhands.sdk.LLM.reasoning_effort`

```python
reasoning_effort: Literal['low', 'medium', 'high', 'none'] | None = Field(default=None, description="The effort to put into reasoning. This is a string that can be one of 'low', 'medium', 'high', or 'none'. Can apply to all reasoning models.")
```

#### `openhands.sdk.LLM.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Resolve differences between a deserialized LLM and the current instance.

This is due to fields like api_key being serialized to "\*\*\*\*" in dumps,
and we want to ensure that when loading from a file, we still use the
runtime-provided api_key in the self instance.

Return a new LLM instance equivalent to `persisted` but with
explicitly whitelisted fields (e.g. api_key) taken from `self`.

#### `openhands.sdk.LLM.retry_decorator`

```python
retry_decorator(*, num_retries, retry_exceptions, retry_min_wait, retry_max_wait, retry_multiplier, retry_listener=None)
```

Create a retry decorator with exponential backoff.

#### `openhands.sdk.LLM.retry_listener`

```python
retry_listener: Callable[[int, int], None] | None = Field(default=None, exclude=True)
```

#### `openhands.sdk.LLM.retry_max_wait`

```python
retry_max_wait: int = Field(default=64)
```

#### `openhands.sdk.LLM.retry_min_wait`

```python
retry_min_wait: int = Field(default=8)
```

#### `openhands.sdk.LLM.retry_multiplier`

```python
retry_multiplier: float = Field(default=8)
```

#### `openhands.sdk.LLM.safety_settings`

```python
safety_settings: list[dict[str, str]] | None = Field(default=None, description='Safety settings for models that support them (like Mistral AI and Gemini)')
```

#### `openhands.sdk.LLM.seed`

```python
seed: int | None = Field(default=None, description='The seed to use for random number generation.')
```

#### `openhands.sdk.LLM.serialize`

```python
serialize()
```

Serialize LLM to dictionary.

#### `openhands.sdk.LLM.service_id`

```python
service_id: str = Field(default='default', exclude=True)
```

#### `openhands.sdk.LLM.temperature`

```python
temperature: float | None = Field(default=0.0)
```

#### `openhands.sdk.LLM.timeout`

```python
timeout: int | None = Field(default=None, description='HTTP timeout (s).')
```

#### `openhands.sdk.LLM.top_k`

```python
top_k: float | None = Field(default=None)
```

#### `openhands.sdk.LLM.top_p`

```python
top_p: float | None = Field(default=1.0)
```

#### `openhands.sdk.LLM.vision_is_active`

```python
vision_is_active()
```

Check if vision capabilities are active.

### `openhands.sdk.LLMConvertibleEvent`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>, <code>[ABC](#abc.ABC)</code>

Base class for events that can be converted to LLM messages.

**Functions:**

- [**events_to_messages**](#openhands.sdk.LLMConvertibleEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.LLMConvertibleEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.LLMConvertibleEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.LLMConvertibleEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.LLMConvertibleEvent.to_llm_message) – Convert the event to an LLM message.

**Attributes:**

- [**id**](#openhands.sdk.LLMConvertibleEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.LLMConvertibleEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.LLMConvertibleEvent.model_config) –
- [**source**](#openhands.sdk.LLMConvertibleEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.LLMConvertibleEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.LLMConvertibleEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

#### `openhands.sdk.LLMConvertibleEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

#### `openhands.sdk.LLMConvertibleEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

#### `openhands.sdk.LLMConvertibleEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.LLMConvertibleEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.sdk.LLMConvertibleEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.LLMConvertibleEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.LLMConvertibleEvent.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

#### `openhands.sdk.LLMConvertibleEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.LLMConvertibleEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

#### `openhands.sdk.LLMConvertibleEvent.to_llm_message`

```python
to_llm_message()
```

Convert the event to an LLM message.

#### `openhands.sdk.LLMConvertibleEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

### `openhands.sdk.LLMRegistry`

```python
LLMRegistry(retry_listener=None)
```

A minimal LLM registry for managing LLM instances by service ID.

This registry provides a simple way to manage multiple LLM instances,
avoiding the need to recreate LLMs with the same configuration.

**Functions:**

- [**add**](#openhands.sdk.LLMRegistry.add) – Add an LLM instance to the registry.
- [**get**](#openhands.sdk.LLMRegistry.get) – Get an LLM instance from the registry.
- [**list_services**](#openhands.sdk.LLMRegistry.list_services) – List all registered service IDs.
- [**notify**](#openhands.sdk.LLMRegistry.notify) – Notify subscribers of registry events.
- [**subscribe**](#openhands.sdk.LLMRegistry.subscribe) – Subscribe to registry events.

**Attributes:**

- [**registry_id**](#openhands.sdk.LLMRegistry.registry_id) –
- [**retry_listener**](#openhands.sdk.LLMRegistry.retry_listener) –
- [**service_to_llm**](#openhands.sdk.LLMRegistry.service_to_llm) (<code>[dict](#dict)\[[str](#str), [LLM](#openhands.sdk.llm.llm.LLM)\]</code>) –
- [**subscriber**](#openhands.sdk.LLMRegistry.subscriber) (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\] | None</code>) –

Initialize the LLM registry.

**Parameters:**

- **retry_listener** (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) – Optional callback for retry events.

#### `openhands.sdk.LLMRegistry.add`

```python
add(service_id, llm)
```

Add an LLM instance to the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.
- **llm** (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) – The LLM instance to register.

**Raises:**

- <code>[ValueError](#ValueError)</code> – If service_id already exists in the registry.

#### `openhands.sdk.LLMRegistry.get`

```python
get(service_id)
```

Get an LLM instance from the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.

**Returns:**

- <code>[LLM](#openhands.sdk.llm.llm.LLM)</code> – The LLM instance.

**Raises:**

- <code>[KeyError](#KeyError)</code> – If service_id is not found in the registry.

#### `openhands.sdk.LLMRegistry.list_services`

```python
list_services()
```

List all registered service IDs.

**Returns:**

- <code>[list](#list)\[[str](#str)\]</code> – List of service IDs currently in the registry.

#### `openhands.sdk.LLMRegistry.notify`

```python
notify(event)
```

Notify subscribers of registry events.

**Parameters:**

- **event** (<code>[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)</code>) – The registry event to notify about.

#### `openhands.sdk.LLMRegistry.registry_id`

```python
registry_id = str(uuid4())
```

#### `openhands.sdk.LLMRegistry.retry_listener`

```python
retry_listener = retry_listener
```

#### `openhands.sdk.LLMRegistry.service_to_llm`

```python
service_to_llm: dict[str, LLM] = {}
```

#### `openhands.sdk.LLMRegistry.subscribe`

```python
subscribe(callback)
```

Subscribe to registry events.

**Parameters:**

- **callback** (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\]</code>) – Function to call when LLMs are created or updated.

#### `openhands.sdk.LLMRegistry.subscriber`

```python
subscriber: Callable[[RegistryEvent], None] | None = None
```

### `openhands.sdk.LocalFileStore`

```python
LocalFileStore(root)
```

Bases: <code>[FileStore](#openhands.sdk.io.base.FileStore)</code>

Local file store implementation using the local filesystem.

This implementation provides file storage operations on the local filesystem
with automatic directory creation and graceful error handling.

**Attributes:**

- [**root**](#openhands.sdk.LocalFileStore.root) (<code>[str](#str)</code>) – The root directory path for all file operations.

**Functions:**

- [**delete**](#openhands.sdk.LocalFileStore.delete) – Delete a file or directory at the given path.
- [**get_full_path**](#openhands.sdk.LocalFileStore.get_full_path) – Get the full filesystem path for a given relative path.
- [**list**](#openhands.sdk.LocalFileStore.list) – List files and directories at the given path.
- [**read**](#openhands.sdk.LocalFileStore.read) – Read contents from a file at the given path.
- [**write**](#openhands.sdk.LocalFileStore.write) – Write contents to a file at the given path.

Initialize the local file store with a root directory.

**Parameters:**

- **root** (<code>[str](#str)</code>) – The root directory path. Supports tilde expansion (e.g., "~/data").
  If the directory doesn't exist, it will be created automatically.

#### `openhands.sdk.LocalFileStore.delete`

```python
delete(path)
```

Delete a file or directory at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete, relative to the root directory.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, this method returns silently without error.
For directories, all contents are recursively deleted.
Any errors during deletion are logged but do not raise exceptions.
</details>

#### `openhands.sdk.LocalFileStore.get_full_path`

```python
get_full_path(path)
```

Get the full filesystem path for a given relative path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The relative path within the file store.
  Leading slashes are automatically stripped.

**Returns:**

- <code>[str](#str)</code> – The absolute filesystem path.

#### `openhands.sdk.LocalFileStore.list`

```python
list(path)
```

List files and directories at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list, relative to the root directory.

**Returns:**

- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – A list of file and directory paths. Directory names end with "/".
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – (consistent with S3 API).

<details class="note" open>
<summary>Note</summary>
This method returns full paths relative to the root directory,
not just the filenames.
</details>

#### `openhands.sdk.LocalFileStore.read`

```python
read(path)
```

Read contents from a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from, relative to the root directory.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string (decoded with UTF-8).

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

#### `openhands.sdk.LocalFileStore.root`

```python
root: str = root
```

#### `openhands.sdk.LocalFileStore.write`

```python
write(path, contents)
```

Write contents to a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to, relative to the root directory.
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, they will be created
automatically. String content is written with UTF-8 encoding.
</details>

### `openhands.sdk.MCPClient`

```python
MCPClient(*args, **kwargs)
```

Bases: <code>[Client](#fastmcp.Client)</code>

Behaves exactly like fastmcp.Client (same constructor & async API).

<details class="owns-a-background-event-loop-and-offers" open>
<summary>Owns a background event loop and offers</summary>
- call_async_from_sync(awaitable_or_fn, *args, timeout=None, **kwargs)
- call_sync_from_async(fn, *args, **kwargs)  # await this from async code
</details>

**Functions:**

- [**call_async_from_sync**](#openhands.sdk.MCPClient.call_async_from_sync) – Run a coroutine or async function on this client's loop from sync code.
- [**call_sync_from_async**](#openhands.sdk.MCPClient.call_sync_from_async) – Await running a blocking function in the threadpool from async code.
- [**sync_close**](#openhands.sdk.MCPClient.sync_close) – Close the client synchronously.

Initialize the MCP client with background event loop support.

#### `openhands.sdk.MCPClient.call_async_from_sync`

```python
call_async_from_sync(awaitable_or_fn, *args, timeout, **kwargs)
```

Run a coroutine or async function on this client's loop from sync code.

<details class="usage" open>
<summary>Usage</summary>
mcp.call_async_from_sync(async_fn, arg1, kw=...)
mcp.call_async_from_sync(coro)
</details>

#### `openhands.sdk.MCPClient.call_sync_from_async`

```python
call_sync_from_async(fn, *args, **kwargs)
```

Await running a blocking function in the threadpool from async code.

#### `openhands.sdk.MCPClient.sync_close`

```python
sync_close()
```

Close the client synchronously.

### `openhands.sdk.MCPTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[MCPActionBase](#openhands.sdk.tool.MCPActionBase), [MCPToolObservation](#openhands.sdk.mcp.MCPToolObservation)\]</code>

MCP Tool that wraps an MCP client and provides tool functionality.

**Functions:**

- [**call**](#openhands.sdk.MCPTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.MCPTool.create) – Create an MCPTool from an MCP tool definition.
- [**model_validate**](#openhands.sdk.MCPTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.MCPTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.MCPTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.MCPTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.MCPTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.MCPTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.MCPTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.MCPTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.MCPTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.MCPTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.MCPTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.MCPTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**mcp_tool**](#openhands.sdk.MCPTool.mcp_tool) (<code>[Tool](#mcp.types.Tool)</code>) –
- [**meta**](#openhands.sdk.MCPTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.MCPTool.model_config) –
- [**name**](#openhands.sdk.MCPTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.MCPTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.MCPTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.MCPTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

#### `openhands.sdk.MCPTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

#### `openhands.sdk.MCPTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

#### `openhands.sdk.MCPTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

#### `openhands.sdk.MCPTool.create`

```python
create(mcp_tool, mcp_client)
```

Create an MCPTool from an MCP tool definition.

#### `openhands.sdk.MCPTool.description`

```python
description: str
```

#### `openhands.sdk.MCPTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.sdk.MCPTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

#### `openhands.sdk.MCPTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.MCPTool.mcp_tool`

```python
mcp_tool: mcp.types.Tool = Field(description='The MCP tool definition.')
```

#### `openhands.sdk.MCPTool.meta`

```python
meta: dict[str, Any] | None = None
```

#### `openhands.sdk.MCPTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.sdk.MCPTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.MCPTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.MCPTool.name`

```python
name: str
```

#### `openhands.sdk.MCPTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

#### `openhands.sdk.MCPTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

#### `openhands.sdk.MCPTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

#### `openhands.sdk.MCPTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.MCPTool.title`

```python
title: str
```

Get the title for the tool.

#### `openhands.sdk.MCPTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

#### `openhands.sdk.MCPTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

### `openhands.sdk.Message`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Message for LLM communication.

**Functions:**

- [**from_litellm_message**](#openhands.sdk.Message.from_litellm_message) – Convert a LiteLLMMessage to our Message class.
- [**to_llm_dict**](#openhands.sdk.Message.to_llm_dict) – Serialize message for LLM API consumption.

**Attributes:**

- [**cache_enabled**](#openhands.sdk.Message.cache_enabled) (<code>[bool](#bool)</code>) –
- [**contains_image**](#openhands.sdk.Message.contains_image) (<code>[bool](#bool)</code>) – Check if message contains image content.
- [**content**](#openhands.sdk.Message.content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) –
- [**force_string_serializer**](#openhands.sdk.Message.force_string_serializer) (<code>[bool](#bool)</code>) –
- [**function_calling_enabled**](#openhands.sdk.Message.function_calling_enabled) (<code>[bool](#bool)</code>) –
- [**name**](#openhands.sdk.Message.name) (<code>[str](#str) | None</code>) –
- [**reasoning_content**](#openhands.sdk.Message.reasoning_content) (<code>[str](#str) | None</code>) –
- [**role**](#openhands.sdk.Message.role) (<code>[Literal](#typing.Literal)['user', 'system', 'assistant', 'tool']</code>) –
- [**tool_call_id**](#openhands.sdk.Message.tool_call_id) (<code>[str](#str) | None</code>) –
- [**tool_calls**](#openhands.sdk.Message.tool_calls) (<code>[list](#list)\[[ChatCompletionMessageToolCall](#litellm.ChatCompletionMessageToolCall)\] | None</code>) –
- [**vision_enabled**](#openhands.sdk.Message.vision_enabled) (<code>[bool](#bool)</code>) –

#### `openhands.sdk.Message.cache_enabled`

```python
cache_enabled: bool = False
```

#### `openhands.sdk.Message.contains_image`

```python
contains_image: bool
```

Check if message contains image content.

#### `openhands.sdk.Message.content`

```python
content: list[TextContent | ImageContent] = Field(default_factory=list)
```

#### `openhands.sdk.Message.force_string_serializer`

```python
force_string_serializer: bool = False
```

#### `openhands.sdk.Message.from_litellm_message`

```python
from_litellm_message(message)
```

Convert a LiteLLMMessage to our Message class.

Provider-agnostic mapping for reasoning:

- Prefer `message.reasoning_content` if present (LiteLLM normalized field)

#### `openhands.sdk.Message.function_calling_enabled`

```python
function_calling_enabled: bool = False
```

#### `openhands.sdk.Message.name`

```python
name: str | None = None
```

#### `openhands.sdk.Message.reasoning_content`

```python
reasoning_content: str | None = Field(default=None, description='Intermediate reasoning/thinking content from reasoning models')
```

#### `openhands.sdk.Message.role`

```python
role: Literal['user', 'system', 'assistant', 'tool']
```

#### `openhands.sdk.Message.to_llm_dict`

```python
to_llm_dict()
```

Serialize message for LLM API consumption.

This method chooses the appropriate serialization format based on the message
configuration and provider capabilities:

- String format: for providers that don't support list of content items
- List format: for providers with vision/prompt caching/tool calls support

#### `openhands.sdk.Message.tool_call_id`

```python
tool_call_id: str | None = None
```

#### `openhands.sdk.Message.tool_calls`

```python
tool_calls: list[ChatCompletionMessageToolCall] | None = None
```

#### `openhands.sdk.Message.vision_enabled`

```python
vision_enabled: bool = False
```

### `openhands.sdk.ObservationBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for output observation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.ObservationBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.ObservationBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.ObservationBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.ObservationBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.ObservationBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.ObservationBase.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the observation string to show to the agent.
- [**kind**](#openhands.sdk.ObservationBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.ObservationBase.model_config) –
- [**visualize**](#openhands.sdk.ObservationBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

#### `openhands.sdk.ObservationBase.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the observation string to show to the agent.

#### `openhands.sdk.ObservationBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.sdk.ObservationBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.ObservationBase.model_config`

```python
model_config = ConfigDict(extra='allow')
```

#### `openhands.sdk.ObservationBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.ObservationBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.ObservationBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.ObservationBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.sdk.ObservationBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

### `openhands.sdk.RegistryEvent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Event representing LLM registration or deregistration.

**Attributes:**

- [**llm**](#openhands.sdk.RegistryEvent.llm) (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.RegistryEvent.model_config) –
- [**service_id**](#openhands.sdk.RegistryEvent.service_id) (<code>[str](#str)</code>) –

#### `openhands.sdk.RegistryEvent.llm`

```python
llm: LLM
```

#### `openhands.sdk.RegistryEvent.model_config`

```python
model_config = ConfigDict(arbitrary_types_allowed=True)
```

#### `openhands.sdk.RegistryEvent.service_id`

```python
service_id: str
```

### `openhands.sdk.TextContent`

Bases: <code>[TextContent](#mcp.types.TextContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Text content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.TextContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.TextContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**model_config**](#openhands.sdk.TextContent.model_config) –
- [**text**](#openhands.sdk.TextContent.text) (<code>[str](#str)</code>) –
- [**type**](#openhands.sdk.TextContent.type) (<code>[Literal](#typing.Literal)['text']</code>) –

#### `openhands.sdk.TextContent.cache_prompt`

```python
cache_prompt: bool = False
```

#### `openhands.sdk.TextContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

#### `openhands.sdk.TextContent.text`

```python
text: str
```

#### `openhands.sdk.TextContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

#### `openhands.sdk.TextContent.type`

```python
type: Literal['text'] = 'text'
```

### `openhands.sdk.Tool`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[Generic](#typing.Generic)\[[ActionT](#openhands.sdk.tool.tool.ActionT), [ObservationT](#openhands.sdk.tool.tool.ObservationT)\]</code>

Tool that wraps an executor function with input/output validation and schema.

- Normalize input/output schemas (class or dict) into both model+schema.
- Validate inputs before execute.
- Coerce outputs only if an output model is defined; else return vanilla JSON.
- Export MCP tool description.

**Functions:**

- [**call**](#openhands.sdk.Tool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.Tool.create) – Create a Tool instance. Placeholder for subclasses.
- [**model_validate**](#openhands.sdk.Tool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.Tool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.Tool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.Tool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.Tool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.Tool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.Tool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.Tool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.Tool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.Tool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.Tool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.Tool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.sdk.Tool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.Tool.model_config) –
- [**name**](#openhands.sdk.Tool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.Tool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.Tool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.Tool.title) (<code>[str](#str)</code>) – Get the title for the tool.

#### `openhands.sdk.Tool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

#### `openhands.sdk.Tool.annotations`

```python
annotations: ToolAnnotations | None = None
```

#### `openhands.sdk.Tool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

#### `openhands.sdk.Tool.create`

```python
create(*args, **kwargs)
```

Create a Tool instance. Placeholder for subclasses.

This can be overridden in subclasses to provide custom initialization logic
(e.g., typically initializing the executor with parameters).

#### `openhands.sdk.Tool.description`

```python
description: str
```

#### `openhands.sdk.Tool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.sdk.Tool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

#### `openhands.sdk.Tool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.sdk.Tool.meta`

```python
meta: dict[str, Any] | None = None
```

#### `openhands.sdk.Tool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.sdk.Tool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.sdk.Tool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.sdk.Tool.name`

```python
name: str
```

#### `openhands.sdk.Tool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

#### `openhands.sdk.Tool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

#### `openhands.sdk.Tool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

#### `openhands.sdk.Tool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.sdk.Tool.title`

```python
title: str
```

Get the title for the tool.

#### `openhands.sdk.Tool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

#### `openhands.sdk.Tool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

### `openhands.sdk.agent`

Agent module - Core agent implementations.

**Modules:**

- [**agent**](#openhands.sdk.agent.agent) – Main agent implementation for OpenHands.
- [**base**](#openhands.sdk.agent.base) – Base classes for OpenHands agents.

**Classes:**

- [**Agent**](#openhands.sdk.agent.Agent) – Main agent implementation for OpenHands.
- [**AgentBase**](#openhands.sdk.agent.AgentBase) – Base class for all OpenHands agents.

**Attributes:**

- [**AgentType**](#openhands.sdk.agent.AgentType) –

#### `openhands.sdk.agent.Agent`

Bases: <code>[AgentBase](#openhands.sdk.agent.base.AgentBase)</code>

Main agent implementation for OpenHands.

**Functions:**

- [**init_state**](#openhands.sdk.agent.Agent.init_state) – Initialize the conversation state with system prompt.
- [**model_dump_succint**](#openhands.sdk.agent.Agent.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.agent.Agent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.agent.Agent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.agent.Agent.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.agent.Agent.step) – Execute one step of the agent conversation.
- [**target_subclass**](#openhands.sdk.agent.Agent.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.agent.Agent.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**cli_mode**](#openhands.sdk.agent.Agent.cli_mode) (<code>[bool](#bool)</code>) –
- [**condenser**](#openhands.sdk.agent.Agent.condenser) (<code>[Condenser](#openhands.sdk.context.condenser.Condenser) | None</code>) –
- [**kind**](#openhands.sdk.agent.Agent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.agent.Agent.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.agent.Agent.model_config) –
- [**name**](#openhands.sdk.agent.Agent.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.agent.Agent.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**system_message**](#openhands.sdk.agent.Agent.system_message) (<code>[str](#str)</code>) – Compute system message on-demand to maintain statelessness.
- [**system_prompt_filename**](#openhands.sdk.agent.Agent.system_prompt_filename) (<code>[str](#str)</code>) –
- [**tools**](#openhands.sdk.agent.Agent.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

##### `openhands.sdk.agent.Agent.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

##### `openhands.sdk.agent.Agent.cli_mode`

```python
cli_mode: bool = Field(default=True)
```

##### `openhands.sdk.agent.Agent.condenser`

```python
condenser: Condenser | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.sdk.agent.Agent.init_state`

```python
init_state(state, on_event)
```

Initialize the conversation state with system prompt.

##### `openhands.sdk.agent.Agent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.agent.Agent.llm`

```python
llm: LLM
```

##### `openhands.sdk.agent.Agent.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.sdk.agent.Agent.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

##### `openhands.sdk.agent.Agent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.agent.Agent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.agent.Agent.name`

```python
name: str
```

Returns the name of the Agent.

##### `openhands.sdk.agent.Agent.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

##### `openhands.sdk.agent.Agent.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

##### `openhands.sdk.agent.Agent.step`

```python
step(state, on_event)
```

Execute one step of the agent conversation.

##### `openhands.sdk.agent.Agent.system_message`

```python
system_message: str
```

Compute system message on-demand to maintain statelessness.

##### `openhands.sdk.agent.Agent.system_prompt_filename`

```python
system_prompt_filename: str = Field(default='system_prompt.j2')
```

##### `openhands.sdk.agent.Agent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.agent.Agent.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

#### `openhands.sdk.agent.AgentBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all OpenHands agents.

**Functions:**

- [**init_state**](#openhands.sdk.agent.AgentBase.init_state) – Initialize the empty conversation state to prepare the agent.
- [**model_dump_succint**](#openhands.sdk.agent.AgentBase.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.agent.AgentBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.agent.AgentBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.agent.AgentBase.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.agent.AgentBase.step) – Take a step in the conversation.
- [**target_subclass**](#openhands.sdk.agent.AgentBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.agent.AgentBase.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**kind**](#openhands.sdk.agent.AgentBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.agent.AgentBase.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.agent.AgentBase.model_config) –
- [**name**](#openhands.sdk.agent.AgentBase.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.agent.AgentBase.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**tools**](#openhands.sdk.agent.AgentBase.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

##### `openhands.sdk.agent.AgentBase.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

##### `openhands.sdk.agent.AgentBase.init_state`

```python
init_state(state, on_event)
```

Initialize the empty conversation state to prepare the agent.

Typically this involves adding system message

NOTE: state will be mutated in-place.

##### `openhands.sdk.agent.AgentBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.agent.AgentBase.llm`

```python
llm: LLM
```

##### `openhands.sdk.agent.AgentBase.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.sdk.agent.AgentBase.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

##### `openhands.sdk.agent.AgentBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.agent.AgentBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.agent.AgentBase.name`

```python
name: str
```

Returns the name of the Agent.

##### `openhands.sdk.agent.AgentBase.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

##### `openhands.sdk.agent.AgentBase.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

##### `openhands.sdk.agent.AgentBase.step`

```python
step(state, on_event)
```

Take a step in the conversation.

Typically this involves:

1. Making a LLM call
1. Executing the tool
1. Updating the conversation state with
   LLM calls (role="assistant") and tool results (role="tool")
   4.1 If conversation is finished, set state.agent_finished flag
   4.2 Otherwise, just return, Conversation will kick off the next step

NOTE: state will be mutated in-place.

##### `openhands.sdk.agent.AgentBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.agent.AgentBase.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

#### `openhands.sdk.agent.AgentType`

```python
AgentType = Annotated[AgentBase, DiscriminatedUnionType[AgentBase]]
```

#### `openhands.sdk.agent.agent`

Main agent implementation for OpenHands.

**Classes:**

- [**Agent**](#openhands.sdk.agent.agent.Agent) – Main agent implementation for OpenHands.

**Attributes:**

- [**logger**](#openhands.sdk.agent.agent.logger) –

##### `openhands.sdk.agent.agent.Agent`

Bases: <code>[AgentBase](#openhands.sdk.agent.base.AgentBase)</code>

Main agent implementation for OpenHands.

**Functions:**

- [**init_state**](#openhands.sdk.agent.agent.Agent.init_state) – Initialize the conversation state with system prompt.
- [**model_dump_succint**](#openhands.sdk.agent.agent.Agent.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.agent.agent.Agent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.agent.agent.Agent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.agent.agent.Agent.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.agent.agent.Agent.step) – Execute one step of the agent conversation.
- [**target_subclass**](#openhands.sdk.agent.agent.Agent.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.agent.agent.Agent.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**cli_mode**](#openhands.sdk.agent.agent.Agent.cli_mode) (<code>[bool](#bool)</code>) –
- [**condenser**](#openhands.sdk.agent.agent.Agent.condenser) (<code>[Condenser](#openhands.sdk.context.condenser.Condenser) | None</code>) –
- [**kind**](#openhands.sdk.agent.agent.Agent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.agent.agent.Agent.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.agent.agent.Agent.model_config) –
- [**name**](#openhands.sdk.agent.agent.Agent.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.agent.agent.Agent.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**system_message**](#openhands.sdk.agent.agent.Agent.system_message) (<code>[str](#str)</code>) – Compute system message on-demand to maintain statelessness.
- [**system_prompt_filename**](#openhands.sdk.agent.agent.Agent.system_prompt_filename) (<code>[str](#str)</code>) –
- [**tools**](#openhands.sdk.agent.agent.Agent.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

###### `openhands.sdk.agent.agent.Agent.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

###### `openhands.sdk.agent.agent.Agent.cli_mode`

```python
cli_mode: bool = Field(default=True)
```

###### `openhands.sdk.agent.agent.Agent.condenser`

```python
condenser: Condenser | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.sdk.agent.agent.Agent.init_state`

```python
init_state(state, on_event)
```

Initialize the conversation state with system prompt.

###### `openhands.sdk.agent.agent.Agent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.agent.agent.Agent.llm`

```python
llm: LLM
```

###### `openhands.sdk.agent.agent.Agent.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.sdk.agent.agent.Agent.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

###### `openhands.sdk.agent.agent.Agent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.agent.agent.Agent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.agent.agent.Agent.name`

```python
name: str
```

Returns the name of the Agent.

###### `openhands.sdk.agent.agent.Agent.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

###### `openhands.sdk.agent.agent.Agent.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

###### `openhands.sdk.agent.agent.Agent.step`

```python
step(state, on_event)
```

Execute one step of the agent conversation.

###### `openhands.sdk.agent.agent.Agent.system_message`

```python
system_message: str
```

Compute system message on-demand to maintain statelessness.

###### `openhands.sdk.agent.agent.Agent.system_prompt_filename`

```python
system_prompt_filename: str = Field(default='system_prompt.j2')
```

###### `openhands.sdk.agent.agent.Agent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.agent.agent.Agent.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

##### `openhands.sdk.agent.agent.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.agent.base`

Base classes for OpenHands agents.

**Classes:**

- [**AgentBase**](#openhands.sdk.agent.base.AgentBase) – Base class for all OpenHands agents.

**Attributes:**

- [**AgentType**](#openhands.sdk.agent.base.AgentType) –
- [**logger**](#openhands.sdk.agent.base.logger) –

##### `openhands.sdk.agent.base.AgentBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all OpenHands agents.

**Functions:**

- [**init_state**](#openhands.sdk.agent.base.AgentBase.init_state) – Initialize the empty conversation state to prepare the agent.
- [**model_dump_succint**](#openhands.sdk.agent.base.AgentBase.model_dump_succint) – Like model_dump, but excludes None fields by default.
- [**model_validate**](#openhands.sdk.agent.base.AgentBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.agent.base.AgentBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**resolve_diff_from_deserialized**](#openhands.sdk.agent.base.AgentBase.resolve_diff_from_deserialized) – Return a new AgentBase instance equivalent to `persisted`.
- [**step**](#openhands.sdk.agent.base.AgentBase.step) – Take a step in the conversation.
- [**target_subclass**](#openhands.sdk.agent.base.AgentBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**agent_context**](#openhands.sdk.agent.base.AgentBase.agent_context) (<code>[AgentContext](#openhands.sdk.context.agent_context.AgentContext) | None</code>) –
- [**kind**](#openhands.sdk.agent.base.AgentBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm**](#openhands.sdk.agent.base.AgentBase.llm) (<code>[LLM](#openhands.sdk.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.agent.base.AgentBase.model_config) –
- [**name**](#openhands.sdk.agent.base.AgentBase.name) (<code>[str](#str)</code>) – Returns the name of the Agent.
- [**prompt_dir**](#openhands.sdk.agent.base.AgentBase.prompt_dir) (<code>[str](#str)</code>) – Returns the directory where this class's module file is located.
- [**tools**](#openhands.sdk.agent.base.AgentBase.tools) (<code>[dict](#dict)\[[str](#str), [ToolType](#openhands.sdk.tool.ToolType)\] | [Sequence](#typing.Sequence)\[[ToolType](#openhands.sdk.tool.ToolType)\]</code>) –

###### `openhands.sdk.agent.base.AgentBase.agent_context`

```python
agent_context: AgentContext | None = Field(default=None)
```

###### `openhands.sdk.agent.base.AgentBase.init_state`

```python
init_state(state, on_event)
```

Initialize the empty conversation state to prepare the agent.

Typically this involves adding system message

NOTE: state will be mutated in-place.

###### `openhands.sdk.agent.base.AgentBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.agent.base.AgentBase.llm`

```python
llm: LLM
```

###### `openhands.sdk.agent.base.AgentBase.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.sdk.agent.base.AgentBase.model_dump_succint`

```python
model_dump_succint(**kwargs)
```

Like model_dump, but excludes None fields by default.

###### `openhands.sdk.agent.base.AgentBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.agent.base.AgentBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.agent.base.AgentBase.name`

```python
name: str
```

Returns the name of the Agent.

###### `openhands.sdk.agent.base.AgentBase.prompt_dir`

```python
prompt_dir: str
```

Returns the directory where this class's module file is located.

###### `openhands.sdk.agent.base.AgentBase.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Return a new AgentBase instance equivalent to `persisted`.

Explicitly whitelisted fields (e.g. api_key) taken from `self`.

###### `openhands.sdk.agent.base.AgentBase.step`

```python
step(state, on_event)
```

Take a step in the conversation.

Typically this involves:

1. Making a LLM call
1. Executing the tool
1. Updating the conversation state with
   LLM calls (role="assistant") and tool results (role="tool")
   4.1 If conversation is finished, set state.agent_finished flag
   4.2 Otherwise, just return, Conversation will kick off the next step

NOTE: state will be mutated in-place.

###### `openhands.sdk.agent.base.AgentBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.agent.base.AgentBase.tools`

```python
tools: dict[str, ToolType] | Sequence[ToolType] = Field(default_factory=dict, description='Mapping of tool name to Tool instance that the agent can use. If a list is provided, it should be converted to a mapping by tool name. We need to define this as ToolType for discriminated union.')
```

##### `openhands.sdk.agent.base.AgentType`

```python
AgentType = Annotated[AgentBase, DiscriminatedUnionType[AgentBase]]
```

##### `openhands.sdk.agent.base.logger`

```python
logger = get_logger(__name__)
```

### `openhands.sdk.context`

Context management module - Agent context and microagents.

**Modules:**

- [**agent_context**](#openhands.sdk.context.agent_context) – Agent context management for prompt extension and microagent integration.
- [**condenser**](#openhands.sdk.context.condenser) – Context condensers for managing conversation history.
- [**microagents**](#openhands.sdk.context.microagents) – Microagents - Specialized agents for specific tasks and knowledge domains.
- [**prompts**](#openhands.sdk.context.prompts) – Context utilities - Template rendering and prompt management.
- [**view**](#openhands.sdk.context.view) – View implementation for event processing and condensation.

**Classes:**

- [**AgentContext**](#openhands.sdk.context.AgentContext) – Central structure for managing prompt extension.
- [**BaseMicroagent**](#openhands.sdk.context.BaseMicroagent) – Base class for all microagents.
- [**KnowledgeMicroagent**](#openhands.sdk.context.KnowledgeMicroagent) – Knowledge micro-agents provide specialized expertise.
- [**MicroagentKnowledge**](#openhands.sdk.context.MicroagentKnowledge) – Represents knowledge from a triggered microagent.
- [**MicroagentMetadata**](#openhands.sdk.context.MicroagentMetadata) – Metadata for all microagents.
- [**MicroagentType**](#openhands.sdk.context.MicroagentType) – Type of microagent.
- [**MicroagentValidationError**](#openhands.sdk.context.MicroagentValidationError) – Raised when there's a validation error in microagent metadata.
- [**RepoMicroagent**](#openhands.sdk.context.RepoMicroagent) – Microagent specialized for repository-specific knowledge and guidelines.

**Functions:**

- [**load_microagents_from_dir**](#openhands.sdk.context.load_microagents_from_dir) – Load all microagents from the given directory.
- [**render_template**](#openhands.sdk.context.render_template) – Render a Jinja2 template with context and apply platform refinements.

#### `openhands.sdk.context.AgentContext`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Central structure for managing prompt extension.

AgentContext unifies all the contextual inputs that shape how the system
extends and interprets user prompts. It combines both static environment
details and dynamic, user-activated extensions from microagents.

Specifically, it provides:

- **Repository context / Repo Microagents**: Information about the active codebase,
  branches, and repo-specific instructions contributed by repo microagents.
- **Runtime context**: Current execution environment (hosts, working
  directory, secrets, date, etc.).
- **Conversation instructions**: Optional task- or channel-specific rules
  that constrain or guide the agent’s behavior across the session.
- **Knowledge Microagents**: Extensible components that can be triggered by user input
  to inject knowledge or domain-specific guidance.

Together, these elements make AgentContext the primary container responsible
for assembling, formatting, and injecting all prompt-relevant context into
LLM interactions.

**Functions:**

- [**get_system_message_suffix**](#openhands.sdk.context.AgentContext.get_system_message_suffix) – Get the system message with repo microagent content and custom suffix.
- [**get_user_message_suffix**](#openhands.sdk.context.AgentContext.get_user_message_suffix) – Augment the user’s message with knowledge recalled from microagents.

**Attributes:**

- [**microagents**](#openhands.sdk.context.AgentContext.microagents) (<code>[list](#list)\[[BaseMicroagent](#openhands.sdk.context.microagents.BaseMicroagent)\]</code>) –
- [**system_message_suffix**](#openhands.sdk.context.AgentContext.system_message_suffix) (<code>[str](#str) | None</code>) –
- [**user_message_suffix**](#openhands.sdk.context.AgentContext.user_message_suffix) (<code>[str](#str) | None</code>) –

##### `openhands.sdk.context.AgentContext.get_system_message_suffix`

```python
get_system_message_suffix()
```

Get the system message with repo microagent content and custom suffix.

Custom suffix can typically includes:

- Repository information (repo name, branch name, PR number, etc.)
- Runtime information (e.g., available hosts, current date)
- Conversation instructions (e.g., user preferences, task details)
- Repository-specific instructions (collected from repo microagents)

##### `openhands.sdk.context.AgentContext.get_user_message_suffix`

```python
get_user_message_suffix(user_message, skip_microagent_names)
```

Augment the user’s message with knowledge recalled from microagents.

This works by:

- Extracting the text content of the user message
- Matching microagent triggers against the query
- Returning formatted knowledge and triggered microagent names if relevant microagents were triggered

##### `openhands.sdk.context.AgentContext.microagents`

```python
microagents: list[BaseMicroagent] = Field(default_factory=list, description="List of available microagents that can extend the user's input.")
```

##### `openhands.sdk.context.AgentContext.system_message_suffix`

```python
system_message_suffix: str | None = Field(default=None, description='Optional suffix to append to the system prompt.')
```

##### `openhands.sdk.context.AgentContext.user_message_suffix`

```python
user_message_suffix: str | None = Field(default=None, description="Optional suffix to append to the user's message.")
```

#### `openhands.sdk.context.BaseMicroagent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Base class for all microagents.

**Functions:**

- [**load**](#openhands.sdk.context.BaseMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.BaseMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.BaseMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.BaseMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.BaseMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

##### `openhands.sdk.context.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

##### `openhands.sdk.context.BaseMicroagent.content`

```python
content: str
```

##### `openhands.sdk.context.BaseMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

##### `openhands.sdk.context.BaseMicroagent.name`

```python
name: str
```

##### `openhands.sdk.context.BaseMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

##### `openhands.sdk.context.BaseMicroagent.type`

```python
type: MicroagentType = Field(..., description='The type of the microagent')
```

#### `openhands.sdk.context.KnowledgeMicroagent`

```python
KnowledgeMicroagent(**data)
```

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Knowledge micro-agents provide specialized expertise.

Triggered by keywords in conversations.

They help with:

- Language best practices
- Framework guidelines
- Common patterns
- Tool usage

**Functions:**

- [**load**](#openhands.sdk.context.KnowledgeMicroagent.load) – Load a microagent from a markdown file with frontmatter.
- [**match_trigger**](#openhands.sdk.context.KnowledgeMicroagent.match_trigger) – Match a trigger in the message.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.KnowledgeMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.KnowledgeMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.KnowledgeMicroagent.source) (<code>[str](#str) | None</code>) –
- [**triggers**](#openhands.sdk.context.KnowledgeMicroagent.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.KnowledgeMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

Initialize the knowledge microagent.

##### `openhands.sdk.context.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

##### `openhands.sdk.context.KnowledgeMicroagent.content`

```python
content: str
```

##### `openhands.sdk.context.KnowledgeMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

##### `openhands.sdk.context.KnowledgeMicroagent.match_trigger`

```python
match_trigger(message)
```

Match a trigger in the message.

It returns the first trigger that matches the message.

##### `openhands.sdk.context.KnowledgeMicroagent.name`

```python
name: str
```

##### `openhands.sdk.context.KnowledgeMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

##### `openhands.sdk.context.KnowledgeMicroagent.triggers`

```python
triggers: list[str] = Field(default_factory=list, description='List of triggers for the microagent')
```

##### `openhands.sdk.context.KnowledgeMicroagent.type`

```python
type: MicroagentType = MicroagentType.KNOWLEDGE
```

#### `openhands.sdk.context.MicroagentKnowledge`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Represents knowledge from a triggered microagent.

**Attributes:**

- [**content**](#openhands.sdk.context.MicroagentKnowledge.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.MicroagentKnowledge.name) (<code>[str](#str)</code>) –
- [**trigger**](#openhands.sdk.context.MicroagentKnowledge.trigger) (<code>[str](#str)</code>) –

##### `openhands.sdk.context.MicroagentKnowledge.content`

```python
content: str = Field(description='The actual content/knowledge from the microagent')
```

##### `openhands.sdk.context.MicroagentKnowledge.name`

```python
name: str = Field(description='The name of the microagent that was triggered')
```

##### `openhands.sdk.context.MicroagentKnowledge.trigger`

```python
trigger: str = Field(description='The word that triggered this microagent')
```

#### `openhands.sdk.context.MicroagentMetadata`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Metadata for all microagents.

**Attributes:**

- [**inputs**](#openhands.sdk.context.MicroagentMetadata.inputs) (<code>[list](#list)\[[InputMetadata](#openhands.sdk.context.microagents.types.InputMetadata)\]</code>) –
- [**mcp_tools**](#openhands.sdk.context.MicroagentMetadata.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | None</code>) –
- [**name**](#openhands.sdk.context.MicroagentMetadata.name) (<code>[str](#str)</code>) –
- [**triggers**](#openhands.sdk.context.MicroagentMetadata.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.MicroagentMetadata.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

##### `openhands.sdk.context.MicroagentMetadata.inputs`

```python
inputs: list[InputMetadata] = []
```

##### `openhands.sdk.context.MicroagentMetadata.mcp_tools`

```python
mcp_tools: MCPConfig | None = None
```

##### `openhands.sdk.context.MicroagentMetadata.name`

```python
name: str = Field('default', description='Unique name of the microagent')
```

##### `openhands.sdk.context.MicroagentMetadata.triggers`

```python
triggers: list[str] = []
```

##### `openhands.sdk.context.MicroagentMetadata.type`

```python
type: MicroagentType = Field(default=(MicroagentType.REPO_KNOWLEDGE))
```

#### `openhands.sdk.context.MicroagentType`

Bases: <code>[str](#str)</code>, <code>[Enum](#enum.Enum)</code>

Type of microagent.

**Attributes:**

- [**KNOWLEDGE**](#openhands.sdk.context.MicroagentType.KNOWLEDGE) –
- [**REPO_KNOWLEDGE**](#openhands.sdk.context.MicroagentType.REPO_KNOWLEDGE) –
- [**TASK**](#openhands.sdk.context.MicroagentType.TASK) –

##### `openhands.sdk.context.MicroagentType.KNOWLEDGE`

```python
KNOWLEDGE = 'knowledge'
```

##### `openhands.sdk.context.MicroagentType.REPO_KNOWLEDGE`

```python
REPO_KNOWLEDGE = 'repo'
```

##### `openhands.sdk.context.MicroagentType.TASK`

```python
TASK = 'task'
```

#### `openhands.sdk.context.MicroagentValidationError`

```python
MicroagentValidationError(message='Microagent validation failed')
```

Bases: <code>[MicroagentError](#openhands.sdk.context.microagents.exceptions.MicroagentError)</code>

Raised when there's a validation error in microagent metadata.

Initialize the validation error with a message.

#### `openhands.sdk.context.RepoMicroagent`

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Microagent specialized for repository-specific knowledge and guidelines.

RepoMicroagents are loaded from `.openhands/microagents/repo.md` files within
repositories and contain private, repository-specific instructions that are
automatically loaded when
working with that repository. They are ideal for:
\- Repository-specific guidelines
\- Team practices and conventions
\- Project-specific workflows
\- Custom documentation references

**Functions:**

- [**load**](#openhands.sdk.context.RepoMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.RepoMicroagent.content) (<code>[str](#str)</code>) –
- [**mcp_tools**](#openhands.sdk.context.RepoMicroagent.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | [dict](#dict) | None</code>) –
- [**name**](#openhands.sdk.context.RepoMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.RepoMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.RepoMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

##### `openhands.sdk.context.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

##### `openhands.sdk.context.RepoMicroagent.content`

```python
content: str
```

##### `openhands.sdk.context.RepoMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

##### `openhands.sdk.context.RepoMicroagent.mcp_tools`

```python
mcp_tools: MCPConfig | dict | None = Field(default=None, description='MCP tools configuration for the microagent')
```

##### `openhands.sdk.context.RepoMicroagent.name`

```python
name: str
```

##### `openhands.sdk.context.RepoMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

##### `openhands.sdk.context.RepoMicroagent.type`

```python
type: MicroagentType = MicroagentType.REPO_KNOWLEDGE
```

#### `openhands.sdk.context.agent_context`

Agent context management for prompt extension and microagent integration.

**Classes:**

- [**AgentContext**](#openhands.sdk.context.agent_context.AgentContext) – Central structure for managing prompt extension.

**Attributes:**

- [**PROMPT_DIR**](#openhands.sdk.context.agent_context.PROMPT_DIR) –
- [**logger**](#openhands.sdk.context.agent_context.logger) –

##### `openhands.sdk.context.agent_context.AgentContext`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Central structure for managing prompt extension.

AgentContext unifies all the contextual inputs that shape how the system
extends and interprets user prompts. It combines both static environment
details and dynamic, user-activated extensions from microagents.

Specifically, it provides:

- **Repository context / Repo Microagents**: Information about the active codebase,
  branches, and repo-specific instructions contributed by repo microagents.
- **Runtime context**: Current execution environment (hosts, working
  directory, secrets, date, etc.).
- **Conversation instructions**: Optional task- or channel-specific rules
  that constrain or guide the agent’s behavior across the session.
- **Knowledge Microagents**: Extensible components that can be triggered by user input
  to inject knowledge or domain-specific guidance.

Together, these elements make AgentContext the primary container responsible
for assembling, formatting, and injecting all prompt-relevant context into
LLM interactions.

**Functions:**

- [**get_system_message_suffix**](#openhands.sdk.context.agent_context.AgentContext.get_system_message_suffix) – Get the system message with repo microagent content and custom suffix.
- [**get_user_message_suffix**](#openhands.sdk.context.agent_context.AgentContext.get_user_message_suffix) – Augment the user’s message with knowledge recalled from microagents.

**Attributes:**

- [**microagents**](#openhands.sdk.context.agent_context.AgentContext.microagents) (<code>[list](#list)\[[BaseMicroagent](#openhands.sdk.context.microagents.BaseMicroagent)\]</code>) –
- [**system_message_suffix**](#openhands.sdk.context.agent_context.AgentContext.system_message_suffix) (<code>[str](#str) | None</code>) –
- [**user_message_suffix**](#openhands.sdk.context.agent_context.AgentContext.user_message_suffix) (<code>[str](#str) | None</code>) –

###### `openhands.sdk.context.agent_context.AgentContext.get_system_message_suffix`

```python
get_system_message_suffix()
```

Get the system message with repo microagent content and custom suffix.

Custom suffix can typically includes:

- Repository information (repo name, branch name, PR number, etc.)
- Runtime information (e.g., available hosts, current date)
- Conversation instructions (e.g., user preferences, task details)
- Repository-specific instructions (collected from repo microagents)

###### `openhands.sdk.context.agent_context.AgentContext.get_user_message_suffix`

```python
get_user_message_suffix(user_message, skip_microagent_names)
```

Augment the user’s message with knowledge recalled from microagents.

This works by:

- Extracting the text content of the user message
- Matching microagent triggers against the query
- Returning formatted knowledge and triggered microagent names if relevant microagents were triggered

###### `openhands.sdk.context.agent_context.AgentContext.microagents`

```python
microagents: list[BaseMicroagent] = Field(default_factory=list, description="List of available microagents that can extend the user's input.")
```

###### `openhands.sdk.context.agent_context.AgentContext.system_message_suffix`

```python
system_message_suffix: str | None = Field(default=None, description='Optional suffix to append to the system prompt.')
```

###### `openhands.sdk.context.agent_context.AgentContext.user_message_suffix`

```python
user_message_suffix: str | None = Field(default=None, description="Optional suffix to append to the user's message.")
```

##### `openhands.sdk.context.agent_context.PROMPT_DIR`

```python
PROMPT_DIR = pathlib.Path(__file__).parent / 'prompts' / 'templates'
```

##### `openhands.sdk.context.agent_context.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.context.condenser`

Context condensers for managing conversation history.

**Modules:**

- [**condenser**](#openhands.sdk.context.condenser.condenser) – Abstract condenser interface and rolling condenser base class.
- [**no_op_condenser**](#openhands.sdk.context.condenser.no_op_condenser) – No-op condenser implementation for testing purposes.

**Classes:**

- [**Condenser**](#openhands.sdk.context.condenser.Condenser) – Abstract condenser interface.
- [**NoOpCondenser**](#openhands.sdk.context.condenser.NoOpCondenser) – Simple condenser that returns a view un-manipulated.
- [**RollingCondenser**](#openhands.sdk.context.condenser.RollingCondenser) – Base class for a specialized condenser strategy.

##### `openhands.sdk.context.condenser.Condenser`

Bases: <code>[ABC](#abc.ABC)</code>

Abstract condenser interface.

Condensers take a list of `Event` objects and reduce them into a potentially smaller
list.

Agents can use condensers to reduce the amount of events they need to consider when
deciding which action to take. To use a condenser, agents can call the
`condensed_history` method on the current `State` being considered and use the
results instead of the full history.

If the condenser returns a `Condensation` instead of a `View`, the agent should
return `Condensation.action` instead of producing its own action. On the next agent
step the condenser will use that condensation event to produce a new `View`.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.Condenser.condense) – Condense a sequence of events into a potentially smaller list.

###### `openhands.sdk.context.condenser.Condenser.condense`

```python
condense(view)
```

Condense a sequence of events into a potentially smaller list.

New condenser strategies should override this method to implement their own
condensation logic. Call `self.add_metadata` in the implementation to record any
relevant per-condensation diagnostic information.

**Parameters:**

- **view** (<code>[View](#openhands.sdk.context.view.View)</code>) – A view of the history containing all events that should be condensed.

**Returns:**

- <code>[View](#openhands.sdk.context.view.View) | [Condensation](#openhands.sdk.event.condenser.Condensation)</code> – View | Condensation: A condensed view of the events or an event indicating
- <code>[View](#openhands.sdk.context.view.View) | [Condensation](#openhands.sdk.event.condenser.Condensation)</code> – the history has been condensed.

##### `openhands.sdk.context.condenser.NoOpCondenser`

Bases: <code>[Condenser](#openhands.sdk.context.condenser.condenser.Condenser)</code>

Simple condenser that returns a view un-manipulated.

Primarily intended for testing purposes.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.NoOpCondenser.condense) – Return the view unchanged.

###### `openhands.sdk.context.condenser.NoOpCondenser.condense`

```python
condense(view)
```

Return the view unchanged.

##### `openhands.sdk.context.condenser.RollingCondenser`

Bases: <code>[Condenser](#openhands.sdk.context.condenser.condenser.Condenser)</code>, <code>[ABC](#abc.ABC)</code>

Base class for a specialized condenser strategy.

Applies condensation to a rolling history.

The rolling history is generated by `View.from_events`, which analyzes all events in
the history and produces a `View` object representing what will be sent to the LLM.

If `should_condense` says so, the condenser is then responsible for generating a
`Condensation` object from the `View` object. This will be added to the event
history which should -- when given to `get_view` -- produce the condensed `View` to
be passed to the LLM.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.RollingCondenser.condense) – Condense a view based on rolling condenser logic.
- [**get_condensation**](#openhands.sdk.context.condenser.RollingCondenser.get_condensation) – Get the condensation from a view.
- [**should_condense**](#openhands.sdk.context.condenser.RollingCondenser.should_condense) – Determine if a view should be condensed.

###### `openhands.sdk.context.condenser.RollingCondenser.condense`

```python
condense(view)
```

Condense a view based on rolling condenser logic.

###### `openhands.sdk.context.condenser.RollingCondenser.get_condensation`

```python
get_condensation(view)
```

Get the condensation from a view.

###### `openhands.sdk.context.condenser.RollingCondenser.should_condense`

```python
should_condense(view)
```

Determine if a view should be condensed.

##### `openhands.sdk.context.condenser.condenser`

Abstract condenser interface and rolling condenser base class.

**Classes:**

- [**Condenser**](#openhands.sdk.context.condenser.condenser.Condenser) – Abstract condenser interface.
- [**RollingCondenser**](#openhands.sdk.context.condenser.condenser.RollingCondenser) – Base class for a specialized condenser strategy.

**Attributes:**

- [**logger**](#openhands.sdk.context.condenser.condenser.logger) –

###### `openhands.sdk.context.condenser.condenser.Condenser`

Bases: <code>[ABC](#abc.ABC)</code>

Abstract condenser interface.

Condensers take a list of `Event` objects and reduce them into a potentially smaller
list.

Agents can use condensers to reduce the amount of events they need to consider when
deciding which action to take. To use a condenser, agents can call the
`condensed_history` method on the current `State` being considered and use the
results instead of the full history.

If the condenser returns a `Condensation` instead of a `View`, the agent should
return `Condensation.action` instead of producing its own action. On the next agent
step the condenser will use that condensation event to produce a new `View`.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.condenser.Condenser.condense) – Condense a sequence of events into a potentially smaller list.

####### `openhands.sdk.context.condenser.condenser.Condenser.condense`

```python
condense(view)
```

Condense a sequence of events into a potentially smaller list.

New condenser strategies should override this method to implement their own
condensation logic. Call `self.add_metadata` in the implementation to record any
relevant per-condensation diagnostic information.

**Parameters:**

- **view** (<code>[View](#openhands.sdk.context.view.View)</code>) – A view of the history containing all events that should be condensed.

**Returns:**

- <code>[View](#openhands.sdk.context.view.View) | [Condensation](#openhands.sdk.event.condenser.Condensation)</code> – View | Condensation: A condensed view of the events or an event indicating
- <code>[View](#openhands.sdk.context.view.View) | [Condensation](#openhands.sdk.event.condenser.Condensation)</code> – the history has been condensed.

###### `openhands.sdk.context.condenser.condenser.RollingCondenser`

Bases: <code>[Condenser](#openhands.sdk.context.condenser.condenser.Condenser)</code>, <code>[ABC](#abc.ABC)</code>

Base class for a specialized condenser strategy.

Applies condensation to a rolling history.

The rolling history is generated by `View.from_events`, which analyzes all events in
the history and produces a `View` object representing what will be sent to the LLM.

If `should_condense` says so, the condenser is then responsible for generating a
`Condensation` object from the `View` object. This will be added to the event
history which should -- when given to `get_view` -- produce the condensed `View` to
be passed to the LLM.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.condenser.RollingCondenser.condense) – Condense a view based on rolling condenser logic.
- [**get_condensation**](#openhands.sdk.context.condenser.condenser.RollingCondenser.get_condensation) – Get the condensation from a view.
- [**should_condense**](#openhands.sdk.context.condenser.condenser.RollingCondenser.should_condense) – Determine if a view should be condensed.

####### `openhands.sdk.context.condenser.condenser.RollingCondenser.condense`

```python
condense(view)
```

Condense a view based on rolling condenser logic.

####### `openhands.sdk.context.condenser.condenser.RollingCondenser.get_condensation`

```python
get_condensation(view)
```

Get the condensation from a view.

####### `openhands.sdk.context.condenser.condenser.RollingCondenser.should_condense`

```python
should_condense(view)
```

Determine if a view should be condensed.

###### `openhands.sdk.context.condenser.condenser.logger`

```python
logger = getLogger(__name__)
```

##### `openhands.sdk.context.condenser.no_op_condenser`

No-op condenser implementation for testing purposes.

**Classes:**

- [**NoOpCondenser**](#openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser) – Simple condenser that returns a view un-manipulated.

###### `openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser`

Bases: <code>[Condenser](#openhands.sdk.context.condenser.condenser.Condenser)</code>

Simple condenser that returns a view un-manipulated.

Primarily intended for testing purposes.

**Functions:**

- [**condense**](#openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser.condense) – Return the view unchanged.

####### `openhands.sdk.context.condenser.no_op_condenser.NoOpCondenser.condense`

```python
condense(view)
```

Return the view unchanged.

#### `openhands.sdk.context.load_microagents_from_dir`

```python
load_microagents_from_dir(microagent_dir)
```

Load all microagents from the given directory.

Note, legacy repo instructions will not be loaded here.

**Parameters:**

- **microagent_dir** (<code>[str](#str) | [Path](#pathlib.Path)</code>) – Path to the microagents directory (e.g. .openhands/microagents)

**Returns:**

- <code>[tuple](#tuple)\[[dict](#dict)\[[str](#str), [RepoMicroagent](#openhands.sdk.context.microagents.microagent.RepoMicroagent)\], [dict](#dict)\[[str](#str), [KnowledgeMicroagent](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent)\]\]</code> – Tuple of (repo_agents, knowledge_agents) dictionaries

#### `openhands.sdk.context.microagents`

Microagents - Specialized agents for specific tasks and knowledge domains.

**Modules:**

- [**exceptions**](#openhands.sdk.context.microagents.exceptions) – Exception classes for microagent operations.
- [**microagent**](#openhands.sdk.context.microagents.microagent) – Microagent implementations for different types of agents.
- [**types**](#openhands.sdk.context.microagents.types) – Types and models for microagents.

**Classes:**

- [**BaseMicroagent**](#openhands.sdk.context.microagents.BaseMicroagent) – Base class for all microagents.
- [**KnowledgeMicroagent**](#openhands.sdk.context.microagents.KnowledgeMicroagent) – Knowledge micro-agents provide specialized expertise.
- [**MicroagentKnowledge**](#openhands.sdk.context.microagents.MicroagentKnowledge) – Represents knowledge from a triggered microagent.
- [**MicroagentMetadata**](#openhands.sdk.context.microagents.MicroagentMetadata) – Metadata for all microagents.
- [**MicroagentType**](#openhands.sdk.context.microagents.MicroagentType) – Type of microagent.
- [**MicroagentValidationError**](#openhands.sdk.context.microagents.MicroagentValidationError) – Raised when there's a validation error in microagent metadata.
- [**RepoMicroagent**](#openhands.sdk.context.microagents.RepoMicroagent) – Microagent specialized for repository-specific knowledge and guidelines.
- [**TaskMicroagent**](#openhands.sdk.context.microagents.TaskMicroagent) – TaskMicroagent is a special type of KnowledgeMicroagent that requires user input.

**Functions:**

- [**load_microagents_from_dir**](#openhands.sdk.context.microagents.load_microagents_from_dir) – Load all microagents from the given directory.

##### `openhands.sdk.context.microagents.BaseMicroagent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Base class for all microagents.

**Functions:**

- [**load**](#openhands.sdk.context.microagents.BaseMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.BaseMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.BaseMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.BaseMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.microagents.BaseMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

###### `openhands.sdk.context.microagents.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

###### `openhands.sdk.context.microagents.BaseMicroagent.content`

```python
content: str
```

###### `openhands.sdk.context.microagents.BaseMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

###### `openhands.sdk.context.microagents.BaseMicroagent.name`

```python
name: str
```

###### `openhands.sdk.context.microagents.BaseMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

###### `openhands.sdk.context.microagents.BaseMicroagent.type`

```python
type: MicroagentType = Field(..., description='The type of the microagent')
```

##### `openhands.sdk.context.microagents.KnowledgeMicroagent`

```python
KnowledgeMicroagent(**data)
```

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Knowledge micro-agents provide specialized expertise.

Triggered by keywords in conversations.

They help with:

- Language best practices
- Framework guidelines
- Common patterns
- Tool usage

**Functions:**

- [**load**](#openhands.sdk.context.microagents.KnowledgeMicroagent.load) – Load a microagent from a markdown file with frontmatter.
- [**match_trigger**](#openhands.sdk.context.microagents.KnowledgeMicroagent.match_trigger) – Match a trigger in the message.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.KnowledgeMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.KnowledgeMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.KnowledgeMicroagent.source) (<code>[str](#str) | None</code>) –
- [**triggers**](#openhands.sdk.context.microagents.KnowledgeMicroagent.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.KnowledgeMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

Initialize the knowledge microagent.

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.content`

```python
content: str
```

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.match_trigger`

```python
match_trigger(message)
```

Match a trigger in the message.

It returns the first trigger that matches the message.

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.name`

```python
name: str
```

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.triggers`

```python
triggers: list[str] = Field(default_factory=list, description='List of triggers for the microagent')
```

###### `openhands.sdk.context.microagents.KnowledgeMicroagent.type`

```python
type: MicroagentType = MicroagentType.KNOWLEDGE
```

##### `openhands.sdk.context.microagents.MicroagentKnowledge`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Represents knowledge from a triggered microagent.

**Attributes:**

- [**content**](#openhands.sdk.context.microagents.MicroagentKnowledge.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.MicroagentKnowledge.name) (<code>[str](#str)</code>) –
- [**trigger**](#openhands.sdk.context.microagents.MicroagentKnowledge.trigger) (<code>[str](#str)</code>) –

###### `openhands.sdk.context.microagents.MicroagentKnowledge.content`

```python
content: str = Field(description='The actual content/knowledge from the microagent')
```

###### `openhands.sdk.context.microagents.MicroagentKnowledge.name`

```python
name: str = Field(description='The name of the microagent that was triggered')
```

###### `openhands.sdk.context.microagents.MicroagentKnowledge.trigger`

```python
trigger: str = Field(description='The word that triggered this microagent')
```

##### `openhands.sdk.context.microagents.MicroagentMetadata`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Metadata for all microagents.

**Attributes:**

- [**inputs**](#openhands.sdk.context.microagents.MicroagentMetadata.inputs) (<code>[list](#list)\[[InputMetadata](#openhands.sdk.context.microagents.types.InputMetadata)\]</code>) –
- [**mcp_tools**](#openhands.sdk.context.microagents.MicroagentMetadata.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | None</code>) –
- [**name**](#openhands.sdk.context.microagents.MicroagentMetadata.name) (<code>[str](#str)</code>) –
- [**triggers**](#openhands.sdk.context.microagents.MicroagentMetadata.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.MicroagentMetadata.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

###### `openhands.sdk.context.microagents.MicroagentMetadata.inputs`

```python
inputs: list[InputMetadata] = []
```

###### `openhands.sdk.context.microagents.MicroagentMetadata.mcp_tools`

```python
mcp_tools: MCPConfig | None = None
```

###### `openhands.sdk.context.microagents.MicroagentMetadata.name`

```python
name: str = Field('default', description='Unique name of the microagent')
```

###### `openhands.sdk.context.microagents.MicroagentMetadata.triggers`

```python
triggers: list[str] = []
```

###### `openhands.sdk.context.microagents.MicroagentMetadata.type`

```python
type: MicroagentType = Field(default=(MicroagentType.REPO_KNOWLEDGE))
```

##### `openhands.sdk.context.microagents.MicroagentType`

Bases: <code>[str](#str)</code>, <code>[Enum](#enum.Enum)</code>

Type of microagent.

**Attributes:**

- [**KNOWLEDGE**](#openhands.sdk.context.microagents.MicroagentType.KNOWLEDGE) –
- [**REPO_KNOWLEDGE**](#openhands.sdk.context.microagents.MicroagentType.REPO_KNOWLEDGE) –
- [**TASK**](#openhands.sdk.context.microagents.MicroagentType.TASK) –

###### `openhands.sdk.context.microagents.MicroagentType.KNOWLEDGE`

```python
KNOWLEDGE = 'knowledge'
```

###### `openhands.sdk.context.microagents.MicroagentType.REPO_KNOWLEDGE`

```python
REPO_KNOWLEDGE = 'repo'
```

###### `openhands.sdk.context.microagents.MicroagentType.TASK`

```python
TASK = 'task'
```

##### `openhands.sdk.context.microagents.MicroagentValidationError`

```python
MicroagentValidationError(message='Microagent validation failed')
```

Bases: <code>[MicroagentError](#openhands.sdk.context.microagents.exceptions.MicroagentError)</code>

Raised when there's a validation error in microagent metadata.

Initialize the validation error with a message.

##### `openhands.sdk.context.microagents.RepoMicroagent`

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Microagent specialized for repository-specific knowledge and guidelines.

RepoMicroagents are loaded from `.openhands/microagents/repo.md` files within
repositories and contain private, repository-specific instructions that are
automatically loaded when
working with that repository. They are ideal for:
\- Repository-specific guidelines
\- Team practices and conventions
\- Project-specific workflows
\- Custom documentation references

**Functions:**

- [**load**](#openhands.sdk.context.microagents.RepoMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.RepoMicroagent.content) (<code>[str](#str)</code>) –
- [**mcp_tools**](#openhands.sdk.context.microagents.RepoMicroagent.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | [dict](#dict) | None</code>) –
- [**name**](#openhands.sdk.context.microagents.RepoMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.RepoMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.microagents.RepoMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

###### `openhands.sdk.context.microagents.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

###### `openhands.sdk.context.microagents.RepoMicroagent.content`

```python
content: str
```

###### `openhands.sdk.context.microagents.RepoMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

###### `openhands.sdk.context.microagents.RepoMicroagent.mcp_tools`

```python
mcp_tools: MCPConfig | dict | None = Field(default=None, description='MCP tools configuration for the microagent')
```

###### `openhands.sdk.context.microagents.RepoMicroagent.name`

```python
name: str
```

###### `openhands.sdk.context.microagents.RepoMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

###### `openhands.sdk.context.microagents.RepoMicroagent.type`

```python
type: MicroagentType = MicroagentType.REPO_KNOWLEDGE
```

##### `openhands.sdk.context.microagents.TaskMicroagent`

```python
TaskMicroagent(**data)
```

Bases: <code>[KnowledgeMicroagent](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent)</code>

TaskMicroagent is a special type of KnowledgeMicroagent that requires user input.

These microagents are triggered by a special format: "/{agent_name}"
and will prompt the user for any required inputs before proceeding.

**Functions:**

- [**extract_variables**](#openhands.sdk.context.microagents.TaskMicroagent.extract_variables) – Extract variables from the content.
- [**load**](#openhands.sdk.context.microagents.TaskMicroagent.load) – Load a microagent from a markdown file with frontmatter.
- [**match_trigger**](#openhands.sdk.context.microagents.TaskMicroagent.match_trigger) – Match a trigger in the message.
- [**requires_user_input**](#openhands.sdk.context.microagents.TaskMicroagent.requires_user_input) – Check if this microagent requires user input.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.TaskMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.TaskMicroagent.content) (<code>[str](#str)</code>) –
- [**inputs**](#openhands.sdk.context.microagents.TaskMicroagent.inputs) (<code>[list](#list)\[[InputMetadata](#openhands.sdk.context.microagents.types.InputMetadata)\]</code>) –
- [**name**](#openhands.sdk.context.microagents.TaskMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.TaskMicroagent.source) (<code>[str](#str) | None</code>) –
- [**triggers**](#openhands.sdk.context.microagents.TaskMicroagent.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.TaskMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

Initialize the task microagent.

###### `openhands.sdk.context.microagents.TaskMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

###### `openhands.sdk.context.microagents.TaskMicroagent.content`

```python
content: str
```

###### `openhands.sdk.context.microagents.TaskMicroagent.extract_variables`

```python
extract_variables(content)
```

Extract variables from the content.

Variables are in the format ${variable_name}.

###### `openhands.sdk.context.microagents.TaskMicroagent.inputs`

```python
inputs: list[InputMetadata] = Field(default_factory=list, description='Input metadata for the microagent. Only exists for task microagents')
```

###### `openhands.sdk.context.microagents.TaskMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

###### `openhands.sdk.context.microagents.TaskMicroagent.match_trigger`

```python
match_trigger(message)
```

Match a trigger in the message.

It returns the first trigger that matches the message.

###### `openhands.sdk.context.microagents.TaskMicroagent.name`

```python
name: str
```

###### `openhands.sdk.context.microagents.TaskMicroagent.requires_user_input`

```python
requires_user_input()
```

Check if this microagent requires user input.

Returns True if the content contains variables in the format ${variable_name}.

###### `openhands.sdk.context.microagents.TaskMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

###### `openhands.sdk.context.microagents.TaskMicroagent.triggers`

```python
triggers: list[str] = Field(default_factory=list, description='List of triggers for the microagent')
```

###### `openhands.sdk.context.microagents.TaskMicroagent.type`

```python
type: MicroagentType = MicroagentType.TASK
```

##### `openhands.sdk.context.microagents.exceptions`

Exception classes for microagent operations.

**Classes:**

- [**MicroagentError**](#openhands.sdk.context.microagents.exceptions.MicroagentError) – Base exception for all microagent errors.
- [**MicroagentValidationError**](#openhands.sdk.context.microagents.exceptions.MicroagentValidationError) – Raised when there's a validation error in microagent metadata.

###### `openhands.sdk.context.microagents.exceptions.MicroagentError`

Bases: <code>[Exception](#Exception)</code>

Base exception for all microagent errors.

###### `openhands.sdk.context.microagents.exceptions.MicroagentValidationError`

```python
MicroagentValidationError(message='Microagent validation failed')
```

Bases: <code>[MicroagentError](#openhands.sdk.context.microagents.exceptions.MicroagentError)</code>

Raised when there's a validation error in microagent metadata.

Initialize the validation error with a message.

##### `openhands.sdk.context.microagents.load_microagents_from_dir`

```python
load_microagents_from_dir(microagent_dir)
```

Load all microagents from the given directory.

Note, legacy repo instructions will not be loaded here.

**Parameters:**

- **microagent_dir** (<code>[str](#str) | [Path](#pathlib.Path)</code>) – Path to the microagents directory (e.g. .openhands/microagents)

**Returns:**

- <code>[tuple](#tuple)\[[dict](#dict)\[[str](#str), [RepoMicroagent](#openhands.sdk.context.microagents.microagent.RepoMicroagent)\], [dict](#dict)\[[str](#str), [KnowledgeMicroagent](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent)\]\]</code> – Tuple of (repo_agents, knowledge_agents) dictionaries

##### `openhands.sdk.context.microagents.microagent`

Microagent implementations for different types of agents.

**Classes:**

- [**BaseMicroagent**](#openhands.sdk.context.microagents.microagent.BaseMicroagent) – Base class for all microagents.
- [**KnowledgeMicroagent**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent) – Knowledge micro-agents provide specialized expertise.
- [**RepoMicroagent**](#openhands.sdk.context.microagents.microagent.RepoMicroagent) – Microagent specialized for repository-specific knowledge and guidelines.
- [**TaskMicroagent**](#openhands.sdk.context.microagents.microagent.TaskMicroagent) – TaskMicroagent is a special type of KnowledgeMicroagent that requires user input.

**Functions:**

- [**load_microagents_from_dir**](#openhands.sdk.context.microagents.microagent.load_microagents_from_dir) – Load all microagents from the given directory.

**Attributes:**

- [**logger**](#openhands.sdk.context.microagents.microagent.logger) –

###### `openhands.sdk.context.microagents.microagent.BaseMicroagent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Base class for all microagents.

**Functions:**

- [**load**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.microagents.microagent.BaseMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.content`

```python
content: str
```

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.name`

```python
name: str
```

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

####### `openhands.sdk.context.microagents.microagent.BaseMicroagent.type`

```python
type: MicroagentType = Field(..., description='The type of the microagent')
```

###### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent`

```python
KnowledgeMicroagent(**data)
```

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Knowledge micro-agents provide specialized expertise.

Triggered by keywords in conversations.

They help with:

- Language best practices
- Framework guidelines
- Common patterns
- Tool usage

**Functions:**

- [**load**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.load) – Load a microagent from a markdown file with frontmatter.
- [**match_trigger**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.match_trigger) – Match a trigger in the message.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.source) (<code>[str](#str) | None</code>) –
- [**triggers**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

Initialize the knowledge microagent.

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.content`

```python
content: str
```

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.match_trigger`

```python
match_trigger(message)
```

Match a trigger in the message.

It returns the first trigger that matches the message.

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.name`

```python
name: str
```

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.triggers`

```python
triggers: list[str] = Field(default_factory=list, description='List of triggers for the microagent')
```

####### `openhands.sdk.context.microagents.microagent.KnowledgeMicroagent.type`

```python
type: MicroagentType = MicroagentType.KNOWLEDGE
```

###### `openhands.sdk.context.microagents.microagent.RepoMicroagent`

Bases: <code>[BaseMicroagent](#openhands.sdk.context.microagents.microagent.BaseMicroagent)</code>

Microagent specialized for repository-specific knowledge and guidelines.

RepoMicroagents are loaded from `.openhands/microagents/repo.md` files within
repositories and contain private, repository-specific instructions that are
automatically loaded when
working with that repository. They are ideal for:
\- Repository-specific guidelines
\- Team practices and conventions
\- Project-specific workflows
\- Custom documentation references

**Functions:**

- [**load**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.load) – Load a microagent from a markdown file with frontmatter.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.content) (<code>[str](#str)</code>) –
- [**mcp_tools**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | [dict](#dict) | None</code>) –
- [**name**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.source) (<code>[str](#str) | None</code>) –
- [**type**](#openhands.sdk.context.microagents.microagent.RepoMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.content`

```python
content: str
```

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.mcp_tools`

```python
mcp_tools: MCPConfig | dict | None = Field(default=None, description='MCP tools configuration for the microagent')
```

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.name`

```python
name: str
```

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

####### `openhands.sdk.context.microagents.microagent.RepoMicroagent.type`

```python
type: MicroagentType = MicroagentType.REPO_KNOWLEDGE
```

###### `openhands.sdk.context.microagents.microagent.TaskMicroagent`

```python
TaskMicroagent(**data)
```

Bases: <code>[KnowledgeMicroagent](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent)</code>

TaskMicroagent is a special type of KnowledgeMicroagent that requires user input.

These microagents are triggered by a special format: "/{agent_name}"
and will prompt the user for any required inputs before proceeding.

**Functions:**

- [**extract_variables**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.extract_variables) – Extract variables from the content.
- [**load**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.load) – Load a microagent from a markdown file with frontmatter.
- [**match_trigger**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.match_trigger) – Match a trigger in the message.
- [**requires_user_input**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.requires_user_input) – Check if this microagent requires user input.

**Attributes:**

- [**PATH_TO_THIRD_PARTY_MICROAGENT_NAME**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –
- [**content**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.content) (<code>[str](#str)</code>) –
- [**inputs**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.inputs) (<code>[list](#list)\[[InputMetadata](#openhands.sdk.context.microagents.types.InputMetadata)\]</code>) –
- [**name**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.name) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.source) (<code>[str](#str) | None</code>) –
- [**triggers**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.microagent.TaskMicroagent.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

Initialize the task microagent.

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.PATH_TO_THIRD_PARTY_MICROAGENT_NAME`

```python
PATH_TO_THIRD_PARTY_MICROAGENT_NAME: dict[str, str] = {'.cursorrules': 'cursorrules', 'agents.md': 'agents', 'agent.md': 'agents'}
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.content`

```python
content: str
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.extract_variables`

```python
extract_variables(content)
```

Extract variables from the content.

Variables are in the format ${variable_name}.

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.inputs`

```python
inputs: list[InputMetadata] = Field(default_factory=list, description='Input metadata for the microagent. Only exists for task microagents')
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.load`

```python
load(path, microagent_dir=None, file_content=None)
```

Load a microagent from a markdown file with frontmatter.

The agent's name is derived from its path relative to the microagent_dir.

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.match_trigger`

```python
match_trigger(message)
```

Match a trigger in the message.

It returns the first trigger that matches the message.

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.name`

```python
name: str
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.requires_user_input`

```python
requires_user_input()
```

Check if this microagent requires user input.

Returns True if the content contains variables in the format ${variable_name}.

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.source`

```python
source: str | None = Field(default=None, description='The source path or identifier of the microagent. When it is None, it is treated as a programmatically defined microagent.')
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.triggers`

```python
triggers: list[str] = Field(default_factory=list, description='List of triggers for the microagent')
```

####### `openhands.sdk.context.microagents.microagent.TaskMicroagent.type`

```python
type: MicroagentType = MicroagentType.TASK
```

###### `openhands.sdk.context.microagents.microagent.load_microagents_from_dir`

```python
load_microagents_from_dir(microagent_dir)
```

Load all microagents from the given directory.

Note, legacy repo instructions will not be loaded here.

**Parameters:**

- **microagent_dir** (<code>[str](#str) | [Path](#pathlib.Path)</code>) – Path to the microagents directory (e.g. .openhands/microagents)

**Returns:**

- <code>[tuple](#tuple)\[[dict](#dict)\[[str](#str), [RepoMicroagent](#openhands.sdk.context.microagents.microagent.RepoMicroagent)\], [dict](#dict)\[[str](#str), [KnowledgeMicroagent](#openhands.sdk.context.microagents.microagent.KnowledgeMicroagent)\]\]</code> – Tuple of (repo_agents, knowledge_agents) dictionaries

###### `openhands.sdk.context.microagents.microagent.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.sdk.context.microagents.types`

Types and models for microagents.

**Classes:**

- [**InputMetadata**](#openhands.sdk.context.microagents.types.InputMetadata) – Metadata for task microagent inputs.
- [**MicroagentContentResponse**](#openhands.sdk.context.microagents.types.MicroagentContentResponse) – Response model for individual microagent content endpoint.
- [**MicroagentKnowledge**](#openhands.sdk.context.microagents.types.MicroagentKnowledge) – Represents knowledge from a triggered microagent.
- [**MicroagentMetadata**](#openhands.sdk.context.microagents.types.MicroagentMetadata) – Metadata for all microagents.
- [**MicroagentResponse**](#openhands.sdk.context.microagents.types.MicroagentResponse) – Response model for microagents endpoint.
- [**MicroagentType**](#openhands.sdk.context.microagents.types.MicroagentType) – Type of microagent.

###### `openhands.sdk.context.microagents.types.InputMetadata`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Metadata for task microagent inputs.

**Attributes:**

- [**description**](#openhands.sdk.context.microagents.types.InputMetadata.description) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.types.InputMetadata.name) (<code>[str](#str)</code>) –

####### `openhands.sdk.context.microagents.types.InputMetadata.description`

```python
description: str = Field(..., description='Description of the input parameter')
```

####### `openhands.sdk.context.microagents.types.InputMetadata.name`

```python
name: str = Field(..., description='Name of the input parameter')
```

###### `openhands.sdk.context.microagents.types.MicroagentContentResponse`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Response model for individual microagent content endpoint.

**Attributes:**

- [**content**](#openhands.sdk.context.microagents.types.MicroagentContentResponse.content) (<code>[str](#str)</code>) –
- [**git_provider**](#openhands.sdk.context.microagents.types.MicroagentContentResponse.git_provider) (<code>[str](#str) | None</code>) –
- [**path**](#openhands.sdk.context.microagents.types.MicroagentContentResponse.path) (<code>[str](#str)</code>) –
- [**triggers**](#openhands.sdk.context.microagents.types.MicroagentContentResponse.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –

####### `openhands.sdk.context.microagents.types.MicroagentContentResponse.content`

```python
content: str = Field(description='The full content of the microagent')
```

####### `openhands.sdk.context.microagents.types.MicroagentContentResponse.git_provider`

```python
git_provider: str | None = Field(None, description='Git provider if the microagent is sourced from a Git repository')
```

####### `openhands.sdk.context.microagents.types.MicroagentContentResponse.path`

```python
path: str = Field(description='The path or identifier of the microagent')
```

####### `openhands.sdk.context.microagents.types.MicroagentContentResponse.triggers`

```python
triggers: list[str] = Field(description='List of triggers associated with the microagent')
```

###### `openhands.sdk.context.microagents.types.MicroagentKnowledge`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Represents knowledge from a triggered microagent.

**Attributes:**

- [**content**](#openhands.sdk.context.microagents.types.MicroagentKnowledge.content) (<code>[str](#str)</code>) –
- [**name**](#openhands.sdk.context.microagents.types.MicroagentKnowledge.name) (<code>[str](#str)</code>) –
- [**trigger**](#openhands.sdk.context.microagents.types.MicroagentKnowledge.trigger) (<code>[str](#str)</code>) –

####### `openhands.sdk.context.microagents.types.MicroagentKnowledge.content`

```python
content: str = Field(description='The actual content/knowledge from the microagent')
```

####### `openhands.sdk.context.microagents.types.MicroagentKnowledge.name`

```python
name: str = Field(description='The name of the microagent that was triggered')
```

####### `openhands.sdk.context.microagents.types.MicroagentKnowledge.trigger`

```python
trigger: str = Field(description='The word that triggered this microagent')
```

###### `openhands.sdk.context.microagents.types.MicroagentMetadata`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Metadata for all microagents.

**Attributes:**

- [**inputs**](#openhands.sdk.context.microagents.types.MicroagentMetadata.inputs) (<code>[list](#list)\[[InputMetadata](#openhands.sdk.context.microagents.types.InputMetadata)\]</code>) –
- [**mcp_tools**](#openhands.sdk.context.microagents.types.MicroagentMetadata.mcp_tools) (<code>[MCPConfig](#fastmcp.mcp_config.MCPConfig) | None</code>) –
- [**name**](#openhands.sdk.context.microagents.types.MicroagentMetadata.name) (<code>[str](#str)</code>) –
- [**triggers**](#openhands.sdk.context.microagents.types.MicroagentMetadata.triggers) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**type**](#openhands.sdk.context.microagents.types.MicroagentMetadata.type) (<code>[MicroagentType](#openhands.sdk.context.microagents.types.MicroagentType)</code>) –

####### `openhands.sdk.context.microagents.types.MicroagentMetadata.inputs`

```python
inputs: list[InputMetadata] = []
```

####### `openhands.sdk.context.microagents.types.MicroagentMetadata.mcp_tools`

```python
mcp_tools: MCPConfig | None = None
```

####### `openhands.sdk.context.microagents.types.MicroagentMetadata.name`

```python
name: str = Field('default', description='Unique name of the microagent')
```

####### `openhands.sdk.context.microagents.types.MicroagentMetadata.triggers`

```python
triggers: list[str] = []
```

####### `openhands.sdk.context.microagents.types.MicroagentMetadata.type`

```python
type: MicroagentType = Field(default=(MicroagentType.REPO_KNOWLEDGE))
```

###### `openhands.sdk.context.microagents.types.MicroagentResponse`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Response model for microagents endpoint.

Note: This model only includes basic metadata that can be determined
without parsing microagent content. Use the separate content API
to get detailed microagent information.

**Attributes:**

- [**created_at**](#openhands.sdk.context.microagents.types.MicroagentResponse.created_at) (<code>[datetime](#datetime.datetime)</code>) –
- [**name**](#openhands.sdk.context.microagents.types.MicroagentResponse.name) (<code>[str](#str)</code>) –
- [**path**](#openhands.sdk.context.microagents.types.MicroagentResponse.path) (<code>[str](#str)</code>) –

####### `openhands.sdk.context.microagents.types.MicroagentResponse.created_at`

```python
created_at: datetime = Field(default_factory=(lambda: datetime.now(timezone.utc)), description='Timestamp when the microagent was created')
```

####### `openhands.sdk.context.microagents.types.MicroagentResponse.name`

```python
name: str = Field(description='The name of the microagent')
```

####### `openhands.sdk.context.microagents.types.MicroagentResponse.path`

```python
path: str = Field(description='The path or identifier of the microagent')
```

###### `openhands.sdk.context.microagents.types.MicroagentType`

Bases: <code>[str](#str)</code>, <code>[Enum](#enum.Enum)</code>

Type of microagent.

**Attributes:**

- [**KNOWLEDGE**](#openhands.sdk.context.microagents.types.MicroagentType.KNOWLEDGE) –
- [**REPO_KNOWLEDGE**](#openhands.sdk.context.microagents.types.MicroagentType.REPO_KNOWLEDGE) –
- [**TASK**](#openhands.sdk.context.microagents.types.MicroagentType.TASK) –

####### `openhands.sdk.context.microagents.types.MicroagentType.KNOWLEDGE`

```python
KNOWLEDGE = 'knowledge'
```

####### `openhands.sdk.context.microagents.types.MicroagentType.REPO_KNOWLEDGE`

```python
REPO_KNOWLEDGE = 'repo'
```

####### `openhands.sdk.context.microagents.types.MicroagentType.TASK`

```python
TASK = 'task'
```

#### `openhands.sdk.context.prompts`

Context utilities - Template rendering and prompt management.

**Modules:**

- [**prompt**](#openhands.sdk.context.prompts.prompt) – Utilities for rendering Jinja2 templates with platform-specific refinements.

**Functions:**

- [**render_template**](#openhands.sdk.context.prompts.render_template) – Render a Jinja2 template with context and apply platform refinements.

##### `openhands.sdk.context.prompts.prompt`

Utilities for rendering Jinja2 templates with platform-specific refinements.

**Functions:**

- [**refine**](#openhands.sdk.context.prompts.prompt.refine) – Refine text for platform-specific commands (bash -> powershell on Windows).
- [**render_template**](#openhands.sdk.context.prompts.prompt.render_template) – Render a Jinja2 template with context and apply platform refinements.

###### `openhands.sdk.context.prompts.prompt.refine`

```python
refine(text)
```

Refine text for platform-specific commands (bash -> powershell on Windows).

###### `openhands.sdk.context.prompts.prompt.render_template`

```python
render_template(prompt_dir, template_name, **ctx)
```

Render a Jinja2 template with context and apply platform refinements.

##### `openhands.sdk.context.prompts.render_template`

```python
render_template(prompt_dir, template_name, **ctx)
```

Render a Jinja2 template with context and apply platform refinements.

#### `openhands.sdk.context.render_template`

```python
render_template(prompt_dir, template_name, **ctx)
```

Render a Jinja2 template with context and apply platform refinements.

#### `openhands.sdk.context.view`

View implementation for event processing and condensation.

**Classes:**

- [**View**](#openhands.sdk.context.view.View) – Linearly ordered view of events.

**Attributes:**

- [**logger**](#openhands.sdk.context.view.logger) –

##### `openhands.sdk.context.view.View`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Linearly ordered view of events.

Produced by a condenser to indicate the included events are ready to process as LLM
input.

**Functions:**

- [**from_events**](#openhands.sdk.context.view.View.from_events) – Create a view from a list of events, respecting condensation events.

**Attributes:**

- [**events**](#openhands.sdk.context.view.View.events) (<code>[list](#list)\[[LLMConvertibleEvent](#openhands.sdk.event.LLMConvertibleEvent)\]</code>) –
- [**unhandled_condensation_request**](#openhands.sdk.context.view.View.unhandled_condensation_request) (<code>[bool](#bool)</code>) –

###### `openhands.sdk.context.view.View.events`

```python
events: list[LLMConvertibleEvent]
```

###### `openhands.sdk.context.view.View.from_events`

```python
from_events(events)
```

Create a view from a list of events, respecting condensation events.

**Parameters:**

- **events** (<code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>) – List of events to create the view from.

**Returns:**

- <code>[View](#openhands.sdk.context.view.View)</code> – A View instance containing the filtered events.

###### `openhands.sdk.context.view.View.unhandled_condensation_request`

```python
unhandled_condensation_request: bool = False
```

##### `openhands.sdk.context.view.logger`

```python
logger = getLogger(__name__)
```

### `openhands.sdk.conversation`

Conversation management - Agent-user interaction handling.

**Modules:**

- [**conversation**](#openhands.sdk.conversation.conversation) – Conversation management and callback composition.
- [**event_store**](#openhands.sdk.conversation.event_store) –
- [**persistence_const**](#openhands.sdk.conversation.persistence_const) –
- [**serialization_diff**](#openhands.sdk.conversation.serialization_diff) – Conversation serialization diff utilities.
- [**state**](#openhands.sdk.conversation.state) – Conversation state management with thread-safe locking.
- [**types**](#openhands.sdk.conversation.types) – Type definitions for conversation callbacks.
- [**visualizer**](#openhands.sdk.conversation.visualizer) – Conversation visualization utilities.

**Classes:**

- [**Conversation**](#openhands.sdk.conversation.Conversation) – Main conversation handler for agent interactions.
- [**ConversationState**](#openhands.sdk.conversation.ConversationState) – Thread-safe conversation state with locking mechanism.
- [**ConversationVisualizer**](#openhands.sdk.conversation.ConversationVisualizer) – Handles visualization of conversation events with Rich formatting.
- [**EventLog**](#openhands.sdk.conversation.EventLog) –
- [**ListLike**](#openhands.sdk.conversation.ListLike) –

**Attributes:**

- [**ConversationCallbackType**](#openhands.sdk.conversation.ConversationCallbackType) –

#### `openhands.sdk.conversation.Conversation`

```python
Conversation(agent, persist_filestore=None, conversation_id=None, callbacks=None, max_iteration_per_run=500, visualize=True)
```

Main conversation handler for agent interactions.

**Functions:**

- [**close**](#openhands.sdk.conversation.Conversation.close) – Close the conversation and clean up all tool executors.
- [**pause**](#openhands.sdk.conversation.Conversation.pause) – Pause agent execution.
- [**reject_pending_actions**](#openhands.sdk.conversation.Conversation.reject_pending_actions) – Reject all pending actions from the agent.
- [**run**](#openhands.sdk.conversation.Conversation.run) – Run the conversation until the agent finishes.
- [**send_message**](#openhands.sdk.conversation.Conversation.send_message) – Send messages to the agent.
- [**set_confirmation_mode**](#openhands.sdk.conversation.Conversation.set_confirmation_mode) – Enable or disable confirmation mode and store it in conversation state.

**Attributes:**

- [**agent**](#openhands.sdk.conversation.Conversation.agent) –
- [**id**](#openhands.sdk.conversation.Conversation.id) (<code>[str](#str)</code>) – Get the unique ID of the conversation.
- [**max_iteration_per_run**](#openhands.sdk.conversation.Conversation.max_iteration_per_run) –
- [**state**](#openhands.sdk.conversation.Conversation.state) –

Initialize the conversation.

**Parameters:**

- **agent** (<code>[AgentType](#openhands.sdk.agent.AgentType)</code>) – The agent to use for the conversation
- **persist_filestore** (<code>[FileStore](#openhands.sdk.io.FileStore) | None</code>) – Optional FileStore to persist conversation state
- **conversation_id** (<code>[str](#str) | None</code>) – Optional ID for the conversation. If provided, will
  be used to identify the conversation. The user might want to
  suffix their persistent filestore with this ID.
- **callbacks** (<code>[list](#list)\[[ConversationCallbackType](#openhands.sdk.conversation.types.ConversationCallbackType)\] | None</code>) – Optional list of callback functions to handle events
- **max_iteration_per_run** (<code>[int](#int)</code>) – Maximum number of iterations per run
- **visualize** (<code>[bool](#bool)</code>) – Whether to enable default visualization. If True, adds
  a default visualizer callback. If False, relies on
  application to provide visualization through callbacks.

##### `openhands.sdk.conversation.Conversation.agent`

```python
agent = agent
```

##### `openhands.sdk.conversation.Conversation.close`

```python
close()
```

Close the conversation and clean up all tool executors.

##### `openhands.sdk.conversation.Conversation.id`

```python
id: str
```

Get the unique ID of the conversation.

##### `openhands.sdk.conversation.Conversation.max_iteration_per_run`

```python
max_iteration_per_run = max_iteration_per_run
```

##### `openhands.sdk.conversation.Conversation.pause`

```python
pause()
```

Pause agent execution.

This method can be called from any thread to request that the agent
pause execution. The pause will take effect at the next iteration
of the run loop (between agent steps).

Note: If called during an LLM completion, the pause will not take
effect until the current LLM call completes.

##### `openhands.sdk.conversation.Conversation.reject_pending_actions`

```python
reject_pending_actions(reason='User rejected the action')
```

Reject all pending actions from the agent.

This is a non-invasive method to reject actions between run() calls.
Also clears the agent_waiting_for_confirmation flag.

##### `openhands.sdk.conversation.Conversation.run`

```python
run()
```

Run the conversation until the agent finishes.

In confirmation mode:

- First call: creates actions but doesn't execute them, stops and waits
- Second call: executes pending actions (implicit confirmation)

In normal mode:

- Creates and executes actions immediately

Can be paused between steps

##### `openhands.sdk.conversation.Conversation.send_message`

```python
send_message(message)
```

Send messages to the agent.

##### `openhands.sdk.conversation.Conversation.set_confirmation_mode`

```python
set_confirmation_mode(enabled)
```

Enable or disable confirmation mode and store it in conversation state.

##### `openhands.sdk.conversation.Conversation.state`

```python
state = ConversationState.create(id=desired_id, agent=agent, file_store=(self._persist_filestore))
```

#### `openhands.sdk.conversation.ConversationCallbackType`

```python
ConversationCallbackType = Callable[[Event], None]
```

#### `openhands.sdk.conversation.ConversationState`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Thread-safe conversation state with locking mechanism.

**Functions:**

- [**acquire**](#openhands.sdk.conversation.ConversationState.acquire) – Acquire the conversation state lock.
- [**assert_locked**](#openhands.sdk.conversation.ConversationState.assert_locked) – Assert that the current thread holds the lock.
- [**create**](#openhands.sdk.conversation.ConversationState.create) – Create or resume a conversation state.
- [**release**](#openhands.sdk.conversation.ConversationState.release) – Release the conversation state lock.

**Attributes:**

- [**activated_knowledge_microagents**](#openhands.sdk.conversation.ConversationState.activated_knowledge_microagents) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**agent**](#openhands.sdk.conversation.ConversationState.agent) (<code>[AgentType](#openhands.sdk.agent.base.AgentType)</code>) –
- [**agent_finished**](#openhands.sdk.conversation.ConversationState.agent_finished) (<code>[bool](#bool)</code>) –
- [**agent_paused**](#openhands.sdk.conversation.ConversationState.agent_paused) (<code>[bool](#bool)</code>) –
- [**agent_waiting_for_confirmation**](#openhands.sdk.conversation.ConversationState.agent_waiting_for_confirmation) (<code>[bool](#bool)</code>) –
- [**confirmation_mode**](#openhands.sdk.conversation.ConversationState.confirmation_mode) (<code>[bool](#bool)</code>) –
- [**events**](#openhands.sdk.conversation.ConversationState.events) (<code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>) – Get events from the conversations.
- [**id**](#openhands.sdk.conversation.ConversationState.id) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.conversation.ConversationState.model_config) –

##### `openhands.sdk.conversation.ConversationState.acquire`

```python
acquire()
```

Acquire the conversation state lock.

##### `openhands.sdk.conversation.ConversationState.activated_knowledge_microagents`

```python
activated_knowledge_microagents: list[str] = Field(default_factory=list, description='List of activated knowledge microagents name')
```

##### `openhands.sdk.conversation.ConversationState.agent`

```python
agent: AgentType = Field(..., description='The agent running in the conversation. This is persisted to allow resuming conversations and check agent configuration to handle e.g., tool changes, LLM changes, etc.')
```

##### `openhands.sdk.conversation.ConversationState.agent_finished`

```python
agent_finished: bool = Field(default=False)
```

##### `openhands.sdk.conversation.ConversationState.agent_paused`

```python
agent_paused: bool = Field(default=False)
```

##### `openhands.sdk.conversation.ConversationState.agent_waiting_for_confirmation`

```python
agent_waiting_for_confirmation: bool = Field(default=False)
```

##### `openhands.sdk.conversation.ConversationState.assert_locked`

```python
assert_locked()
```

Assert that the current thread holds the lock.

##### `openhands.sdk.conversation.ConversationState.confirmation_mode`

```python
confirmation_mode: bool = Field(default=False)
```

##### `openhands.sdk.conversation.ConversationState.create`

```python
create(id, agent, file_store=None)
```

Create or resume a conversation state.

If base_state.json exists: resume (attach EventLog,
reconcile agent, enforce id).
Else: create fresh (agent required), persist base, and return.

##### `openhands.sdk.conversation.ConversationState.events`

```python
events: ListLike[Event]
```

Get events from the conversations.

##### `openhands.sdk.conversation.ConversationState.id`

```python
id: str = Field(description='Unique conversation ID')
```

##### `openhands.sdk.conversation.ConversationState.model_config`

```python
model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True, frozen=False)
```

##### `openhands.sdk.conversation.ConversationState.release`

```python
release()
```

Release the conversation state lock.

#### `openhands.sdk.conversation.ConversationVisualizer`

```python
ConversationVisualizer(highlight_regex=None, skip_user_messages=False)
```

Handles visualization of conversation events with Rich formatting.

Provides Rich-formatted output with panels and complete content display.

**Functions:**

- [**on_event**](#openhands.sdk.conversation.ConversationVisualizer.on_event) – Display events with Rich formatting.

Initialize the visualizer.

**Parameters:**

- **highlight_regex** (<code>[Dict](#typing.Dict)\[[str](#str), [str](#str)\] | None</code>) – Dictionary mapping regex patterns to Rich color styles
  for highlighting keywords in the visualizer.
  For example: {"Reasoning:": "bold blue",
  "Thought:": "bold green"}
- **skip_user_messages** (<code>[bool](#bool)</code>) – If True, skip displaying user messages. Useful for
  scenarios where user input is not relevant to show.

##### `openhands.sdk.conversation.ConversationVisualizer.on_event`

```python
on_event(event)
```

Display events with Rich formatting.

#### `openhands.sdk.conversation.EventLog`

```python
EventLog(fs, dir_path=EVENTS_DIR)
```

Bases: <code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>

**Functions:**

- [**append**](#openhands.sdk.conversation.EventLog.append) –
- [**get_id**](#openhands.sdk.conversation.EventLog.get_id) – Return the event_id for a given index.
- [**get_index**](#openhands.sdk.conversation.EventLog.get_index) – Return the integer index for a given event_id.

##### `openhands.sdk.conversation.EventLog.append`

```python
append(item)
```

##### `openhands.sdk.conversation.EventLog.get_id`

```python
get_id(idx)
```

Return the event_id for a given index.

##### `openhands.sdk.conversation.EventLog.get_index`

```python
get_index(event_id)
```

Return the integer index for a given event_id.

#### `openhands.sdk.conversation.ListLike`

Bases: <code>[Protocol](#typing.Protocol)\[[T](#openhands.sdk.utils.protocol.T)\]</code>

**Functions:**

- [**append**](#openhands.sdk.conversation.ListLike.append) –

##### `openhands.sdk.conversation.ListLike.append`

```python
append(__object)
```

#### `openhands.sdk.conversation.conversation`

Conversation management and callback composition.

**Classes:**

- [**Conversation**](#openhands.sdk.conversation.conversation.Conversation) – Main conversation handler for agent interactions.

**Functions:**

- [**compose_callbacks**](#openhands.sdk.conversation.conversation.compose_callbacks) – Compose multiple callbacks into a single callback function.

**Attributes:**

- [**logger**](#openhands.sdk.conversation.conversation.logger) –

##### `openhands.sdk.conversation.conversation.Conversation`

```python
Conversation(agent, persist_filestore=None, conversation_id=None, callbacks=None, max_iteration_per_run=500, visualize=True)
```

Main conversation handler for agent interactions.

**Functions:**

- [**close**](#openhands.sdk.conversation.conversation.Conversation.close) – Close the conversation and clean up all tool executors.
- [**pause**](#openhands.sdk.conversation.conversation.Conversation.pause) – Pause agent execution.
- [**reject_pending_actions**](#openhands.sdk.conversation.conversation.Conversation.reject_pending_actions) – Reject all pending actions from the agent.
- [**run**](#openhands.sdk.conversation.conversation.Conversation.run) – Run the conversation until the agent finishes.
- [**send_message**](#openhands.sdk.conversation.conversation.Conversation.send_message) – Send messages to the agent.
- [**set_confirmation_mode**](#openhands.sdk.conversation.conversation.Conversation.set_confirmation_mode) – Enable or disable confirmation mode and store it in conversation state.

**Attributes:**

- [**agent**](#openhands.sdk.conversation.conversation.Conversation.agent) –
- [**id**](#openhands.sdk.conversation.conversation.Conversation.id) (<code>[str](#str)</code>) – Get the unique ID of the conversation.
- [**max_iteration_per_run**](#openhands.sdk.conversation.conversation.Conversation.max_iteration_per_run) –
- [**state**](#openhands.sdk.conversation.conversation.Conversation.state) –

Initialize the conversation.

**Parameters:**

- **agent** (<code>[AgentType](#openhands.sdk.agent.AgentType)</code>) – The agent to use for the conversation
- **persist_filestore** (<code>[FileStore](#openhands.sdk.io.FileStore) | None</code>) – Optional FileStore to persist conversation state
- **conversation_id** (<code>[str](#str) | None</code>) – Optional ID for the conversation. If provided, will
  be used to identify the conversation. The user might want to
  suffix their persistent filestore with this ID.
- **callbacks** (<code>[list](#list)\[[ConversationCallbackType](#openhands.sdk.conversation.types.ConversationCallbackType)\] | None</code>) – Optional list of callback functions to handle events
- **max_iteration_per_run** (<code>[int](#int)</code>) – Maximum number of iterations per run
- **visualize** (<code>[bool](#bool)</code>) – Whether to enable default visualization. If True, adds
  a default visualizer callback. If False, relies on
  application to provide visualization through callbacks.

###### `openhands.sdk.conversation.conversation.Conversation.agent`

```python
agent = agent
```

###### `openhands.sdk.conversation.conversation.Conversation.close`

```python
close()
```

Close the conversation and clean up all tool executors.

###### `openhands.sdk.conversation.conversation.Conversation.id`

```python
id: str
```

Get the unique ID of the conversation.

###### `openhands.sdk.conversation.conversation.Conversation.max_iteration_per_run`

```python
max_iteration_per_run = max_iteration_per_run
```

###### `openhands.sdk.conversation.conversation.Conversation.pause`

```python
pause()
```

Pause agent execution.

This method can be called from any thread to request that the agent
pause execution. The pause will take effect at the next iteration
of the run loop (between agent steps).

Note: If called during an LLM completion, the pause will not take
effect until the current LLM call completes.

###### `openhands.sdk.conversation.conversation.Conversation.reject_pending_actions`

```python
reject_pending_actions(reason='User rejected the action')
```

Reject all pending actions from the agent.

This is a non-invasive method to reject actions between run() calls.
Also clears the agent_waiting_for_confirmation flag.

###### `openhands.sdk.conversation.conversation.Conversation.run`

```python
run()
```

Run the conversation until the agent finishes.

In confirmation mode:

- First call: creates actions but doesn't execute them, stops and waits
- Second call: executes pending actions (implicit confirmation)

In normal mode:

- Creates and executes actions immediately

Can be paused between steps

###### `openhands.sdk.conversation.conversation.Conversation.send_message`

```python
send_message(message)
```

Send messages to the agent.

###### `openhands.sdk.conversation.conversation.Conversation.set_confirmation_mode`

```python
set_confirmation_mode(enabled)
```

Enable or disable confirmation mode and store it in conversation state.

###### `openhands.sdk.conversation.conversation.Conversation.state`

```python
state = ConversationState.create(id=desired_id, agent=agent, file_store=(self._persist_filestore))
```

##### `openhands.sdk.conversation.conversation.compose_callbacks`

```python
compose_callbacks(callbacks)
```

Compose multiple callbacks into a single callback function.

##### `openhands.sdk.conversation.conversation.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.conversation.event_store`

**Classes:**

- [**EventLog**](#openhands.sdk.conversation.event_store.EventLog) –

**Attributes:**

- [**logger**](#openhands.sdk.conversation.event_store.logger) –

##### `openhands.sdk.conversation.event_store.EventLog`

```python
EventLog(fs, dir_path=EVENTS_DIR)
```

Bases: <code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>

**Functions:**

- [**append**](#openhands.sdk.conversation.event_store.EventLog.append) –
- [**get_id**](#openhands.sdk.conversation.event_store.EventLog.get_id) – Return the event_id for a given index.
- [**get_index**](#openhands.sdk.conversation.event_store.EventLog.get_index) – Return the integer index for a given event_id.

###### `openhands.sdk.conversation.event_store.EventLog.append`

```python
append(item)
```

###### `openhands.sdk.conversation.event_store.EventLog.get_id`

```python
get_id(idx)
```

Return the event_id for a given index.

###### `openhands.sdk.conversation.event_store.EventLog.get_index`

```python
get_index(event_id)
```

Return the integer index for a given event_id.

##### `openhands.sdk.conversation.event_store.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.conversation.persistence_const`

**Attributes:**

- [**BASE_STATE**](#openhands.sdk.conversation.persistence_const.BASE_STATE) –
- [**EVENTS_DIR**](#openhands.sdk.conversation.persistence_const.EVENTS_DIR) –
- [**EVENT_FILE_PATTERN**](#openhands.sdk.conversation.persistence_const.EVENT_FILE_PATTERN) –
- [**EVENT_NAME_RE**](#openhands.sdk.conversation.persistence_const.EVENT_NAME_RE) –

##### `openhands.sdk.conversation.persistence_const.BASE_STATE`

```python
BASE_STATE = 'base_state.json'
```

##### `openhands.sdk.conversation.persistence_const.EVENTS_DIR`

```python
EVENTS_DIR = 'events'
```

##### `openhands.sdk.conversation.persistence_const.EVENT_FILE_PATTERN`

```python
EVENT_FILE_PATTERN = 'event-{idx:05d}-{event_id}.json'
```

##### `openhands.sdk.conversation.persistence_const.EVENT_NAME_RE`

```python
EVENT_NAME_RE = re.compile('^event-(?P<idx>\\d{5})-(?P<event_id>[0-9a-fA-F\\-]{8,})\\.json$')
```

#### `openhands.sdk.conversation.serialization_diff`

Conversation serialization diff utilities.

#### `openhands.sdk.conversation.state`

Conversation state management with thread-safe locking.

**Classes:**

- [**ConversationState**](#openhands.sdk.conversation.state.ConversationState) – Thread-safe conversation state with locking mechanism.

**Attributes:**

- [**logger**](#openhands.sdk.conversation.state.logger) –

##### `openhands.sdk.conversation.state.ConversationState`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Thread-safe conversation state with locking mechanism.

**Functions:**

- [**acquire**](#openhands.sdk.conversation.state.ConversationState.acquire) – Acquire the conversation state lock.
- [**assert_locked**](#openhands.sdk.conversation.state.ConversationState.assert_locked) – Assert that the current thread holds the lock.
- [**create**](#openhands.sdk.conversation.state.ConversationState.create) – Create or resume a conversation state.
- [**release**](#openhands.sdk.conversation.state.ConversationState.release) – Release the conversation state lock.

**Attributes:**

- [**activated_knowledge_microagents**](#openhands.sdk.conversation.state.ConversationState.activated_knowledge_microagents) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**agent**](#openhands.sdk.conversation.state.ConversationState.agent) (<code>[AgentType](#openhands.sdk.agent.base.AgentType)</code>) –
- [**agent_finished**](#openhands.sdk.conversation.state.ConversationState.agent_finished) (<code>[bool](#bool)</code>) –
- [**agent_paused**](#openhands.sdk.conversation.state.ConversationState.agent_paused) (<code>[bool](#bool)</code>) –
- [**agent_waiting_for_confirmation**](#openhands.sdk.conversation.state.ConversationState.agent_waiting_for_confirmation) (<code>[bool](#bool)</code>) –
- [**confirmation_mode**](#openhands.sdk.conversation.state.ConversationState.confirmation_mode) (<code>[bool](#bool)</code>) –
- [**events**](#openhands.sdk.conversation.state.ConversationState.events) (<code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>) – Get events from the conversations.
- [**id**](#openhands.sdk.conversation.state.ConversationState.id) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.conversation.state.ConversationState.model_config) –

###### `openhands.sdk.conversation.state.ConversationState.acquire`

```python
acquire()
```

Acquire the conversation state lock.

###### `openhands.sdk.conversation.state.ConversationState.activated_knowledge_microagents`

```python
activated_knowledge_microagents: list[str] = Field(default_factory=list, description='List of activated knowledge microagents name')
```

###### `openhands.sdk.conversation.state.ConversationState.agent`

```python
agent: AgentType = Field(..., description='The agent running in the conversation. This is persisted to allow resuming conversations and check agent configuration to handle e.g., tool changes, LLM changes, etc.')
```

###### `openhands.sdk.conversation.state.ConversationState.agent_finished`

```python
agent_finished: bool = Field(default=False)
```

###### `openhands.sdk.conversation.state.ConversationState.agent_paused`

```python
agent_paused: bool = Field(default=False)
```

###### `openhands.sdk.conversation.state.ConversationState.agent_waiting_for_confirmation`

```python
agent_waiting_for_confirmation: bool = Field(default=False)
```

###### `openhands.sdk.conversation.state.ConversationState.assert_locked`

```python
assert_locked()
```

Assert that the current thread holds the lock.

###### `openhands.sdk.conversation.state.ConversationState.confirmation_mode`

```python
confirmation_mode: bool = Field(default=False)
```

###### `openhands.sdk.conversation.state.ConversationState.create`

```python
create(id, agent, file_store=None)
```

Create or resume a conversation state.

If base_state.json exists: resume (attach EventLog,
reconcile agent, enforce id).
Else: create fresh (agent required), persist base, and return.

###### `openhands.sdk.conversation.state.ConversationState.events`

```python
events: ListLike[Event]
```

Get events from the conversations.

###### `openhands.sdk.conversation.state.ConversationState.id`

```python
id: str = Field(description='Unique conversation ID')
```

###### `openhands.sdk.conversation.state.ConversationState.model_config`

```python
model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True, frozen=False)
```

###### `openhands.sdk.conversation.state.ConversationState.release`

```python
release()
```

Release the conversation state lock.

##### `openhands.sdk.conversation.state.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.conversation.types`

Type definitions for conversation callbacks.

**Attributes:**

- [**ConversationCallbackType**](#openhands.sdk.conversation.types.ConversationCallbackType) –

##### `openhands.sdk.conversation.types.ConversationCallbackType`

```python
ConversationCallbackType = Callable[[Event], None]
```

#### `openhands.sdk.conversation.visualizer`

Conversation visualization utilities.

**Classes:**

- [**ConversationVisualizer**](#openhands.sdk.conversation.visualizer.ConversationVisualizer) – Handles visualization of conversation events with Rich formatting.

**Functions:**

- [**create_default_visualizer**](#openhands.sdk.conversation.visualizer.create_default_visualizer) – Create a default conversation visualizer instance.

**Attributes:**

- [**DEFAULT_HIGHLIGHT_REGEX**](#openhands.sdk.conversation.visualizer.DEFAULT_HIGHLIGHT_REGEX) –

##### `openhands.sdk.conversation.visualizer.ConversationVisualizer`

```python
ConversationVisualizer(highlight_regex=None, skip_user_messages=False)
```

Handles visualization of conversation events with Rich formatting.

Provides Rich-formatted output with panels and complete content display.

**Functions:**

- [**on_event**](#openhands.sdk.conversation.visualizer.ConversationVisualizer.on_event) – Display events with Rich formatting.

Initialize the visualizer.

**Parameters:**

- **highlight_regex** (<code>[Dict](#typing.Dict)\[[str](#str), [str](#str)\] | None</code>) – Dictionary mapping regex patterns to Rich color styles
  for highlighting keywords in the visualizer.
  For example: {"Reasoning:": "bold blue",
  "Thought:": "bold green"}
- **skip_user_messages** (<code>[bool](#bool)</code>) – If True, skip displaying user messages. Useful for
  scenarios where user input is not relevant to show.

###### `openhands.sdk.conversation.visualizer.ConversationVisualizer.on_event`

```python
on_event(event)
```

Display events with Rich formatting.

##### `openhands.sdk.conversation.visualizer.DEFAULT_HIGHLIGHT_REGEX`

```python
DEFAULT_HIGHLIGHT_REGEX = {'^Reasoning:': f'bold {_THOUGHT_COLOR}', '^Thought:': f'bold {_THOUGHT_COLOR}', '^Action:': f'bold {_ACTION_COLOR}', '^Arguments:': f'bold {_ACTION_COLOR}', '^Tool:': f'bold {_OBSERVATION_COLOR}', '^Result:': f'bold {_OBSERVATION_COLOR}', '\\*\\*(.*?)\\*\\*': 'bold', '\\*(.*?)\\*': 'italic'}
```

##### `openhands.sdk.conversation.visualizer.create_default_visualizer`

```python
create_default_visualizer(highlight_regex=None, **kwargs)
```

Create a default conversation visualizer instance.

**Parameters:**

- **highlight_regex** (<code>[Dict](#typing.Dict)\[[str](#str), [str](#str)\] | None</code>) – Dictionary mapping regex patterns to Rich color styles
  for highlighting keywords in the visualizer.
  For example: {"Reasoning:": "bold blue",
  "Thought:": "bold green"}
- \*\***kwargs** – Additional keyword arguments passed to ConversationVisualizer.

### `openhands.sdk.create_mcp_tools`

```python
create_mcp_tools(config, timeout=30.0)
```

Create MCP tools from MCP configuration.

### `openhands.sdk.event`

Event system for agent communication and state management.

**Modules:**

- [**base**](#openhands.sdk.event.base) – Base event classes and interfaces.
- [**condenser**](#openhands.sdk.event.condenser) – Event classes for conversation history condensation.
- [**llm_convertible**](#openhands.sdk.event.llm_convertible) – Events that can be converted to LLM messages.
- [**types**](#openhands.sdk.event.types) – Type definitions for events and sources.
- [**user_action**](#openhands.sdk.event.user_action) – User action events.
- [**utils**](#openhands.sdk.event.utils) – Utility functions for event processing.

**Classes:**

- [**ActionEvent**](#openhands.sdk.event.ActionEvent) – Event representing an action taken by the agent.
- [**AgentErrorEvent**](#openhands.sdk.event.AgentErrorEvent) – Error triggered by the agent.
- [**Condensation**](#openhands.sdk.event.Condensation) – Action indicating a condensation of the conversation history is happening.
- [**CondensationRequest**](#openhands.sdk.event.CondensationRequest) – Action used to request a condensation of the conversation history.
- [**EventBase**](#openhands.sdk.event.EventBase) – Base class for all events.
- [**LLMConvertibleEvent**](#openhands.sdk.event.LLMConvertibleEvent) – Base class for events that can be converted to LLM messages.
- [**MessageEvent**](#openhands.sdk.event.MessageEvent) – Message from either agent or user.
- [**ObservationEvent**](#openhands.sdk.event.ObservationEvent) – Event representing an observation from the environment.
- [**PauseEvent**](#openhands.sdk.event.PauseEvent) – Event indicating that the agent execution was paused by user request.
- [**SystemPromptEvent**](#openhands.sdk.event.SystemPromptEvent) – System prompt added by the agent.
- [**UserRejectObservation**](#openhands.sdk.event.UserRejectObservation) – Observation when user rejects an action in confirmation mode.

**Attributes:**

- [**Event**](#openhands.sdk.event.Event) – Type annotation for values that can be any implementation of EventBase.

#### `openhands.sdk.event.ActionEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Event representing an action taken by the agent.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.ActionEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.ActionEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.ActionEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.ActionEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.ActionEvent.to_llm_message) – Individual message - may be incomplete for multi-action batches.

**Attributes:**

- [**action**](#openhands.sdk.event.ActionEvent.action) (<code>[Action](#openhands.sdk.tool.Action)</code>) –
- [**id**](#openhands.sdk.event.ActionEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.ActionEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm_response_id**](#openhands.sdk.event.ActionEvent.llm_response_id) (<code>[str](#str)</code>) –
- [**metrics**](#openhands.sdk.event.ActionEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.ActionEvent.model_config) –
- [**reasoning_content**](#openhands.sdk.event.ActionEvent.reasoning_content) (<code>[str](#str) | None</code>) –
- [**source**](#openhands.sdk.event.ActionEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**thought**](#openhands.sdk.event.ActionEvent.thought) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent)\]</code>) –
- [**timestamp**](#openhands.sdk.event.ActionEvent.timestamp) (<code>[str](#str)</code>) –
- [**tool_call**](#openhands.sdk.event.ActionEvent.tool_call) (<code>[ChatCompletionMessageToolCall](#litellm.ChatCompletionMessageToolCall)</code>) –
- [**tool_call_id**](#openhands.sdk.event.ActionEvent.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.ActionEvent.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.ActionEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action event.

##### `openhands.sdk.event.ActionEvent.action`

```python
action: Action = Field(..., description='Single action (tool call) returned by LLM')
```

##### `openhands.sdk.event.ActionEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.ActionEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.ActionEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.ActionEvent.llm_response_id`

```python
llm_response_id: str = Field(..., description='Groups related actions from same LLM response. This helps in tracking and managing results of parallel function calling from the same LLM response.')
```

##### `openhands.sdk.event.ActionEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs). Only attached to the last action when multiple actions share the same LLM response.')
```

##### `openhands.sdk.event.ActionEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.ActionEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.ActionEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.ActionEvent.reasoning_content`

```python
reasoning_content: str | None = Field(default=None, description='Intermediate reasoning/thinking content from reasoning models')
```

##### `openhands.sdk.event.ActionEvent.source`

```python
source: SourceType = 'agent'
```

##### `openhands.sdk.event.ActionEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.ActionEvent.thought`

```python
thought: list[TextContent] = Field(..., description='The thought process of the agent before taking this action')
```

##### `openhands.sdk.event.ActionEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.ActionEvent.to_llm_message`

```python
to_llm_message()
```

Individual message - may be incomplete for multi-action batches.

##### `openhands.sdk.event.ActionEvent.tool_call`

```python
tool_call: ChatCompletionMessageToolCall = Field(..., description='The tool call received from the LLM response. We keep a copy of it so it is easier to construct it into LLM message')
```

##### `openhands.sdk.event.ActionEvent.tool_call_id`

```python
tool_call_id: str = Field(..., description='The unique id returned by LLM API for this tool call')
```

##### `openhands.sdk.event.ActionEvent.tool_name`

```python
tool_name: str = Field(..., description='The name of the tool being called')
```

##### `openhands.sdk.event.ActionEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action event.

#### `openhands.sdk.event.AgentErrorEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Error triggered by the agent.

Note: This event should not contain model "thought" or "reasoning_content". It
represents an error produced by the agent/scaffold, not model output.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.AgentErrorEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.AgentErrorEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.AgentErrorEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.AgentErrorEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.AgentErrorEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**error**](#openhands.sdk.event.AgentErrorEvent.error) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.AgentErrorEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.AgentErrorEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**metrics**](#openhands.sdk.event.AgentErrorEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.AgentErrorEvent.model_config) –
- [**source**](#openhands.sdk.event.AgentErrorEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.AgentErrorEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.AgentErrorEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this agent error event.

##### `openhands.sdk.event.AgentErrorEvent.error`

```python
error: str = Field(..., description='The error message from the scaffold')
```

##### `openhands.sdk.event.AgentErrorEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.AgentErrorEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.AgentErrorEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.AgentErrorEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs). Only attached to the last action when multiple actions share the same LLM response.')
```

##### `openhands.sdk.event.AgentErrorEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.AgentErrorEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.AgentErrorEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.AgentErrorEvent.source`

```python
source: SourceType = 'agent'
```

##### `openhands.sdk.event.AgentErrorEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.AgentErrorEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.AgentErrorEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

##### `openhands.sdk.event.AgentErrorEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this agent error event.

#### `openhands.sdk.event.Condensation`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Action indicating a condensation of the conversation history is happening.

**Functions:**

- [**model_validate**](#openhands.sdk.event.Condensation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.Condensation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.Condensation.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**forgotten**](#openhands.sdk.event.Condensation.forgotten) (<code>[list](#list)\[[str](#str)\]</code>) – The list of event IDs that should be forgotten.
- [**forgotten_event_ids**](#openhands.sdk.event.Condensation.forgotten_event_ids) (<code>[list](#list)\[[str](#str)\] | None</code>) – The IDs of the events that are being forgotten (removed from the `View` given to
- [**id**](#openhands.sdk.event.Condensation.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.Condensation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.event.Condensation.message) (<code>[str](#str)</code>) – Get a human-readable message describing the condensation.
- [**model_config**](#openhands.sdk.event.Condensation.model_config) –
- [**source**](#openhands.sdk.event.Condensation.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**summary**](#openhands.sdk.event.Condensation.summary) (<code>[str](#str) | None</code>) – An optional summary of the events being forgotten.
- [**summary_offset**](#openhands.sdk.event.Condensation.summary_offset) (<code>[int](#int) | None</code>) – An optional offset to the start of the resulting view indicating where the
- [**timestamp**](#openhands.sdk.event.Condensation.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.Condensation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

##### `openhands.sdk.event.Condensation.forgotten`

```python
forgotten: list[str]
```

The list of event IDs that should be forgotten.

##### `openhands.sdk.event.Condensation.forgotten_event_ids`

```python
forgotten_event_ids: list[str] | None = None
```

The IDs of the events that are being forgotten (removed from the `View` given to
the LLM).

##### `openhands.sdk.event.Condensation.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.Condensation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.Condensation.message`

```python
message: str
```

Get a human-readable message describing the condensation.

##### `openhands.sdk.event.Condensation.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.Condensation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.Condensation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.Condensation.source`

```python
source: SourceType = 'environment'
```

##### `openhands.sdk.event.Condensation.summary`

```python
summary: str | None = None
```

An optional summary of the events being forgotten.

##### `openhands.sdk.event.Condensation.summary_offset`

```python
summary_offset: int | None = None
```

An optional offset to the start of the resulting view indicating where the
summary should be inserted.

##### `openhands.sdk.event.Condensation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.Condensation.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.Condensation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

#### `openhands.sdk.event.CondensationRequest`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Action used to request a condensation of the conversation history.

**Attributes:**

- [**action**](#openhands.sdk.event.CondensationRequest.action) (<code>[str](#str)</code>) – The action type, namely ActionType.CONDENSATION_REQUEST.

**Functions:**

- [**model_validate**](#openhands.sdk.event.CondensationRequest.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.CondensationRequest.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.CondensationRequest.target_subclass) – Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.CondensationRequest.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.CondensationRequest.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.CondensationRequest.message`

```python
message: str
```

Get a human-readable message describing the condensation request.

##### `openhands.sdk.event.CondensationRequest.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.CondensationRequest.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.CondensationRequest.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.CondensationRequest.source`

```python
source: SourceType = 'environment'
```

##### `openhands.sdk.event.CondensationRequest.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.CondensationRequest.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.CondensationRequest.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

#### `openhands.sdk.event.Event`

```python
Event = Annotated[EventBase, DiscriminatedUnionType[EventBase]]
```

Type annotation for values that can be any implementation of EventBase.

In most situations, this is equivalent to EventBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.

#### `openhands.sdk.event.EventBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all events.

**Functions:**

- [**model_validate**](#openhands.sdk.event.EventBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.EventBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.EventBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**id**](#openhands.sdk.event.EventBase.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.EventBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.EventBase.model_config) –
- [**source**](#openhands.sdk.event.EventBase.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.EventBase.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.EventBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

##### `openhands.sdk.event.EventBase.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.EventBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.EventBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.EventBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.EventBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.EventBase.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

##### `openhands.sdk.event.EventBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.EventBase.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.EventBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

#### `openhands.sdk.event.LLMConvertibleEvent`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>, <code>[ABC](#abc.ABC)</code>

Base class for events that can be converted to LLM messages.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.LLMConvertibleEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.LLMConvertibleEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.LLMConvertibleEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.LLMConvertibleEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.LLMConvertibleEvent.to_llm_message) – Convert the event to an LLM message.

**Attributes:**

- [**id**](#openhands.sdk.event.LLMConvertibleEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.LLMConvertibleEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.LLMConvertibleEvent.model_config) –
- [**source**](#openhands.sdk.event.LLMConvertibleEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.LLMConvertibleEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.LLMConvertibleEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

##### `openhands.sdk.event.LLMConvertibleEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.LLMConvertibleEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.LLMConvertibleEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.LLMConvertibleEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.LLMConvertibleEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.LLMConvertibleEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.LLMConvertibleEvent.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

##### `openhands.sdk.event.LLMConvertibleEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.LLMConvertibleEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.LLMConvertibleEvent.to_llm_message`

```python
to_llm_message()
```

Convert the event to an LLM message.

##### `openhands.sdk.event.LLMConvertibleEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

#### `openhands.sdk.event.MessageEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Message from either agent or user.

This is originally the "MessageAction", but it suppose not to be tool call.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.MessageEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.MessageEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.MessageEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**reasoning_content**](#openhands.sdk.event.MessageEvent.reasoning_content) – Get the reasoning content from the LLM message.
- [**target_subclass**](#openhands.sdk.event.MessageEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.MessageEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**activated_microagents**](#openhands.sdk.event.MessageEvent.activated_microagents) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**extended_content**](#openhands.sdk.event.MessageEvent.extended_content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent)\]</code>) –
- [**id**](#openhands.sdk.event.MessageEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.MessageEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm_message**](#openhands.sdk.event.MessageEvent.llm_message) (<code>[Message](#openhands.sdk.llm.Message)</code>) –
- [**metrics**](#openhands.sdk.event.MessageEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.MessageEvent.model_config) –
- [**source**](#openhands.sdk.event.MessageEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.MessageEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.MessageEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this message event.

##### `openhands.sdk.event.MessageEvent.activated_microagents`

```python
activated_microagents: list[str] = Field(default_factory=list, description='List of activated microagent name')
```

##### `openhands.sdk.event.MessageEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.MessageEvent.extended_content`

```python
extended_content: list[TextContent] = Field(default_factory=list, description='List of content added by agent context')
```

##### `openhands.sdk.event.MessageEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.MessageEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.MessageEvent.llm_message`

```python
llm_message: Message = Field(..., description='The exact LLM message for this message event')
```

##### `openhands.sdk.event.MessageEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs) for this message. Only attached to messages from agent.')
```

##### `openhands.sdk.event.MessageEvent.model_config`

```python
model_config = ConfigDict(extra='ignore')
```

##### `openhands.sdk.event.MessageEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.MessageEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.MessageEvent.reasoning_content`

```python
reasoning_content()
```

Get the reasoning content from the LLM message.

##### `openhands.sdk.event.MessageEvent.source`

```python
source: SourceType
```

##### `openhands.sdk.event.MessageEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.MessageEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.MessageEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

##### `openhands.sdk.event.MessageEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this message event.

#### `openhands.sdk.event.ObservationEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Event representing an observation from the environment.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.ObservationEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.ObservationEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.ObservationEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.ObservationEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.ObservationEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**action_id**](#openhands.sdk.event.ObservationEvent.action_id) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.ObservationEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.ObservationEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.ObservationEvent.model_config) –
- [**observation**](#openhands.sdk.event.ObservationEvent.observation) (<code>[Observation](#openhands.sdk.tool.Observation)</code>) –
- [**source**](#openhands.sdk.event.ObservationEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.ObservationEvent.timestamp) (<code>[str](#str)</code>) –
- [**tool_call_id**](#openhands.sdk.event.ObservationEvent.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.ObservationEvent.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.ObservationEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this observation event.

##### `openhands.sdk.event.ObservationEvent.action_id`

```python
action_id: str = Field(..., description='The action id that this observation is responding to')
```

##### `openhands.sdk.event.ObservationEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.ObservationEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.ObservationEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.ObservationEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.ObservationEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.ObservationEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.ObservationEvent.observation`

```python
observation: Observation = Field(..., description='The observation (tool call) sent to LLM')
```

##### `openhands.sdk.event.ObservationEvent.source`

```python
source: SourceType = 'environment'
```

##### `openhands.sdk.event.ObservationEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.ObservationEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.ObservationEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

##### `openhands.sdk.event.ObservationEvent.tool_call_id`

```python
tool_call_id: str = Field(..., description='The tool call id that this observation is responding to')
```

##### `openhands.sdk.event.ObservationEvent.tool_name`

```python
tool_name: str = Field(..., description='The tool name that this observation is responding to')
```

##### `openhands.sdk.event.ObservationEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this observation event.

#### `openhands.sdk.event.PauseEvent`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Event indicating that the agent execution was paused by user request.

**Functions:**

- [**model_validate**](#openhands.sdk.event.PauseEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.PauseEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.PauseEvent.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**id**](#openhands.sdk.event.PauseEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.PauseEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.PauseEvent.model_config) –
- [**source**](#openhands.sdk.event.PauseEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.PauseEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.PauseEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this pause event.

##### `openhands.sdk.event.PauseEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.PauseEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.PauseEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.PauseEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.PauseEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.PauseEvent.source`

```python
source: SourceType = 'user'
```

##### `openhands.sdk.event.PauseEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.PauseEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.PauseEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this pause event.

#### `openhands.sdk.event.SystemPromptEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

System prompt added by the agent.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.SystemPromptEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.SystemPromptEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.SystemPromptEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.SystemPromptEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.SystemPromptEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**id**](#openhands.sdk.event.SystemPromptEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.SystemPromptEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.SystemPromptEvent.model_config) –
- [**source**](#openhands.sdk.event.SystemPromptEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**system_prompt**](#openhands.sdk.event.SystemPromptEvent.system_prompt) (<code>[TextContent](#openhands.sdk.llm.TextContent)</code>) –
- [**timestamp**](#openhands.sdk.event.SystemPromptEvent.timestamp) (<code>[str](#str)</code>) –
- [**tools**](#openhands.sdk.event.SystemPromptEvent.tools) (<code>[list](#list)\[[ChatCompletionToolParam](#litellm.ChatCompletionToolParam)\]</code>) –
- [**visualize**](#openhands.sdk.event.SystemPromptEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this system prompt event.

##### `openhands.sdk.event.SystemPromptEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.SystemPromptEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.SystemPromptEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.SystemPromptEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.SystemPromptEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.SystemPromptEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.SystemPromptEvent.source`

```python
source: SourceType = 'agent'
```

##### `openhands.sdk.event.SystemPromptEvent.system_prompt`

```python
system_prompt: TextContent = Field(..., description='The system prompt text')
```

##### `openhands.sdk.event.SystemPromptEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.SystemPromptEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.SystemPromptEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

##### `openhands.sdk.event.SystemPromptEvent.tools`

```python
tools: list[ChatCompletionToolParam] = Field(..., description='List of tools in OpenAI tool format')
```

##### `openhands.sdk.event.SystemPromptEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this system prompt event.

#### `openhands.sdk.event.UserRejectObservation`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Observation when user rejects an action in confirmation mode.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.UserRejectObservation.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.UserRejectObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.UserRejectObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.UserRejectObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.UserRejectObservation.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**action_id**](#openhands.sdk.event.UserRejectObservation.action_id) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.UserRejectObservation.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.UserRejectObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.UserRejectObservation.model_config) –
- [**rejection_reason**](#openhands.sdk.event.UserRejectObservation.rejection_reason) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.event.UserRejectObservation.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.UserRejectObservation.timestamp) (<code>[str](#str)</code>) –
- [**tool_call_id**](#openhands.sdk.event.UserRejectObservation.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.UserRejectObservation.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.UserRejectObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this user rejection event.

##### `openhands.sdk.event.UserRejectObservation.action_id`

```python
action_id: str = Field(..., description='The action id that this rejection is responding to')
```

##### `openhands.sdk.event.UserRejectObservation.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

##### `openhands.sdk.event.UserRejectObservation.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

##### `openhands.sdk.event.UserRejectObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.event.UserRejectObservation.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.event.UserRejectObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.event.UserRejectObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.event.UserRejectObservation.rejection_reason`

```python
rejection_reason: str = Field(default='User rejected the action', description='Reason for rejecting the action')
```

##### `openhands.sdk.event.UserRejectObservation.source`

```python
source: SourceType = 'user'
```

##### `openhands.sdk.event.UserRejectObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.event.UserRejectObservation.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

##### `openhands.sdk.event.UserRejectObservation.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

##### `openhands.sdk.event.UserRejectObservation.tool_call_id`

```python
tool_call_id: str = Field(..., description='The tool call id that this rejection is responding to')
```

##### `openhands.sdk.event.UserRejectObservation.tool_name`

```python
tool_name: str = Field(..., description='The tool name that this rejection is responding to')
```

##### `openhands.sdk.event.UserRejectObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this user rejection event.

#### `openhands.sdk.event.base`

Base event classes and interfaces.

**Classes:**

- [**EventBase**](#openhands.sdk.event.base.EventBase) – Base class for all events.
- [**LLMConvertibleEvent**](#openhands.sdk.event.base.LLMConvertibleEvent) – Base class for events that can be converted to LLM messages.

**Attributes:**

- [**Event**](#openhands.sdk.event.base.Event) – Type annotation for values that can be any implementation of EventBase.
- [**N_CHAR_PREVIEW**](#openhands.sdk.event.base.N_CHAR_PREVIEW) –

##### `openhands.sdk.event.base.Event`

```python
Event = Annotated[EventBase, DiscriminatedUnionType[EventBase]]
```

Type annotation for values that can be any implementation of EventBase.

In most situations, this is equivalent to EventBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.

##### `openhands.sdk.event.base.EventBase`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[ABC](#abc.ABC)</code>

Base class for all events.

**Functions:**

- [**model_validate**](#openhands.sdk.event.base.EventBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.base.EventBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.base.EventBase.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**id**](#openhands.sdk.event.base.EventBase.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.base.EventBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.base.EventBase.model_config) –
- [**source**](#openhands.sdk.event.base.EventBase.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.base.EventBase.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.base.EventBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

###### `openhands.sdk.event.base.EventBase.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.base.EventBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.base.EventBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.base.EventBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.base.EventBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.base.EventBase.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

###### `openhands.sdk.event.base.EventBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.base.EventBase.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.base.EventBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

##### `openhands.sdk.event.base.LLMConvertibleEvent`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>, <code>[ABC](#abc.ABC)</code>

Base class for events that can be converted to LLM messages.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.base.LLMConvertibleEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.base.LLMConvertibleEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.base.LLMConvertibleEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.base.LLMConvertibleEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.base.LLMConvertibleEvent.to_llm_message) – Convert the event to an LLM message.

**Attributes:**

- [**id**](#openhands.sdk.event.base.LLMConvertibleEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.base.LLMConvertibleEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.base.LLMConvertibleEvent.model_config) –
- [**source**](#openhands.sdk.event.base.LLMConvertibleEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.base.LLMConvertibleEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.base.LLMConvertibleEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

###### `openhands.sdk.event.base.LLMConvertibleEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.base.LLMConvertibleEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.base.LLMConvertibleEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.base.LLMConvertibleEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.base.LLMConvertibleEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.base.LLMConvertibleEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.base.LLMConvertibleEvent.source`

```python
source: SourceType = Field(..., description='The source of this event')
```

###### `openhands.sdk.event.base.LLMConvertibleEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.base.LLMConvertibleEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.base.LLMConvertibleEvent.to_llm_message`

```python
to_llm_message()
```

Convert the event to an LLM message.

###### `openhands.sdk.event.base.LLMConvertibleEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

##### `openhands.sdk.event.base.N_CHAR_PREVIEW`

```python
N_CHAR_PREVIEW = 500
```

#### `openhands.sdk.event.condenser`

Event classes for conversation history condensation.

**Classes:**

- [**Condensation**](#openhands.sdk.event.condenser.Condensation) – Action indicating a condensation of the conversation history is happening.
- [**CondensationRequest**](#openhands.sdk.event.condenser.CondensationRequest) – Action used to request a condensation of the conversation history.

##### `openhands.sdk.event.condenser.Condensation`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Action indicating a condensation of the conversation history is happening.

**Functions:**

- [**model_validate**](#openhands.sdk.event.condenser.Condensation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.condenser.Condensation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.condenser.Condensation.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**forgotten**](#openhands.sdk.event.condenser.Condensation.forgotten) (<code>[list](#list)\[[str](#str)\]</code>) – The list of event IDs that should be forgotten.
- [**forgotten_event_ids**](#openhands.sdk.event.condenser.Condensation.forgotten_event_ids) (<code>[list](#list)\[[str](#str)\] | None</code>) – The IDs of the events that are being forgotten (removed from the `View` given to
- [**id**](#openhands.sdk.event.condenser.Condensation.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.condenser.Condensation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.event.condenser.Condensation.message) (<code>[str](#str)</code>) – Get a human-readable message describing the condensation.
- [**model_config**](#openhands.sdk.event.condenser.Condensation.model_config) –
- [**source**](#openhands.sdk.event.condenser.Condensation.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**summary**](#openhands.sdk.event.condenser.Condensation.summary) (<code>[str](#str) | None</code>) – An optional summary of the events being forgotten.
- [**summary_offset**](#openhands.sdk.event.condenser.Condensation.summary_offset) (<code>[int](#int) | None</code>) – An optional offset to the start of the resulting view indicating where the
- [**timestamp**](#openhands.sdk.event.condenser.Condensation.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.condenser.Condensation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this event.

###### `openhands.sdk.event.condenser.Condensation.forgotten`

```python
forgotten: list[str]
```

The list of event IDs that should be forgotten.

###### `openhands.sdk.event.condenser.Condensation.forgotten_event_ids`

```python
forgotten_event_ids: list[str] | None = None
```

The IDs of the events that are being forgotten (removed from the `View` given to
the LLM).

###### `openhands.sdk.event.condenser.Condensation.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.condenser.Condensation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.condenser.Condensation.message`

```python
message: str
```

Get a human-readable message describing the condensation.

###### `openhands.sdk.event.condenser.Condensation.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.condenser.Condensation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.condenser.Condensation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.condenser.Condensation.source`

```python
source: SourceType = 'environment'
```

###### `openhands.sdk.event.condenser.Condensation.summary`

```python
summary: str | None = None
```

An optional summary of the events being forgotten.

###### `openhands.sdk.event.condenser.Condensation.summary_offset`

```python
summary_offset: int | None = None
```

An optional offset to the start of the resulting view indicating where the
summary should be inserted.

###### `openhands.sdk.event.condenser.Condensation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.condenser.Condensation.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.condenser.Condensation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

##### `openhands.sdk.event.condenser.CondensationRequest`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Action used to request a condensation of the conversation history.

**Attributes:**

- [**action**](#openhands.sdk.event.condenser.CondensationRequest.action) (<code>[str](#str)</code>) – The action type, namely ActionType.CONDENSATION_REQUEST.

**Functions:**

- [**model_validate**](#openhands.sdk.event.condenser.CondensationRequest.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.condenser.CondensationRequest.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.condenser.CondensationRequest.target_subclass) – Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.condenser.CondensationRequest.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.condenser.CondensationRequest.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.condenser.CondensationRequest.message`

```python
message: str
```

Get a human-readable message describing the condensation request.

###### `openhands.sdk.event.condenser.CondensationRequest.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.condenser.CondensationRequest.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.condenser.CondensationRequest.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.condenser.CondensationRequest.source`

```python
source: SourceType = 'environment'
```

###### `openhands.sdk.event.condenser.CondensationRequest.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.condenser.CondensationRequest.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.condenser.CondensationRequest.visualize`

```python
visualize: Text
```

Return Rich Text representation of this event.

This is a fallback implementation for unknown event types.
Subclasses should override this method to provide specific visualization.

#### `openhands.sdk.event.llm_convertible`

Events that can be converted to LLM messages.

**Classes:**

- [**ActionEvent**](#openhands.sdk.event.llm_convertible.ActionEvent) – Event representing an action taken by the agent.
- [**AgentErrorEvent**](#openhands.sdk.event.llm_convertible.AgentErrorEvent) – Error triggered by the agent.
- [**MessageEvent**](#openhands.sdk.event.llm_convertible.MessageEvent) – Message from either agent or user.
- [**ObservationEvent**](#openhands.sdk.event.llm_convertible.ObservationEvent) – Event representing an observation from the environment.
- [**SystemPromptEvent**](#openhands.sdk.event.llm_convertible.SystemPromptEvent) – System prompt added by the agent.
- [**UserRejectObservation**](#openhands.sdk.event.llm_convertible.UserRejectObservation) – Observation when user rejects an action in confirmation mode.

##### `openhands.sdk.event.llm_convertible.ActionEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Event representing an action taken by the agent.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.ActionEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.ActionEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.ActionEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.ActionEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.ActionEvent.to_llm_message) – Individual message - may be incomplete for multi-action batches.

**Attributes:**

- [**action**](#openhands.sdk.event.llm_convertible.ActionEvent.action) (<code>[Action](#openhands.sdk.tool.Action)</code>) –
- [**id**](#openhands.sdk.event.llm_convertible.ActionEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.ActionEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm_response_id**](#openhands.sdk.event.llm_convertible.ActionEvent.llm_response_id) (<code>[str](#str)</code>) –
- [**metrics**](#openhands.sdk.event.llm_convertible.ActionEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.llm_convertible.ActionEvent.model_config) –
- [**reasoning_content**](#openhands.sdk.event.llm_convertible.ActionEvent.reasoning_content) (<code>[str](#str) | None</code>) –
- [**source**](#openhands.sdk.event.llm_convertible.ActionEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**thought**](#openhands.sdk.event.llm_convertible.ActionEvent.thought) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent)\]</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.ActionEvent.timestamp) (<code>[str](#str)</code>) –
- [**tool_call**](#openhands.sdk.event.llm_convertible.ActionEvent.tool_call) (<code>[ChatCompletionMessageToolCall](#litellm.ChatCompletionMessageToolCall)</code>) –
- [**tool_call_id**](#openhands.sdk.event.llm_convertible.ActionEvent.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.llm_convertible.ActionEvent.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.ActionEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action event.

###### `openhands.sdk.event.llm_convertible.ActionEvent.action`

```python
action: Action = Field(..., description='Single action (tool call) returned by LLM')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.ActionEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.ActionEvent.llm_response_id`

```python
llm_response_id: str = Field(..., description='Groups related actions from same LLM response. This helps in tracking and managing results of parallel function calling from the same LLM response.')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs). Only attached to the last action when multiple actions share the same LLM response.')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.ActionEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.ActionEvent.reasoning_content`

```python
reasoning_content: str | None = Field(default=None, description='Intermediate reasoning/thinking content from reasoning models')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.source`

```python
source: SourceType = 'agent'
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.ActionEvent.thought`

```python
thought: list[TextContent] = Field(..., description='The thought process of the agent before taking this action')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.to_llm_message`

```python
to_llm_message()
```

Individual message - may be incomplete for multi-action batches.

###### `openhands.sdk.event.llm_convertible.ActionEvent.tool_call`

```python
tool_call: ChatCompletionMessageToolCall = Field(..., description='The tool call received from the LLM response. We keep a copy of it so it is easier to construct it into LLM message')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.tool_call_id`

```python
tool_call_id: str = Field(..., description='The unique id returned by LLM API for this tool call')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.tool_name`

```python
tool_name: str = Field(..., description='The name of the tool being called')
```

###### `openhands.sdk.event.llm_convertible.ActionEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action event.

##### `openhands.sdk.event.llm_convertible.AgentErrorEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Error triggered by the agent.

Note: This event should not contain model "thought" or "reasoning_content". It
represents an error produced by the agent/scaffold, not model output.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**error**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.error) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**metrics**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.model_config) –
- [**source**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.AgentErrorEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this agent error event.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.error`

```python
error: str = Field(..., description='The error message from the scaffold')
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs). Only attached to the last action when multiple actions share the same LLM response.')
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.source`

```python
source: SourceType = 'agent'
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

###### `openhands.sdk.event.llm_convertible.AgentErrorEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this agent error event.

##### `openhands.sdk.event.llm_convertible.MessageEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Message from either agent or user.

This is originally the "MessageAction", but it suppose not to be tool call.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.MessageEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.MessageEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.MessageEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**reasoning_content**](#openhands.sdk.event.llm_convertible.MessageEvent.reasoning_content) – Get the reasoning content from the LLM message.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.MessageEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.MessageEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**activated_microagents**](#openhands.sdk.event.llm_convertible.MessageEvent.activated_microagents) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**extended_content**](#openhands.sdk.event.llm_convertible.MessageEvent.extended_content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent)\]</code>) –
- [**id**](#openhands.sdk.event.llm_convertible.MessageEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.MessageEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**llm_message**](#openhands.sdk.event.llm_convertible.MessageEvent.llm_message) (<code>[Message](#openhands.sdk.llm.Message)</code>) –
- [**metrics**](#openhands.sdk.event.llm_convertible.MessageEvent.metrics) (<code>[MetricsSnapshot](#openhands.sdk.llm.utils.metrics.MetricsSnapshot) | None</code>) –
- [**model_config**](#openhands.sdk.event.llm_convertible.MessageEvent.model_config) –
- [**source**](#openhands.sdk.event.llm_convertible.MessageEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.MessageEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.MessageEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this message event.

###### `openhands.sdk.event.llm_convertible.MessageEvent.activated_microagents`

```python
activated_microagents: list[str] = Field(default_factory=list, description='List of activated microagent name')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.MessageEvent.extended_content`

```python
extended_content: list[TextContent] = Field(default_factory=list, description='List of content added by agent context')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.MessageEvent.llm_message`

```python
llm_message: Message = Field(..., description='The exact LLM message for this message event')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.metrics`

```python
metrics: MetricsSnapshot | None = Field(default=None, description='Snapshot of LLM metrics (token counts and costs) for this message. Only attached to messages from agent.')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.model_config`

```python
model_config = ConfigDict(extra='ignore')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.MessageEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.MessageEvent.reasoning_content`

```python
reasoning_content()
```

Get the reasoning content from the LLM message.

###### `openhands.sdk.event.llm_convertible.MessageEvent.source`

```python
source: SourceType
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.MessageEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.MessageEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

###### `openhands.sdk.event.llm_convertible.MessageEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this message event.

##### `openhands.sdk.event.llm_convertible.ObservationEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Event representing an observation from the environment.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.ObservationEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.ObservationEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.ObservationEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.ObservationEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.ObservationEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**action_id**](#openhands.sdk.event.llm_convertible.ObservationEvent.action_id) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.llm_convertible.ObservationEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.ObservationEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.llm_convertible.ObservationEvent.model_config) –
- [**observation**](#openhands.sdk.event.llm_convertible.ObservationEvent.observation) (<code>[Observation](#openhands.sdk.tool.Observation)</code>) –
- [**source**](#openhands.sdk.event.llm_convertible.ObservationEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.ObservationEvent.timestamp) (<code>[str](#str)</code>) –
- [**tool_call_id**](#openhands.sdk.event.llm_convertible.ObservationEvent.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.llm_convertible.ObservationEvent.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.ObservationEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this observation event.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.action_id`

```python
action_id: str = Field(..., description='The action id that this observation is responding to')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.observation`

```python
observation: Observation = Field(..., description='The observation (tool call) sent to LLM')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.source`

```python
source: SourceType = 'environment'
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

###### `openhands.sdk.event.llm_convertible.ObservationEvent.tool_call_id`

```python
tool_call_id: str = Field(..., description='The tool call id that this observation is responding to')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.tool_name`

```python
tool_name: str = Field(..., description='The tool name that this observation is responding to')
```

###### `openhands.sdk.event.llm_convertible.ObservationEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this observation event.

##### `openhands.sdk.event.llm_convertible.SystemPromptEvent`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

System prompt added by the agent.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**id**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.model_config) –
- [**source**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**system_prompt**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.system_prompt) (<code>[TextContent](#openhands.sdk.llm.TextContent)</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.timestamp) (<code>[str](#str)</code>) –
- [**tools**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.tools) (<code>[list](#list)\[[ChatCompletionToolParam](#litellm.ChatCompletionToolParam)\]</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.SystemPromptEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this system prompt event.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.source`

```python
source: SourceType = 'agent'
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.system_prompt`

```python
system_prompt: TextContent = Field(..., description='The system prompt text')
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.tools`

```python
tools: list[ChatCompletionToolParam] = Field(..., description='List of tools in OpenAI tool format')
```

###### `openhands.sdk.event.llm_convertible.SystemPromptEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this system prompt event.

##### `openhands.sdk.event.llm_convertible.UserRejectObservation`

Bases: <code>[LLMConvertibleEvent](#openhands.sdk.event.base.LLMConvertibleEvent)</code>

Observation when user rejects an action in confirmation mode.

**Functions:**

- [**events_to_messages**](#openhands.sdk.event.llm_convertible.UserRejectObservation.events_to_messages) – Convert event stream to LLM message stream, handling multi-action batches.
- [**model_validate**](#openhands.sdk.event.llm_convertible.UserRejectObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.llm_convertible.UserRejectObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.llm_convertible.UserRejectObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_llm_message**](#openhands.sdk.event.llm_convertible.UserRejectObservation.to_llm_message) – Convert to LLM message.

**Attributes:**

- [**action_id**](#openhands.sdk.event.llm_convertible.UserRejectObservation.action_id) (<code>[str](#str)</code>) –
- [**id**](#openhands.sdk.event.llm_convertible.UserRejectObservation.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.llm_convertible.UserRejectObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.llm_convertible.UserRejectObservation.model_config) –
- [**rejection_reason**](#openhands.sdk.event.llm_convertible.UserRejectObservation.rejection_reason) (<code>[str](#str)</code>) –
- [**source**](#openhands.sdk.event.llm_convertible.UserRejectObservation.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.llm_convertible.UserRejectObservation.timestamp) (<code>[str](#str)</code>) –
- [**tool_call_id**](#openhands.sdk.event.llm_convertible.UserRejectObservation.tool_call_id) (<code>[str](#str)</code>) –
- [**tool_name**](#openhands.sdk.event.llm_convertible.UserRejectObservation.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.llm_convertible.UserRejectObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this user rejection event.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.action_id`

```python
action_id: str = Field(..., description='The action id that this rejection is responding to')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.events_to_messages`

```python
events_to_messages(events)
```

Convert event stream to LLM message stream, handling multi-action batches.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.rejection_reason`

```python
rejection_reason: str = Field(default='User rejected the action', description='Reason for rejecting the action')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.source`

```python
source: SourceType = 'user'
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.to_llm_message`

```python
to_llm_message()
```

Convert to LLM message.

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.tool_call_id`

```python
tool_call_id: str = Field(..., description='The tool call id that this rejection is responding to')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.tool_name`

```python
tool_name: str = Field(..., description='The tool name that this rejection is responding to')
```

###### `openhands.sdk.event.llm_convertible.UserRejectObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this user rejection event.

#### `openhands.sdk.event.types`

Type definitions for events and sources.

**Attributes:**

- [**EventType**](#openhands.sdk.event.types.EventType) –
- [**SourceType**](#openhands.sdk.event.types.SourceType) –

##### `openhands.sdk.event.types.EventType`

```python
EventType = Literal['action', 'observation', 'message', 'system_prompt', 'agent_error']
```

##### `openhands.sdk.event.types.SourceType`

```python
SourceType = Literal['agent', 'user', 'environment']
```

#### `openhands.sdk.event.user_action`

User action events.

**Classes:**

- [**PauseEvent**](#openhands.sdk.event.user_action.PauseEvent) – Event indicating that the agent execution was paused by user request.

##### `openhands.sdk.event.user_action.PauseEvent`

Bases: <code>[EventBase](#openhands.sdk.event.base.EventBase)</code>

Event indicating that the agent execution was paused by user request.

**Functions:**

- [**model_validate**](#openhands.sdk.event.user_action.PauseEvent.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.event.user_action.PauseEvent.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.event.user_action.PauseEvent.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**id**](#openhands.sdk.event.user_action.PauseEvent.id) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.event.user_action.PauseEvent.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.event.user_action.PauseEvent.model_config) –
- [**source**](#openhands.sdk.event.user_action.PauseEvent.source) (<code>[SourceType](#openhands.sdk.event.types.SourceType)</code>) –
- [**timestamp**](#openhands.sdk.event.user_action.PauseEvent.timestamp) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.event.user_action.PauseEvent.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this pause event.

###### `openhands.sdk.event.user_action.PauseEvent.id`

```python
id: str = Field(default_factory=(lambda: str(uuid.uuid4())), description='Unique event id (ULID/UUID)')
```

###### `openhands.sdk.event.user_action.PauseEvent.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.event.user_action.PauseEvent.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.event.user_action.PauseEvent.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.event.user_action.PauseEvent.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.event.user_action.PauseEvent.source`

```python
source: SourceType = 'user'
```

###### `openhands.sdk.event.user_action.PauseEvent.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.event.user_action.PauseEvent.timestamp`

```python
timestamp: str = Field(default_factory=(lambda: datetime.now().isoformat()), description='Event timestamp')
```

###### `openhands.sdk.event.user_action.PauseEvent.visualize`

```python
visualize: Text
```

Return Rich Text representation of this pause event.

#### `openhands.sdk.event.utils`

Utility functions for event processing.

**Functions:**

- [**get_unmatched_actions**](#openhands.sdk.event.utils.get_unmatched_actions) – Find actions in the event history that don't have matching observations.

##### `openhands.sdk.event.utils.get_unmatched_actions`

```python
get_unmatched_actions(events)
```

Find actions in the event history that don't have matching observations.

Optimized to search in reverse chronological order since recent actions
are more likely to be unmatched (pending confirmation).

**Parameters:**

- **events** (<code>[ListLike](#openhands.sdk.utils.protocol.ListLike)\[[Event](#openhands.sdk.event.Event)\]</code>) – List of events to search through

**Returns:**

- <code>[list](#list)\[[ActionEvent](#openhands.sdk.event.ActionEvent)\]</code> – List of ActionEvent objects that don't have corresponding observations

### `openhands.sdk.get_logger`

```python
get_logger(name)
```

Return a logger for the given module name.

### `openhands.sdk.io`

File storage interfaces and implementations.

**Modules:**

- [**base**](#openhands.sdk.io.base) – Base file storage interface.
- [**local**](#openhands.sdk.io.local) – Local file store implementation.
- [**memory**](#openhands.sdk.io.memory) –

**Classes:**

- [**FileStore**](#openhands.sdk.io.FileStore) – Abstract base class for file storage operations.
- [**InMemoryFileStore**](#openhands.sdk.io.InMemoryFileStore) –
- [**LocalFileStore**](#openhands.sdk.io.LocalFileStore) – Local file store implementation using the local filesystem.

#### `openhands.sdk.io.FileStore`

Abstract base class for file storage operations.

**Functions:**

- [**delete**](#openhands.sdk.io.FileStore.delete) – Delete a file or directory at the specified path.
- [**list**](#openhands.sdk.io.FileStore.list) – List files and directories at the specified path.
- [**read**](#openhands.sdk.io.FileStore.read) – Read contents from a file at the specified path.
- [**write**](#openhands.sdk.io.FileStore.write) – Write contents to a file at the specified path.

##### `openhands.sdk.io.FileStore.delete`

```python
delete(path)
```

Delete a file or directory at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, implementations should handle this
gracefully without raising an exception.
</details>

##### `openhands.sdk.io.FileStore.list`

```python
list(path)
```

List files and directories at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list.

**Returns:**

- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – A list of file and directory names. Directory names end with "/".
- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist.

##### `openhands.sdk.io.FileStore.read`

```python
read(path)
```

Read contents from a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string.

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

##### `openhands.sdk.io.FileStore.write`

```python
write(path, contents)
```

Write contents to a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to. Can be nested
  (e.g., "folder/subfolder/file.txt").
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, implementations should
create them automatically.
</details>

#### `openhands.sdk.io.InMemoryFileStore`

```python
InMemoryFileStore(files=None)
```

Bases: <code>[FileStore](#openhands.sdk.io.base.FileStore)</code>

**Functions:**

- [**delete**](#openhands.sdk.io.InMemoryFileStore.delete) –
- [**list**](#openhands.sdk.io.InMemoryFileStore.list) –
- [**read**](#openhands.sdk.io.InMemoryFileStore.read) –
- [**write**](#openhands.sdk.io.InMemoryFileStore.write) –

**Attributes:**

- [**files**](#openhands.sdk.io.InMemoryFileStore.files) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –

##### `openhands.sdk.io.InMemoryFileStore.delete`

```python
delete(path)
```

##### `openhands.sdk.io.InMemoryFileStore.files`

```python
files: dict[str, str] = {}
```

##### `openhands.sdk.io.InMemoryFileStore.list`

```python
list(path)
```

##### `openhands.sdk.io.InMemoryFileStore.read`

```python
read(path)
```

##### `openhands.sdk.io.InMemoryFileStore.write`

```python
write(path, contents)
```

#### `openhands.sdk.io.LocalFileStore`

```python
LocalFileStore(root)
```

Bases: <code>[FileStore](#openhands.sdk.io.base.FileStore)</code>

Local file store implementation using the local filesystem.

This implementation provides file storage operations on the local filesystem
with automatic directory creation and graceful error handling.

**Attributes:**

- [**root**](#openhands.sdk.io.LocalFileStore.root) (<code>[str](#str)</code>) – The root directory path for all file operations.

**Functions:**

- [**delete**](#openhands.sdk.io.LocalFileStore.delete) – Delete a file or directory at the given path.
- [**get_full_path**](#openhands.sdk.io.LocalFileStore.get_full_path) – Get the full filesystem path for a given relative path.
- [**list**](#openhands.sdk.io.LocalFileStore.list) – List files and directories at the given path.
- [**read**](#openhands.sdk.io.LocalFileStore.read) – Read contents from a file at the given path.
- [**write**](#openhands.sdk.io.LocalFileStore.write) – Write contents to a file at the given path.

Initialize the local file store with a root directory.

**Parameters:**

- **root** (<code>[str](#str)</code>) – The root directory path. Supports tilde expansion (e.g., "~/data").
  If the directory doesn't exist, it will be created automatically.

##### `openhands.sdk.io.LocalFileStore.delete`

```python
delete(path)
```

Delete a file or directory at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete, relative to the root directory.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, this method returns silently without error.
For directories, all contents are recursively deleted.
Any errors during deletion are logged but do not raise exceptions.
</details>

##### `openhands.sdk.io.LocalFileStore.get_full_path`

```python
get_full_path(path)
```

Get the full filesystem path for a given relative path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The relative path within the file store.
  Leading slashes are automatically stripped.

**Returns:**

- <code>[str](#str)</code> – The absolute filesystem path.

##### `openhands.sdk.io.LocalFileStore.list`

```python
list(path)
```

List files and directories at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list, relative to the root directory.

**Returns:**

- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – A list of file and directory paths. Directory names end with "/".
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – (consistent with S3 API).

<details class="note" open>
<summary>Note</summary>
This method returns full paths relative to the root directory,
not just the filenames.
</details>

##### `openhands.sdk.io.LocalFileStore.read`

```python
read(path)
```

Read contents from a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from, relative to the root directory.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string (decoded with UTF-8).

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

##### `openhands.sdk.io.LocalFileStore.root`

```python
root: str = root
```

##### `openhands.sdk.io.LocalFileStore.write`

```python
write(path, contents)
```

Write contents to a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to, relative to the root directory.
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, they will be created
automatically. String content is written with UTF-8 encoding.
</details>

#### `openhands.sdk.io.base`

Base file storage interface.

**Classes:**

- [**FileStore**](#openhands.sdk.io.base.FileStore) – Abstract base class for file storage operations.

##### `openhands.sdk.io.base.FileStore`

Abstract base class for file storage operations.

**Functions:**

- [**delete**](#openhands.sdk.io.base.FileStore.delete) – Delete a file or directory at the specified path.
- [**list**](#openhands.sdk.io.base.FileStore.list) – List files and directories at the specified path.
- [**read**](#openhands.sdk.io.base.FileStore.read) – Read contents from a file at the specified path.
- [**write**](#openhands.sdk.io.base.FileStore.write) – Write contents to a file at the specified path.

###### `openhands.sdk.io.base.FileStore.delete`

```python
delete(path)
```

Delete a file or directory at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, implementations should handle this
gracefully without raising an exception.
</details>

###### `openhands.sdk.io.base.FileStore.list`

```python
list(path)
```

List files and directories at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list.

**Returns:**

- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – A list of file and directory names. Directory names end with "/".
- <code>[list](#openhands.sdk.io.base.FileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist.

###### `openhands.sdk.io.base.FileStore.read`

```python
read(path)
```

Read contents from a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string.

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

###### `openhands.sdk.io.base.FileStore.write`

```python
write(path, contents)
```

Write contents to a file at the specified path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to. Can be nested
  (e.g., "folder/subfolder/file.txt").
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, implementations should
create them automatically.
</details>

#### `openhands.sdk.io.local`

Local file store implementation.

**Classes:**

- [**LocalFileStore**](#openhands.sdk.io.local.LocalFileStore) – Local file store implementation using the local filesystem.

**Attributes:**

- [**logger**](#openhands.sdk.io.local.logger) –

##### `openhands.sdk.io.local.LocalFileStore`

```python
LocalFileStore(root)
```

Bases: <code>[FileStore](#openhands.sdk.io.base.FileStore)</code>

Local file store implementation using the local filesystem.

This implementation provides file storage operations on the local filesystem
with automatic directory creation and graceful error handling.

**Attributes:**

- [**root**](#openhands.sdk.io.local.LocalFileStore.root) (<code>[str](#str)</code>) – The root directory path for all file operations.

**Functions:**

- [**delete**](#openhands.sdk.io.local.LocalFileStore.delete) – Delete a file or directory at the given path.
- [**get_full_path**](#openhands.sdk.io.local.LocalFileStore.get_full_path) – Get the full filesystem path for a given relative path.
- [**list**](#openhands.sdk.io.local.LocalFileStore.list) – List files and directories at the given path.
- [**read**](#openhands.sdk.io.local.LocalFileStore.read) – Read contents from a file at the given path.
- [**write**](#openhands.sdk.io.local.LocalFileStore.write) – Write contents to a file at the given path.

Initialize the local file store with a root directory.

**Parameters:**

- **root** (<code>[str](#str)</code>) – The root directory path. Supports tilde expansion (e.g., "~/data").
  If the directory doesn't exist, it will be created automatically.

###### `openhands.sdk.io.local.LocalFileStore.delete`

```python
delete(path)
```

Delete a file or directory at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file or directory path to delete, relative to the root directory.

<details class="note" open>
<summary>Note</summary>
If the path does not exist, this method returns silently without error.
For directories, all contents are recursively deleted.
Any errors during deletion are logged but do not raise exceptions.
</details>

###### `openhands.sdk.io.local.LocalFileStore.get_full_path`

```python
get_full_path(path)
```

Get the full filesystem path for a given relative path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The relative path within the file store.
  Leading slashes are automatically stripped.

**Returns:**

- <code>[str](#str)</code> – The absolute filesystem path.

###### `openhands.sdk.io.local.LocalFileStore.list`

```python
list(path)
```

List files and directories at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The directory path to list, relative to the root directory.

**Returns:**

- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – A list of file and directory paths. Directory names end with "/".
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – Returns an empty list if the directory does not exist
- <code>[list](#openhands.sdk.io.local.LocalFileStore.list)\[[str](#str)\]</code> – (consistent with S3 API).

<details class="note" open>
<summary>Note</summary>
This method returns full paths relative to the root directory,
not just the filenames.
</details>

###### `openhands.sdk.io.local.LocalFileStore.read`

```python
read(path)
```

Read contents from a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to read from, relative to the root directory.

**Returns:**

- <code>[str](#str)</code> – The file contents as a string (decoded with UTF-8).

**Raises:**

- <code>[FileNotFoundError](#FileNotFoundError)</code> – If the file does not exist.

###### `openhands.sdk.io.local.LocalFileStore.root`

```python
root: str = root
```

###### `openhands.sdk.io.local.LocalFileStore.write`

```python
write(path, contents)
```

Write contents to a file at the given path.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path to write to, relative to the root directory.
- **contents** (<code>[str](#str) | [bytes](#bytes)</code>) – The content to write, either as string or bytes.

<details class="note" open>
<summary>Note</summary>
If parent directories in the path don't exist, they will be created
automatically. String content is written with UTF-8 encoding.
</details>

##### `openhands.sdk.io.local.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.io.memory`

**Classes:**

- [**InMemoryFileStore**](#openhands.sdk.io.memory.InMemoryFileStore) –

**Attributes:**

- [**logger**](#openhands.sdk.io.memory.logger) –

##### `openhands.sdk.io.memory.InMemoryFileStore`

```python
InMemoryFileStore(files=None)
```

Bases: <code>[FileStore](#openhands.sdk.io.base.FileStore)</code>

**Functions:**

- [**delete**](#openhands.sdk.io.memory.InMemoryFileStore.delete) –
- [**list**](#openhands.sdk.io.memory.InMemoryFileStore.list) –
- [**read**](#openhands.sdk.io.memory.InMemoryFileStore.read) –
- [**write**](#openhands.sdk.io.memory.InMemoryFileStore.write) –

**Attributes:**

- [**files**](#openhands.sdk.io.memory.InMemoryFileStore.files) (<code>[dict](#dict)\[[str](#str), [str](#str)\]</code>) –

###### `openhands.sdk.io.memory.InMemoryFileStore.delete`

```python
delete(path)
```

###### `openhands.sdk.io.memory.InMemoryFileStore.files`

```python
files: dict[str, str] = {}
```

###### `openhands.sdk.io.memory.InMemoryFileStore.list`

```python
list(path)
```

###### `openhands.sdk.io.memory.InMemoryFileStore.read`

```python
read(path)
```

###### `openhands.sdk.io.memory.InMemoryFileStore.write`

```python
write(path, contents)
```

##### `openhands.sdk.io.memory.logger`

```python
logger = get_logger(__name__)
```

### `openhands.sdk.llm`

LLM integration module - Language model interfaces and utilities.

**Modules:**

- [**exceptions**](#openhands.sdk.llm.exceptions) – LLM-related exception classes.
- [**llm**](#openhands.sdk.llm.llm) – LLM interface and implementation using LiteLLM.
- [**llm_registry**](#openhands.sdk.llm.llm_registry) – LLM registry for managing LLM instances.
- [**message**](#openhands.sdk.llm.message) – Message types and content for LLM communication.
- [**metadata**](#openhands.sdk.llm.metadata) – LLM metadata utilities for tracing and telemetry.

**Classes:**

- [**ImageContent**](#openhands.sdk.llm.ImageContent) – Image content for messages.
- [**LLM**](#openhands.sdk.llm.LLM) – Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.
- [**LLMRegistry**](#openhands.sdk.llm.LLMRegistry) – A minimal LLM registry for managing LLM instances by service ID.
- [**Message**](#openhands.sdk.llm.Message) – Message for LLM communication.
- [**RegistryEvent**](#openhands.sdk.llm.RegistryEvent) – Event representing LLM registration or deregistration.
- [**TextContent**](#openhands.sdk.llm.TextContent) – Text content for messages.

**Functions:**

- [**content_to_str**](#openhands.sdk.llm.content_to_str) – Convert a list of TextContent and ImageContent to a list of strings.
- [**get_llm_metadata**](#openhands.sdk.llm.get_llm_metadata) – Get metadata for LLM tracing and telemetry.

#### `openhands.sdk.llm.ImageContent`

Bases: <code>[ImageContent](#mcp.types.ImageContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Image content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.llm.ImageContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.llm.ImageContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**image_urls**](#openhands.sdk.llm.ImageContent.image_urls) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**model_config**](#openhands.sdk.llm.ImageContent.model_config) –
- [**type**](#openhands.sdk.llm.ImageContent.type) (<code>[Literal](#typing.Literal)['image']</code>) –

##### `openhands.sdk.llm.ImageContent.cache_prompt`

```python
cache_prompt: bool = False
```

##### `openhands.sdk.llm.ImageContent.image_urls`

```python
image_urls: list[str]
```

##### `openhands.sdk.llm.ImageContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

##### `openhands.sdk.llm.ImageContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

##### `openhands.sdk.llm.ImageContent.type`

```python
type: Literal['image'] = 'image'
```

#### `openhands.sdk.llm.LLM`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[RetryMixin](#openhands.sdk.llm.llm.RetryMixin)</code>, <code>[NonNativeToolCallingMixin](#openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin)</code>

Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.

**Functions:**

- [**completion**](#openhands.sdk.llm.LLM.completion) – Single entry point for LLM completion.
- [**deserialize**](#openhands.sdk.llm.LLM.deserialize) – Deserialize LLM from dictionary.
- [**format_messages_for_llm**](#openhands.sdk.llm.LLM.format_messages_for_llm) – Format Message objects for LLM consumption.
- [**get_token_count**](#openhands.sdk.llm.LLM.get_token_count) – Get token count for messages.
- [**is_caching_prompt_active**](#openhands.sdk.llm.LLM.is_caching_prompt_active) – Check if prompt caching is supported and enabled for current model.
- [**is_function_calling_active**](#openhands.sdk.llm.LLM.is_function_calling_active) – Check whether function calling is supported and enabled for this LLM.
- [**load_from_env**](#openhands.sdk.llm.LLM.load_from_env) – Load LLM from environment variables.
- [**load_from_json**](#openhands.sdk.llm.LLM.load_from_json) – Load LLM from JSON file.
- [**load_from_toml**](#openhands.sdk.llm.LLM.load_from_toml) – Load LLM from TOML file.
- [**resolve_diff_from_deserialized**](#openhands.sdk.llm.LLM.resolve_diff_from_deserialized) – Resolve differences between a deserialized LLM and the current instance.
- [**retry_decorator**](#openhands.sdk.llm.LLM.retry_decorator) – Create a retry decorator with exponential backoff.
- [**serialize**](#openhands.sdk.llm.LLM.serialize) – Serialize LLM to dictionary.
- [**vision_is_active**](#openhands.sdk.llm.LLM.vision_is_active) – Check if vision capabilities are active.

**Attributes:**

- [**OVERRIDE_ON_SERIALIZE**](#openhands.sdk.llm.LLM.OVERRIDE_ON_SERIALIZE) (<code>[tuple](#tuple)\[[str](#str), ...\]</code>) –
- [**api_key**](#openhands.sdk.llm.LLM.api_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**api_version**](#openhands.sdk.llm.LLM.api_version) (<code>[str](#str) | None</code>) –
- [**aws_access_key_id**](#openhands.sdk.llm.LLM.aws_access_key_id) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**aws_region_name**](#openhands.sdk.llm.LLM.aws_region_name) (<code>[str](#str) | None</code>) –
- [**aws_secret_access_key**](#openhands.sdk.llm.LLM.aws_secret_access_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**base_url**](#openhands.sdk.llm.LLM.base_url) (<code>[str](#str) | None</code>) –
- [**caching_prompt**](#openhands.sdk.llm.LLM.caching_prompt) (<code>[bool](#bool)</code>) –
- [**custom_llm_provider**](#openhands.sdk.llm.LLM.custom_llm_provider) (<code>[str](#str) | None</code>) –
- [**custom_tokenizer**](#openhands.sdk.llm.LLM.custom_tokenizer) (<code>[str](#str) | None</code>) –
- [**disable_stop_word**](#openhands.sdk.llm.LLM.disable_stop_word) (<code>[bool](#bool) | None</code>) –
- [**disable_vision**](#openhands.sdk.llm.LLM.disable_vision) (<code>[bool](#bool) | None</code>) –
- [**drop_params**](#openhands.sdk.llm.LLM.drop_params) (<code>[bool](#bool)</code>) –
- [**input_cost_per_token**](#openhands.sdk.llm.LLM.input_cost_per_token) (<code>[float](#float) | None</code>) –
- [**log_completions**](#openhands.sdk.llm.LLM.log_completions) (<code>[bool](#bool)</code>) –
- [**log_completions_folder**](#openhands.sdk.llm.LLM.log_completions_folder) (<code>[str](#str)</code>) –
- [**max_input_tokens**](#openhands.sdk.llm.LLM.max_input_tokens) (<code>[int](#int) | None</code>) –
- [**max_message_chars**](#openhands.sdk.llm.LLM.max_message_chars) (<code>[int](#int)</code>) –
- [**max_output_tokens**](#openhands.sdk.llm.LLM.max_output_tokens) (<code>[int](#int) | None</code>) –
- [**metrics**](#openhands.sdk.llm.LLM.metrics) (<code>[Metrics](#openhands.sdk.llm.utils.metrics.Metrics) | None</code>) –
- [**model**](#openhands.sdk.llm.LLM.model) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.llm.LLM.model_config) –
- [**model_info**](#openhands.sdk.llm.LLM.model_info) (<code>[dict](#dict) | None</code>) – Returns the model info dictionary.
- [**modify_params**](#openhands.sdk.llm.LLM.modify_params) (<code>[bool](#bool)</code>) –
- [**native_tool_calling**](#openhands.sdk.llm.LLM.native_tool_calling) (<code>[bool](#bool) | None</code>) –
- [**num_retries**](#openhands.sdk.llm.LLM.num_retries) (<code>[int](#int)</code>) –
- [**ollama_base_url**](#openhands.sdk.llm.LLM.ollama_base_url) (<code>[str](#str) | None</code>) –
- [**openrouter_app_name**](#openhands.sdk.llm.LLM.openrouter_app_name) (<code>[str](#str)</code>) –
- [**openrouter_site_url**](#openhands.sdk.llm.LLM.openrouter_site_url) (<code>[str](#str)</code>) –
- [**output_cost_per_token**](#openhands.sdk.llm.LLM.output_cost_per_token) (<code>[float](#float) | None</code>) –
- [**reasoning_effort**](#openhands.sdk.llm.LLM.reasoning_effort) (<code>[Literal](#typing.Literal)['low', 'medium', 'high', 'none'] | None</code>) –
- [**retry_listener**](#openhands.sdk.llm.LLM.retry_listener) (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) –
- [**retry_max_wait**](#openhands.sdk.llm.LLM.retry_max_wait) (<code>[int](#int)</code>) –
- [**retry_min_wait**](#openhands.sdk.llm.LLM.retry_min_wait) (<code>[int](#int)</code>) –
- [**retry_multiplier**](#openhands.sdk.llm.LLM.retry_multiplier) (<code>[float](#float)</code>) –
- [**safety_settings**](#openhands.sdk.llm.LLM.safety_settings) (<code>[list](#list)\[[dict](#dict)\[[str](#str), [str](#str)\]\] | None</code>) –
- [**seed**](#openhands.sdk.llm.LLM.seed) (<code>[int](#int) | None</code>) –
- [**service_id**](#openhands.sdk.llm.LLM.service_id) (<code>[str](#str)</code>) –
- [**temperature**](#openhands.sdk.llm.LLM.temperature) (<code>[float](#float) | None</code>) –
- [**timeout**](#openhands.sdk.llm.LLM.timeout) (<code>[int](#int) | None</code>) –
- [**top_k**](#openhands.sdk.llm.LLM.top_k) (<code>[float](#float) | None</code>) –
- [**top_p**](#openhands.sdk.llm.LLM.top_p) (<code>[float](#float) | None</code>) –

##### `openhands.sdk.llm.LLM.OVERRIDE_ON_SERIALIZE`

```python
OVERRIDE_ON_SERIALIZE: tuple[str, ...] = ('api_key', 'aws_access_key_id', 'aws_secret_access_key')
```

##### `openhands.sdk.llm.LLM.api_key`

```python
api_key: SecretStr | None = Field(default=None, description='API key.')
```

##### `openhands.sdk.llm.LLM.api_version`

```python
api_version: str | None = Field(default=None, description='API version (e.g., Azure).')
```

##### `openhands.sdk.llm.LLM.aws_access_key_id`

```python
aws_access_key_id: SecretStr | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.aws_region_name`

```python
aws_region_name: str | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.aws_secret_access_key`

```python
aws_secret_access_key: SecretStr | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.base_url`

```python
base_url: str | None = Field(default=None, description='Custom base URL.')
```

##### `openhands.sdk.llm.LLM.caching_prompt`

```python
caching_prompt: bool = Field(default=True, description='Enable caching of prompts.')
```

##### `openhands.sdk.llm.LLM.completion`

```python
completion(messages, tools=None, return_metrics=False, **kwargs)
```

Single entry point for LLM completion.

Normalize → (maybe) mock tools → transport → postprocess.

##### `openhands.sdk.llm.LLM.custom_llm_provider`

```python
custom_llm_provider: str | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.custom_tokenizer`

```python
custom_tokenizer: str | None = Field(default=None, description='A custom tokenizer to use for token counting.')
```

##### `openhands.sdk.llm.LLM.deserialize`

```python
deserialize(data)
```

Deserialize LLM from dictionary.

##### `openhands.sdk.llm.LLM.disable_stop_word`

```python
disable_stop_word: bool | None = Field(default=False, description='Disable using of stop word.')
```

##### `openhands.sdk.llm.LLM.disable_vision`

```python
disable_vision: bool | None = Field(default=None, description='If model is vision capable, this option allows to disable image processing (useful for cost reduction).')
```

##### `openhands.sdk.llm.LLM.drop_params`

```python
drop_params: bool = Field(default=True)
```

##### `openhands.sdk.llm.LLM.format_messages_for_llm`

```python
format_messages_for_llm(messages)
```

Format Message objects for LLM consumption.

**Parameters:**

- **messages** (<code>[list](#list)\[[Message](#openhands.sdk.llm.message.Message)\]</code>) – List of Message objects to format.

**Returns:**

- <code>[list](#list)\[[dict](#dict)\]</code> – List of dictionaries formatted for LLM consumption.

##### `openhands.sdk.llm.LLM.get_token_count`

```python
get_token_count(messages)
```

Get token count for messages.

##### `openhands.sdk.llm.LLM.input_cost_per_token`

```python
input_cost_per_token: float | None = Field(default=None, description='The cost per input token. This will available in logs for user.')
```

##### `openhands.sdk.llm.LLM.is_caching_prompt_active`

```python
is_caching_prompt_active()
```

Check if prompt caching is supported and enabled for current model.

**Returns:**

- **boolean** (<code>[bool](#bool)</code>) – True if prompt caching is supported and enabled for the given
  model.

##### `openhands.sdk.llm.LLM.is_function_calling_active`

```python
is_function_calling_active()
```

Check whether function calling is supported and enabled for this LLM.

**Returns:**

- <code>[bool](#bool)</code> – True if function calling is active, False otherwise.

##### `openhands.sdk.llm.LLM.load_from_env`

```python
load_from_env(prefix='LLM_')
```

Load LLM from environment variables.

##### `openhands.sdk.llm.LLM.load_from_json`

```python
load_from_json(json_path)
```

Load LLM from JSON file.

##### `openhands.sdk.llm.LLM.load_from_toml`

```python
load_from_toml(toml_path)
```

Load LLM from TOML file.

##### `openhands.sdk.llm.LLM.log_completions`

```python
log_completions: bool = Field(default=False, description='Enable logging of completions.')
```

##### `openhands.sdk.llm.LLM.log_completions_folder`

```python
log_completions_folder: str = Field(default=(os.path.join(ENV_LOG_DIR, 'completions')), description='The folder to log LLM completions to. Required if log_completions is True.')
```

##### `openhands.sdk.llm.LLM.max_input_tokens`

```python
max_input_tokens: int | None = Field(default=None, description='The maximum number of input tokens. Note that this is currently unused, and the value at runtime is actually the total tokens in OpenAI (e.g. 128,000 tokens for GPT-4).')
```

##### `openhands.sdk.llm.LLM.max_message_chars`

```python
max_message_chars: int = Field(default=30000, description='Approx max chars in each event/content sent to the LLM.')
```

##### `openhands.sdk.llm.LLM.max_output_tokens`

```python
max_output_tokens: int | None = Field(default=None, description='The maximum number of output tokens. This is sent to the LLM.')
```

##### `openhands.sdk.llm.LLM.metrics`

```python
metrics: Metrics | None = Field(default=None, exclude=True)
```

##### `openhands.sdk.llm.LLM.model`

```python
model: str = Field(default='claude-sonnet-4-20250514', description='Model name.')
```

##### `openhands.sdk.llm.LLM.model_config`

```python
model_config = ConfigDict(extra='forbid', arbitrary_types_allowed=True)
```

##### `openhands.sdk.llm.LLM.model_info`

```python
model_info: dict | None
```

Returns the model info dictionary.

##### `openhands.sdk.llm.LLM.modify_params`

```python
modify_params: bool = Field(default=True, description='Modify params allows litellm to do transformations like adding a default message, when a message is empty.')
```

##### `openhands.sdk.llm.LLM.native_tool_calling`

```python
native_tool_calling: bool | None = Field(default=None, description='Whether to use native tool calling if supported by the model. Can be True, False, or not set.')
```

##### `openhands.sdk.llm.LLM.num_retries`

```python
num_retries: int = Field(default=5)
```

##### `openhands.sdk.llm.LLM.ollama_base_url`

```python
ollama_base_url: str | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.openrouter_app_name`

```python
openrouter_app_name: str = Field(default='OpenHands')
```

##### `openhands.sdk.llm.LLM.openrouter_site_url`

```python
openrouter_site_url: str = Field(default='https://docs.all-hands.dev/')
```

##### `openhands.sdk.llm.LLM.output_cost_per_token`

```python
output_cost_per_token: float | None = Field(default=None, description='The cost per output token. This will available in logs for user.')
```

##### `openhands.sdk.llm.LLM.reasoning_effort`

```python
reasoning_effort: Literal['low', 'medium', 'high', 'none'] | None = Field(default=None, description="The effort to put into reasoning. This is a string that can be one of 'low', 'medium', 'high', or 'none'. Can apply to all reasoning models.")
```

##### `openhands.sdk.llm.LLM.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Resolve differences between a deserialized LLM and the current instance.

This is due to fields like api_key being serialized to "\*\*\*\*" in dumps,
and we want to ensure that when loading from a file, we still use the
runtime-provided api_key in the self instance.

Return a new LLM instance equivalent to `persisted` but with
explicitly whitelisted fields (e.g. api_key) taken from `self`.

##### `openhands.sdk.llm.LLM.retry_decorator`

```python
retry_decorator(*, num_retries, retry_exceptions, retry_min_wait, retry_max_wait, retry_multiplier, retry_listener=None)
```

Create a retry decorator with exponential backoff.

##### `openhands.sdk.llm.LLM.retry_listener`

```python
retry_listener: Callable[[int, int], None] | None = Field(default=None, exclude=True)
```

##### `openhands.sdk.llm.LLM.retry_max_wait`

```python
retry_max_wait: int = Field(default=64)
```

##### `openhands.sdk.llm.LLM.retry_min_wait`

```python
retry_min_wait: int = Field(default=8)
```

##### `openhands.sdk.llm.LLM.retry_multiplier`

```python
retry_multiplier: float = Field(default=8)
```

##### `openhands.sdk.llm.LLM.safety_settings`

```python
safety_settings: list[dict[str, str]] | None = Field(default=None, description='Safety settings for models that support them (like Mistral AI and Gemini)')
```

##### `openhands.sdk.llm.LLM.seed`

```python
seed: int | None = Field(default=None, description='The seed to use for random number generation.')
```

##### `openhands.sdk.llm.LLM.serialize`

```python
serialize()
```

Serialize LLM to dictionary.

##### `openhands.sdk.llm.LLM.service_id`

```python
service_id: str = Field(default='default', exclude=True)
```

##### `openhands.sdk.llm.LLM.temperature`

```python
temperature: float | None = Field(default=0.0)
```

##### `openhands.sdk.llm.LLM.timeout`

```python
timeout: int | None = Field(default=None, description='HTTP timeout (s).')
```

##### `openhands.sdk.llm.LLM.top_k`

```python
top_k: float | None = Field(default=None)
```

##### `openhands.sdk.llm.LLM.top_p`

```python
top_p: float | None = Field(default=1.0)
```

##### `openhands.sdk.llm.LLM.vision_is_active`

```python
vision_is_active()
```

Check if vision capabilities are active.

#### `openhands.sdk.llm.LLMRegistry`

```python
LLMRegistry(retry_listener=None)
```

A minimal LLM registry for managing LLM instances by service ID.

This registry provides a simple way to manage multiple LLM instances,
avoiding the need to recreate LLMs with the same configuration.

**Functions:**

- [**add**](#openhands.sdk.llm.LLMRegistry.add) – Add an LLM instance to the registry.
- [**get**](#openhands.sdk.llm.LLMRegistry.get) – Get an LLM instance from the registry.
- [**list_services**](#openhands.sdk.llm.LLMRegistry.list_services) – List all registered service IDs.
- [**notify**](#openhands.sdk.llm.LLMRegistry.notify) – Notify subscribers of registry events.
- [**subscribe**](#openhands.sdk.llm.LLMRegistry.subscribe) – Subscribe to registry events.

**Attributes:**

- [**registry_id**](#openhands.sdk.llm.LLMRegistry.registry_id) –
- [**retry_listener**](#openhands.sdk.llm.LLMRegistry.retry_listener) –
- [**service_to_llm**](#openhands.sdk.llm.LLMRegistry.service_to_llm) (<code>[dict](#dict)\[[str](#str), [LLM](#openhands.sdk.llm.llm.LLM)\]</code>) –
- [**subscriber**](#openhands.sdk.llm.LLMRegistry.subscriber) (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\] | None</code>) –

Initialize the LLM registry.

**Parameters:**

- **retry_listener** (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) – Optional callback for retry events.

##### `openhands.sdk.llm.LLMRegistry.add`

```python
add(service_id, llm)
```

Add an LLM instance to the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.
- **llm** (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) – The LLM instance to register.

**Raises:**

- <code>[ValueError](#ValueError)</code> – If service_id already exists in the registry.

##### `openhands.sdk.llm.LLMRegistry.get`

```python
get(service_id)
```

Get an LLM instance from the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.

**Returns:**

- <code>[LLM](#openhands.sdk.llm.llm.LLM)</code> – The LLM instance.

**Raises:**

- <code>[KeyError](#KeyError)</code> – If service_id is not found in the registry.

##### `openhands.sdk.llm.LLMRegistry.list_services`

```python
list_services()
```

List all registered service IDs.

**Returns:**

- <code>[list](#list)\[[str](#str)\]</code> – List of service IDs currently in the registry.

##### `openhands.sdk.llm.LLMRegistry.notify`

```python
notify(event)
```

Notify subscribers of registry events.

**Parameters:**

- **event** (<code>[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)</code>) – The registry event to notify about.

##### `openhands.sdk.llm.LLMRegistry.registry_id`

```python
registry_id = str(uuid4())
```

##### `openhands.sdk.llm.LLMRegistry.retry_listener`

```python
retry_listener = retry_listener
```

##### `openhands.sdk.llm.LLMRegistry.service_to_llm`

```python
service_to_llm: dict[str, LLM] = {}
```

##### `openhands.sdk.llm.LLMRegistry.subscribe`

```python
subscribe(callback)
```

Subscribe to registry events.

**Parameters:**

- **callback** (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\]</code>) – Function to call when LLMs are created or updated.

##### `openhands.sdk.llm.LLMRegistry.subscriber`

```python
subscriber: Callable[[RegistryEvent], None] | None = None
```

#### `openhands.sdk.llm.Message`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Message for LLM communication.

**Functions:**

- [**from_litellm_message**](#openhands.sdk.llm.Message.from_litellm_message) – Convert a LiteLLMMessage to our Message class.
- [**to_llm_dict**](#openhands.sdk.llm.Message.to_llm_dict) – Serialize message for LLM API consumption.

**Attributes:**

- [**cache_enabled**](#openhands.sdk.llm.Message.cache_enabled) (<code>[bool](#bool)</code>) –
- [**contains_image**](#openhands.sdk.llm.Message.contains_image) (<code>[bool](#bool)</code>) – Check if message contains image content.
- [**content**](#openhands.sdk.llm.Message.content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) –
- [**force_string_serializer**](#openhands.sdk.llm.Message.force_string_serializer) (<code>[bool](#bool)</code>) –
- [**function_calling_enabled**](#openhands.sdk.llm.Message.function_calling_enabled) (<code>[bool](#bool)</code>) –
- [**name**](#openhands.sdk.llm.Message.name) (<code>[str](#str) | None</code>) –
- [**reasoning_content**](#openhands.sdk.llm.Message.reasoning_content) (<code>[str](#str) | None</code>) –
- [**role**](#openhands.sdk.llm.Message.role) (<code>[Literal](#typing.Literal)['user', 'system', 'assistant', 'tool']</code>) –
- [**tool_call_id**](#openhands.sdk.llm.Message.tool_call_id) (<code>[str](#str) | None</code>) –
- [**tool_calls**](#openhands.sdk.llm.Message.tool_calls) (<code>[list](#list)\[[ChatCompletionMessageToolCall](#litellm.ChatCompletionMessageToolCall)\] | None</code>) –
- [**vision_enabled**](#openhands.sdk.llm.Message.vision_enabled) (<code>[bool](#bool)</code>) –

##### `openhands.sdk.llm.Message.cache_enabled`

```python
cache_enabled: bool = False
```

##### `openhands.sdk.llm.Message.contains_image`

```python
contains_image: bool
```

Check if message contains image content.

##### `openhands.sdk.llm.Message.content`

```python
content: list[TextContent | ImageContent] = Field(default_factory=list)
```

##### `openhands.sdk.llm.Message.force_string_serializer`

```python
force_string_serializer: bool = False
```

##### `openhands.sdk.llm.Message.from_litellm_message`

```python
from_litellm_message(message)
```

Convert a LiteLLMMessage to our Message class.

Provider-agnostic mapping for reasoning:

- Prefer `message.reasoning_content` if present (LiteLLM normalized field)

##### `openhands.sdk.llm.Message.function_calling_enabled`

```python
function_calling_enabled: bool = False
```

##### `openhands.sdk.llm.Message.name`

```python
name: str | None = None
```

##### `openhands.sdk.llm.Message.reasoning_content`

```python
reasoning_content: str | None = Field(default=None, description='Intermediate reasoning/thinking content from reasoning models')
```

##### `openhands.sdk.llm.Message.role`

```python
role: Literal['user', 'system', 'assistant', 'tool']
```

##### `openhands.sdk.llm.Message.to_llm_dict`

```python
to_llm_dict()
```

Serialize message for LLM API consumption.

This method chooses the appropriate serialization format based on the message
configuration and provider capabilities:

- String format: for providers that don't support list of content items
- List format: for providers with vision/prompt caching/tool calls support

##### `openhands.sdk.llm.Message.tool_call_id`

```python
tool_call_id: str | None = None
```

##### `openhands.sdk.llm.Message.tool_calls`

```python
tool_calls: list[ChatCompletionMessageToolCall] | None = None
```

##### `openhands.sdk.llm.Message.vision_enabled`

```python
vision_enabled: bool = False
```

#### `openhands.sdk.llm.RegistryEvent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Event representing LLM registration or deregistration.

**Attributes:**

- [**llm**](#openhands.sdk.llm.RegistryEvent.llm) (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.llm.RegistryEvent.model_config) –
- [**service_id**](#openhands.sdk.llm.RegistryEvent.service_id) (<code>[str](#str)</code>) –

##### `openhands.sdk.llm.RegistryEvent.llm`

```python
llm: LLM
```

##### `openhands.sdk.llm.RegistryEvent.model_config`

```python
model_config = ConfigDict(arbitrary_types_allowed=True)
```

##### `openhands.sdk.llm.RegistryEvent.service_id`

```python
service_id: str
```

#### `openhands.sdk.llm.TextContent`

Bases: <code>[TextContent](#mcp.types.TextContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Text content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.llm.TextContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.llm.TextContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**model_config**](#openhands.sdk.llm.TextContent.model_config) –
- [**text**](#openhands.sdk.llm.TextContent.text) (<code>[str](#str)</code>) –
- [**type**](#openhands.sdk.llm.TextContent.type) (<code>[Literal](#typing.Literal)['text']</code>) –

##### `openhands.sdk.llm.TextContent.cache_prompt`

```python
cache_prompt: bool = False
```

##### `openhands.sdk.llm.TextContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

##### `openhands.sdk.llm.TextContent.text`

```python
text: str
```

##### `openhands.sdk.llm.TextContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

##### `openhands.sdk.llm.TextContent.type`

```python
type: Literal['text'] = 'text'
```

#### `openhands.sdk.llm.content_to_str`

```python
content_to_str(contents)
```

Convert a list of TextContent and ImageContent to a list of strings.

This is primarily used for display purposes.

#### `openhands.sdk.llm.exceptions`

LLM-related exception classes.

**Classes:**

- [**FunctionCallConversionError**](#openhands.sdk.llm.exceptions.FunctionCallConversionError) – Exception raised when FunctionCallingConverter failed to convert.
- [**FunctionCallNotExistsError**](#openhands.sdk.llm.exceptions.FunctionCallNotExistsError) – Exception raised when an LLM call a tool that is not registered.
- [**FunctionCallValidationError**](#openhands.sdk.llm.exceptions.FunctionCallValidationError) – Exception raised when FunctionCallingConverter failed to validate.
- [**LLMContextWindowExceedError**](#openhands.sdk.llm.exceptions.LLMContextWindowExceedError) – Exception raised when LLM context window limit is exceeded.
- [**LLMError**](#openhands.sdk.llm.exceptions.LLMError) – Base class for all LLM-related exceptions.
- [**LLMMalformedActionError**](#openhands.sdk.llm.exceptions.LLMMalformedActionError) – Exception raised when the LLM response is malformed or does not conform to the expected format.
- [**LLMNoActionError**](#openhands.sdk.llm.exceptions.LLMNoActionError) – Exception raised when the LLM response does not include an action.
- [**LLMNoResponseError**](#openhands.sdk.llm.exceptions.LLMNoResponseError) – Exception raised when the LLM does not return a response.
- [**LLMResponseError**](#openhands.sdk.llm.exceptions.LLMResponseError) – Exception raised when the LLM response does not include an action or the action is not of the expected type.
- [**OperationCancelled**](#openhands.sdk.llm.exceptions.OperationCancelled) – Exception raised when an operation is cancelled (e.g. by a keyboard interrupt).
- [**UserCancelledError**](#openhands.sdk.llm.exceptions.UserCancelledError) – Exception raised when user cancels a request.

##### `openhands.sdk.llm.exceptions.FunctionCallConversionError`

```python
FunctionCallConversionError(message)
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when FunctionCallingConverter failed to convert.

Failed to convert a non-function call message to a function call message.

This typically happens when there's a malformed message (e.g., missing
\<function=...> tags). But not due to LLM output.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.FunctionCallConversionError.message) –

Initialize FunctionCallConversionError with a message.

###### `openhands.sdk.llm.exceptions.FunctionCallConversionError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.FunctionCallNotExistsError`

```python
FunctionCallNotExistsError(message)
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when an LLM call a tool that is not registered.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.FunctionCallNotExistsError.message) –

Initialize FunctionCallNotExistsError with a message.

###### `openhands.sdk.llm.exceptions.FunctionCallNotExistsError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.FunctionCallValidationError`

```python
FunctionCallValidationError(message)
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when FunctionCallingConverter failed to validate.

Failed to validate a function call message.

This typically happens when the LLM outputs unrecognized function call /
parameter names / values.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.FunctionCallValidationError.message) –

Initialize FunctionCallValidationError with a message.

###### `openhands.sdk.llm.exceptions.FunctionCallValidationError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMContextWindowExceedError`

```python
LLMContextWindowExceedError(message='Conversation history longer than LLM context window limit. Consider turning on enable_history_truncation config to avoid this error')
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when LLM context window limit is exceeded.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMContextWindowExceedError.message) –

Initialize LLMContextWindowExceedError with a message.

###### `openhands.sdk.llm.exceptions.LLMContextWindowExceedError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMError`

```python
LLMError(message)
```

Bases: <code>[Exception](#Exception)</code>

Base class for all LLM-related exceptions.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMError.message) –

Initialize LLMError with a message.

###### `openhands.sdk.llm.exceptions.LLMError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMMalformedActionError`

```python
LLMMalformedActionError(message='Malformed response')
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when the LLM response is malformed or does not conform to the expected format.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMMalformedActionError.message) –

Initialize LLMMalformedActionError with a message.

###### `openhands.sdk.llm.exceptions.LLMMalformedActionError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMNoActionError`

```python
LLMNoActionError(message='Agent must return an action')
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when the LLM response does not include an action.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMNoActionError.message) –

Initialize LLMNoActionError with a message.

###### `openhands.sdk.llm.exceptions.LLMNoActionError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMNoResponseError`

```python
LLMNoResponseError(message='LLM did not return a response. This is only seen in Gemini models so far.')
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when the LLM does not return a response.

Typically seen in Gemini models.

This exception should be retried
Typically, after retry with a non-zero temperature, the LLM will return a response

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMNoResponseError.message) –

Initialize LLMNoResponseError with a message.

###### `openhands.sdk.llm.exceptions.LLMNoResponseError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.LLMResponseError`

```python
LLMResponseError(message='Failed to retrieve action from LLM response')
```

Bases: <code>[LLMError](#openhands.sdk.llm.exceptions.LLMError)</code>

Exception raised when the LLM response does not include an action or the action is not of the expected type.

**Attributes:**

- [**message**](#openhands.sdk.llm.exceptions.LLMResponseError.message) –

Initialize LLMResponseError with a message.

###### `openhands.sdk.llm.exceptions.LLMResponseError.message`

```python
message = message
```

##### `openhands.sdk.llm.exceptions.OperationCancelled`

```python
OperationCancelled(message='Operation was cancelled')
```

Bases: <code>[Exception](#Exception)</code>

Exception raised when an operation is cancelled (e.g. by a keyboard interrupt).

Initialize OperationCancelled with a message.

##### `openhands.sdk.llm.exceptions.UserCancelledError`

```python
UserCancelledError(message='User cancelled the request')
```

Bases: <code>[Exception](#Exception)</code>

Exception raised when user cancels a request.

Initialize UserCancelledError with a message.

#### `openhands.sdk.llm.get_llm_metadata`

```python
get_llm_metadata(model_name, agent_name, session_id=None, user_id=None)
```

Get metadata for LLM tracing and telemetry.

#### `openhands.sdk.llm.llm`

LLM interface and implementation using LiteLLM.

**Classes:**

- [**LLM**](#openhands.sdk.llm.llm.LLM) – Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.

##### `openhands.sdk.llm.llm.LLM`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>, <code>[RetryMixin](#openhands.sdk.llm.llm.RetryMixin)</code>, <code>[NonNativeToolCallingMixin](#openhands.sdk.llm.mixins.non_native_fc.NonNativeToolCallingMixin)</code>

Refactored LLM: simple `completion()`, centralized Telemetry, tiny helpers.

**Functions:**

- [**completion**](#openhands.sdk.llm.llm.LLM.completion) – Single entry point for LLM completion.
- [**deserialize**](#openhands.sdk.llm.llm.LLM.deserialize) – Deserialize LLM from dictionary.
- [**format_messages_for_llm**](#openhands.sdk.llm.llm.LLM.format_messages_for_llm) – Format Message objects for LLM consumption.
- [**get_token_count**](#openhands.sdk.llm.llm.LLM.get_token_count) – Get token count for messages.
- [**is_caching_prompt_active**](#openhands.sdk.llm.llm.LLM.is_caching_prompt_active) – Check if prompt caching is supported and enabled for current model.
- [**is_function_calling_active**](#openhands.sdk.llm.llm.LLM.is_function_calling_active) – Check whether function calling is supported and enabled for this LLM.
- [**load_from_env**](#openhands.sdk.llm.llm.LLM.load_from_env) – Load LLM from environment variables.
- [**load_from_json**](#openhands.sdk.llm.llm.LLM.load_from_json) – Load LLM from JSON file.
- [**load_from_toml**](#openhands.sdk.llm.llm.LLM.load_from_toml) – Load LLM from TOML file.
- [**resolve_diff_from_deserialized**](#openhands.sdk.llm.llm.LLM.resolve_diff_from_deserialized) – Resolve differences between a deserialized LLM and the current instance.
- [**retry_decorator**](#openhands.sdk.llm.llm.LLM.retry_decorator) – Create a retry decorator with exponential backoff.
- [**serialize**](#openhands.sdk.llm.llm.LLM.serialize) – Serialize LLM to dictionary.
- [**vision_is_active**](#openhands.sdk.llm.llm.LLM.vision_is_active) – Check if vision capabilities are active.

**Attributes:**

- [**OVERRIDE_ON_SERIALIZE**](#openhands.sdk.llm.llm.LLM.OVERRIDE_ON_SERIALIZE) (<code>[tuple](#tuple)\[[str](#str), ...\]</code>) –
- [**api_key**](#openhands.sdk.llm.llm.LLM.api_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**api_version**](#openhands.sdk.llm.llm.LLM.api_version) (<code>[str](#str) | None</code>) –
- [**aws_access_key_id**](#openhands.sdk.llm.llm.LLM.aws_access_key_id) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**aws_region_name**](#openhands.sdk.llm.llm.LLM.aws_region_name) (<code>[str](#str) | None</code>) –
- [**aws_secret_access_key**](#openhands.sdk.llm.llm.LLM.aws_secret_access_key) (<code>[SecretStr](#pydantic.SecretStr) | None</code>) –
- [**base_url**](#openhands.sdk.llm.llm.LLM.base_url) (<code>[str](#str) | None</code>) –
- [**caching_prompt**](#openhands.sdk.llm.llm.LLM.caching_prompt) (<code>[bool](#bool)</code>) –
- [**custom_llm_provider**](#openhands.sdk.llm.llm.LLM.custom_llm_provider) (<code>[str](#str) | None</code>) –
- [**custom_tokenizer**](#openhands.sdk.llm.llm.LLM.custom_tokenizer) (<code>[str](#str) | None</code>) –
- [**disable_stop_word**](#openhands.sdk.llm.llm.LLM.disable_stop_word) (<code>[bool](#bool) | None</code>) –
- [**disable_vision**](#openhands.sdk.llm.llm.LLM.disable_vision) (<code>[bool](#bool) | None</code>) –
- [**drop_params**](#openhands.sdk.llm.llm.LLM.drop_params) (<code>[bool](#bool)</code>) –
- [**input_cost_per_token**](#openhands.sdk.llm.llm.LLM.input_cost_per_token) (<code>[float](#float) | None</code>) –
- [**log_completions**](#openhands.sdk.llm.llm.LLM.log_completions) (<code>[bool](#bool)</code>) –
- [**log_completions_folder**](#openhands.sdk.llm.llm.LLM.log_completions_folder) (<code>[str](#str)</code>) –
- [**max_input_tokens**](#openhands.sdk.llm.llm.LLM.max_input_tokens) (<code>[int](#int) | None</code>) –
- [**max_message_chars**](#openhands.sdk.llm.llm.LLM.max_message_chars) (<code>[int](#int)</code>) –
- [**max_output_tokens**](#openhands.sdk.llm.llm.LLM.max_output_tokens) (<code>[int](#int) | None</code>) –
- [**metrics**](#openhands.sdk.llm.llm.LLM.metrics) (<code>[Metrics](#openhands.sdk.llm.utils.metrics.Metrics) | None</code>) –
- [**model**](#openhands.sdk.llm.llm.LLM.model) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.llm.llm.LLM.model_config) –
- [**model_info**](#openhands.sdk.llm.llm.LLM.model_info) (<code>[dict](#dict) | None</code>) – Returns the model info dictionary.
- [**modify_params**](#openhands.sdk.llm.llm.LLM.modify_params) (<code>[bool](#bool)</code>) –
- [**native_tool_calling**](#openhands.sdk.llm.llm.LLM.native_tool_calling) (<code>[bool](#bool) | None</code>) –
- [**num_retries**](#openhands.sdk.llm.llm.LLM.num_retries) (<code>[int](#int)</code>) –
- [**ollama_base_url**](#openhands.sdk.llm.llm.LLM.ollama_base_url) (<code>[str](#str) | None</code>) –
- [**openrouter_app_name**](#openhands.sdk.llm.llm.LLM.openrouter_app_name) (<code>[str](#str)</code>) –
- [**openrouter_site_url**](#openhands.sdk.llm.llm.LLM.openrouter_site_url) (<code>[str](#str)</code>) –
- [**output_cost_per_token**](#openhands.sdk.llm.llm.LLM.output_cost_per_token) (<code>[float](#float) | None</code>) –
- [**reasoning_effort**](#openhands.sdk.llm.llm.LLM.reasoning_effort) (<code>[Literal](#typing.Literal)['low', 'medium', 'high', 'none'] | None</code>) –
- [**retry_listener**](#openhands.sdk.llm.llm.LLM.retry_listener) (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) –
- [**retry_max_wait**](#openhands.sdk.llm.llm.LLM.retry_max_wait) (<code>[int](#int)</code>) –
- [**retry_min_wait**](#openhands.sdk.llm.llm.LLM.retry_min_wait) (<code>[int](#int)</code>) –
- [**retry_multiplier**](#openhands.sdk.llm.llm.LLM.retry_multiplier) (<code>[float](#float)</code>) –
- [**safety_settings**](#openhands.sdk.llm.llm.LLM.safety_settings) (<code>[list](#list)\[[dict](#dict)\[[str](#str), [str](#str)\]\] | None</code>) –
- [**seed**](#openhands.sdk.llm.llm.LLM.seed) (<code>[int](#int) | None</code>) –
- [**service_id**](#openhands.sdk.llm.llm.LLM.service_id) (<code>[str](#str)</code>) –
- [**temperature**](#openhands.sdk.llm.llm.LLM.temperature) (<code>[float](#float) | None</code>) –
- [**timeout**](#openhands.sdk.llm.llm.LLM.timeout) (<code>[int](#int) | None</code>) –
- [**top_k**](#openhands.sdk.llm.llm.LLM.top_k) (<code>[float](#float) | None</code>) –
- [**top_p**](#openhands.sdk.llm.llm.LLM.top_p) (<code>[float](#float) | None</code>) –

###### `openhands.sdk.llm.llm.LLM.OVERRIDE_ON_SERIALIZE`

```python
OVERRIDE_ON_SERIALIZE: tuple[str, ...] = ('api_key', 'aws_access_key_id', 'aws_secret_access_key')
```

###### `openhands.sdk.llm.llm.LLM.api_key`

```python
api_key: SecretStr | None = Field(default=None, description='API key.')
```

###### `openhands.sdk.llm.llm.LLM.api_version`

```python
api_version: str | None = Field(default=None, description='API version (e.g., Azure).')
```

###### `openhands.sdk.llm.llm.LLM.aws_access_key_id`

```python
aws_access_key_id: SecretStr | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.aws_region_name`

```python
aws_region_name: str | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.aws_secret_access_key`

```python
aws_secret_access_key: SecretStr | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.base_url`

```python
base_url: str | None = Field(default=None, description='Custom base URL.')
```

###### `openhands.sdk.llm.llm.LLM.caching_prompt`

```python
caching_prompt: bool = Field(default=True, description='Enable caching of prompts.')
```

###### `openhands.sdk.llm.llm.LLM.completion`

```python
completion(messages, tools=None, return_metrics=False, **kwargs)
```

Single entry point for LLM completion.

Normalize → (maybe) mock tools → transport → postprocess.

###### `openhands.sdk.llm.llm.LLM.custom_llm_provider`

```python
custom_llm_provider: str | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.custom_tokenizer`

```python
custom_tokenizer: str | None = Field(default=None, description='A custom tokenizer to use for token counting.')
```

###### `openhands.sdk.llm.llm.LLM.deserialize`

```python
deserialize(data)
```

Deserialize LLM from dictionary.

###### `openhands.sdk.llm.llm.LLM.disable_stop_word`

```python
disable_stop_word: bool | None = Field(default=False, description='Disable using of stop word.')
```

###### `openhands.sdk.llm.llm.LLM.disable_vision`

```python
disable_vision: bool | None = Field(default=None, description='If model is vision capable, this option allows to disable image processing (useful for cost reduction).')
```

###### `openhands.sdk.llm.llm.LLM.drop_params`

```python
drop_params: bool = Field(default=True)
```

###### `openhands.sdk.llm.llm.LLM.format_messages_for_llm`

```python
format_messages_for_llm(messages)
```

Format Message objects for LLM consumption.

**Parameters:**

- **messages** (<code>[list](#list)\[[Message](#openhands.sdk.llm.message.Message)\]</code>) – List of Message objects to format.

**Returns:**

- <code>[list](#list)\[[dict](#dict)\]</code> – List of dictionaries formatted for LLM consumption.

###### `openhands.sdk.llm.llm.LLM.get_token_count`

```python
get_token_count(messages)
```

Get token count for messages.

###### `openhands.sdk.llm.llm.LLM.input_cost_per_token`

```python
input_cost_per_token: float | None = Field(default=None, description='The cost per input token. This will available in logs for user.')
```

###### `openhands.sdk.llm.llm.LLM.is_caching_prompt_active`

```python
is_caching_prompt_active()
```

Check if prompt caching is supported and enabled for current model.

**Returns:**

- **boolean** (<code>[bool](#bool)</code>) – True if prompt caching is supported and enabled for the given
  model.

###### `openhands.sdk.llm.llm.LLM.is_function_calling_active`

```python
is_function_calling_active()
```

Check whether function calling is supported and enabled for this LLM.

**Returns:**

- <code>[bool](#bool)</code> – True if function calling is active, False otherwise.

###### `openhands.sdk.llm.llm.LLM.load_from_env`

```python
load_from_env(prefix='LLM_')
```

Load LLM from environment variables.

###### `openhands.sdk.llm.llm.LLM.load_from_json`

```python
load_from_json(json_path)
```

Load LLM from JSON file.

###### `openhands.sdk.llm.llm.LLM.load_from_toml`

```python
load_from_toml(toml_path)
```

Load LLM from TOML file.

###### `openhands.sdk.llm.llm.LLM.log_completions`

```python
log_completions: bool = Field(default=False, description='Enable logging of completions.')
```

###### `openhands.sdk.llm.llm.LLM.log_completions_folder`

```python
log_completions_folder: str = Field(default=(os.path.join(ENV_LOG_DIR, 'completions')), description='The folder to log LLM completions to. Required if log_completions is True.')
```

###### `openhands.sdk.llm.llm.LLM.max_input_tokens`

```python
max_input_tokens: int | None = Field(default=None, description='The maximum number of input tokens. Note that this is currently unused, and the value at runtime is actually the total tokens in OpenAI (e.g. 128,000 tokens for GPT-4).')
```

###### `openhands.sdk.llm.llm.LLM.max_message_chars`

```python
max_message_chars: int = Field(default=30000, description='Approx max chars in each event/content sent to the LLM.')
```

###### `openhands.sdk.llm.llm.LLM.max_output_tokens`

```python
max_output_tokens: int | None = Field(default=None, description='The maximum number of output tokens. This is sent to the LLM.')
```

###### `openhands.sdk.llm.llm.LLM.metrics`

```python
metrics: Metrics | None = Field(default=None, exclude=True)
```

###### `openhands.sdk.llm.llm.LLM.model`

```python
model: str = Field(default='claude-sonnet-4-20250514', description='Model name.')
```

###### `openhands.sdk.llm.llm.LLM.model_config`

```python
model_config = ConfigDict(extra='forbid', arbitrary_types_allowed=True)
```

###### `openhands.sdk.llm.llm.LLM.model_info`

```python
model_info: dict | None
```

Returns the model info dictionary.

###### `openhands.sdk.llm.llm.LLM.modify_params`

```python
modify_params: bool = Field(default=True, description='Modify params allows litellm to do transformations like adding a default message, when a message is empty.')
```

###### `openhands.sdk.llm.llm.LLM.native_tool_calling`

```python
native_tool_calling: bool | None = Field(default=None, description='Whether to use native tool calling if supported by the model. Can be True, False, or not set.')
```

###### `openhands.sdk.llm.llm.LLM.num_retries`

```python
num_retries: int = Field(default=5)
```

###### `openhands.sdk.llm.llm.LLM.ollama_base_url`

```python
ollama_base_url: str | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.openrouter_app_name`

```python
openrouter_app_name: str = Field(default='OpenHands')
```

###### `openhands.sdk.llm.llm.LLM.openrouter_site_url`

```python
openrouter_site_url: str = Field(default='https://docs.all-hands.dev/')
```

###### `openhands.sdk.llm.llm.LLM.output_cost_per_token`

```python
output_cost_per_token: float | None = Field(default=None, description='The cost per output token. This will available in logs for user.')
```

###### `openhands.sdk.llm.llm.LLM.reasoning_effort`

```python
reasoning_effort: Literal['low', 'medium', 'high', 'none'] | None = Field(default=None, description="The effort to put into reasoning. This is a string that can be one of 'low', 'medium', 'high', or 'none'. Can apply to all reasoning models.")
```

###### `openhands.sdk.llm.llm.LLM.resolve_diff_from_deserialized`

```python
resolve_diff_from_deserialized(persisted)
```

Resolve differences between a deserialized LLM and the current instance.

This is due to fields like api_key being serialized to "\*\*\*\*" in dumps,
and we want to ensure that when loading from a file, we still use the
runtime-provided api_key in the self instance.

Return a new LLM instance equivalent to `persisted` but with
explicitly whitelisted fields (e.g. api_key) taken from `self`.

###### `openhands.sdk.llm.llm.LLM.retry_decorator`

```python
retry_decorator(*, num_retries, retry_exceptions, retry_min_wait, retry_max_wait, retry_multiplier, retry_listener=None)
```

Create a retry decorator with exponential backoff.

###### `openhands.sdk.llm.llm.LLM.retry_listener`

```python
retry_listener: Callable[[int, int], None] | None = Field(default=None, exclude=True)
```

###### `openhands.sdk.llm.llm.LLM.retry_max_wait`

```python
retry_max_wait: int = Field(default=64)
```

###### `openhands.sdk.llm.llm.LLM.retry_min_wait`

```python
retry_min_wait: int = Field(default=8)
```

###### `openhands.sdk.llm.llm.LLM.retry_multiplier`

```python
retry_multiplier: float = Field(default=8)
```

###### `openhands.sdk.llm.llm.LLM.safety_settings`

```python
safety_settings: list[dict[str, str]] | None = Field(default=None, description='Safety settings for models that support them (like Mistral AI and Gemini)')
```

###### `openhands.sdk.llm.llm.LLM.seed`

```python
seed: int | None = Field(default=None, description='The seed to use for random number generation.')
```

###### `openhands.sdk.llm.llm.LLM.serialize`

```python
serialize()
```

Serialize LLM to dictionary.

###### `openhands.sdk.llm.llm.LLM.service_id`

```python
service_id: str = Field(default='default', exclude=True)
```

###### `openhands.sdk.llm.llm.LLM.temperature`

```python
temperature: float | None = Field(default=0.0)
```

###### `openhands.sdk.llm.llm.LLM.timeout`

```python
timeout: int | None = Field(default=None, description='HTTP timeout (s).')
```

###### `openhands.sdk.llm.llm.LLM.top_k`

```python
top_k: float | None = Field(default=None)
```

###### `openhands.sdk.llm.llm.LLM.top_p`

```python
top_p: float | None = Field(default=1.0)
```

###### `openhands.sdk.llm.llm.LLM.vision_is_active`

```python
vision_is_active()
```

Check if vision capabilities are active.

#### `openhands.sdk.llm.llm_registry`

LLM registry for managing LLM instances.

**Classes:**

- [**LLMRegistry**](#openhands.sdk.llm.llm_registry.LLMRegistry) – A minimal LLM registry for managing LLM instances by service ID.
- [**RegistryEvent**](#openhands.sdk.llm.llm_registry.RegistryEvent) – Event representing LLM registration or deregistration.

**Attributes:**

- [**logger**](#openhands.sdk.llm.llm_registry.logger) –

##### `openhands.sdk.llm.llm_registry.LLMRegistry`

```python
LLMRegistry(retry_listener=None)
```

A minimal LLM registry for managing LLM instances by service ID.

This registry provides a simple way to manage multiple LLM instances,
avoiding the need to recreate LLMs with the same configuration.

**Functions:**

- [**add**](#openhands.sdk.llm.llm_registry.LLMRegistry.add) – Add an LLM instance to the registry.
- [**get**](#openhands.sdk.llm.llm_registry.LLMRegistry.get) – Get an LLM instance from the registry.
- [**list_services**](#openhands.sdk.llm.llm_registry.LLMRegistry.list_services) – List all registered service IDs.
- [**notify**](#openhands.sdk.llm.llm_registry.LLMRegistry.notify) – Notify subscribers of registry events.
- [**subscribe**](#openhands.sdk.llm.llm_registry.LLMRegistry.subscribe) – Subscribe to registry events.

**Attributes:**

- [**registry_id**](#openhands.sdk.llm.llm_registry.LLMRegistry.registry_id) –
- [**retry_listener**](#openhands.sdk.llm.llm_registry.LLMRegistry.retry_listener) –
- [**service_to_llm**](#openhands.sdk.llm.llm_registry.LLMRegistry.service_to_llm) (<code>[dict](#dict)\[[str](#str), [LLM](#openhands.sdk.llm.llm.LLM)\]</code>) –
- [**subscriber**](#openhands.sdk.llm.llm_registry.LLMRegistry.subscriber) (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\] | None</code>) –

Initialize the LLM registry.

**Parameters:**

- **retry_listener** (<code>[Callable](#typing.Callable)\[\[[int](#int), [int](#int)\], None\] | None</code>) – Optional callback for retry events.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.add`

```python
add(service_id, llm)
```

Add an LLM instance to the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.
- **llm** (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) – The LLM instance to register.

**Raises:**

- <code>[ValueError](#ValueError)</code> – If service_id already exists in the registry.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.get`

```python
get(service_id)
```

Get an LLM instance from the registry.

**Parameters:**

- **service_id** (<code>[str](#str)</code>) – Unique identifier for the LLM service.

**Returns:**

- <code>[LLM](#openhands.sdk.llm.llm.LLM)</code> – The LLM instance.

**Raises:**

- <code>[KeyError](#KeyError)</code> – If service_id is not found in the registry.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.list_services`

```python
list_services()
```

List all registered service IDs.

**Returns:**

- <code>[list](#list)\[[str](#str)\]</code> – List of service IDs currently in the registry.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.notify`

```python
notify(event)
```

Notify subscribers of registry events.

**Parameters:**

- **event** (<code>[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)</code>) – The registry event to notify about.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.registry_id`

```python
registry_id = str(uuid4())
```

###### `openhands.sdk.llm.llm_registry.LLMRegistry.retry_listener`

```python
retry_listener = retry_listener
```

###### `openhands.sdk.llm.llm_registry.LLMRegistry.service_to_llm`

```python
service_to_llm: dict[str, LLM] = {}
```

###### `openhands.sdk.llm.llm_registry.LLMRegistry.subscribe`

```python
subscribe(callback)
```

Subscribe to registry events.

**Parameters:**

- **callback** (<code>[Callable](#typing.Callable)\[\[[RegistryEvent](#openhands.sdk.llm.llm_registry.RegistryEvent)\], None\]</code>) – Function to call when LLMs are created or updated.

###### `openhands.sdk.llm.llm_registry.LLMRegistry.subscriber`

```python
subscriber: Callable[[RegistryEvent], None] | None = None
```

##### `openhands.sdk.llm.llm_registry.RegistryEvent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Event representing LLM registration or deregistration.

**Attributes:**

- [**llm**](#openhands.sdk.llm.llm_registry.RegistryEvent.llm) (<code>[LLM](#openhands.sdk.llm.llm.LLM)</code>) –
- [**model_config**](#openhands.sdk.llm.llm_registry.RegistryEvent.model_config) –
- [**service_id**](#openhands.sdk.llm.llm_registry.RegistryEvent.service_id) (<code>[str](#str)</code>) –

###### `openhands.sdk.llm.llm_registry.RegistryEvent.llm`

```python
llm: LLM
```

###### `openhands.sdk.llm.llm_registry.RegistryEvent.model_config`

```python
model_config = ConfigDict(arbitrary_types_allowed=True)
```

###### `openhands.sdk.llm.llm_registry.RegistryEvent.service_id`

```python
service_id: str
```

##### `openhands.sdk.llm.llm_registry.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.llm.message`

Message types and content for LLM communication.

**Classes:**

- [**BaseContent**](#openhands.sdk.llm.message.BaseContent) – Base class for message content.
- [**ImageContent**](#openhands.sdk.llm.message.ImageContent) – Image content for messages.
- [**Message**](#openhands.sdk.llm.message.Message) – Message for LLM communication.
- [**TextContent**](#openhands.sdk.llm.message.TextContent) – Text content for messages.

**Functions:**

- [**content_to_str**](#openhands.sdk.llm.message.content_to_str) – Convert a list of TextContent and ImageContent to a list of strings.

**Attributes:**

- [**logger**](#openhands.sdk.llm.message.logger) –

##### `openhands.sdk.llm.message.BaseContent`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Base class for message content.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.llm.message.BaseContent.to_llm_dict) – Convert to LLM API format. Subclasses should implement this method.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.llm.message.BaseContent.cache_prompt) (<code>[bool](#bool)</code>) –

###### `openhands.sdk.llm.message.BaseContent.cache_prompt`

```python
cache_prompt: bool = False
```

###### `openhands.sdk.llm.message.BaseContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format. Subclasses should implement this method.

##### `openhands.sdk.llm.message.ImageContent`

Bases: <code>[ImageContent](#mcp.types.ImageContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Image content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.llm.message.ImageContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.llm.message.ImageContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**image_urls**](#openhands.sdk.llm.message.ImageContent.image_urls) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**model_config**](#openhands.sdk.llm.message.ImageContent.model_config) –
- [**type**](#openhands.sdk.llm.message.ImageContent.type) (<code>[Literal](#typing.Literal)['image']</code>) –

###### `openhands.sdk.llm.message.ImageContent.cache_prompt`

```python
cache_prompt: bool = False
```

###### `openhands.sdk.llm.message.ImageContent.image_urls`

```python
image_urls: list[str]
```

###### `openhands.sdk.llm.message.ImageContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

###### `openhands.sdk.llm.message.ImageContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

###### `openhands.sdk.llm.message.ImageContent.type`

```python
type: Literal['image'] = 'image'
```

##### `openhands.sdk.llm.message.Message`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Message for LLM communication.

**Functions:**

- [**from_litellm_message**](#openhands.sdk.llm.message.Message.from_litellm_message) – Convert a LiteLLMMessage to our Message class.
- [**to_llm_dict**](#openhands.sdk.llm.message.Message.to_llm_dict) – Serialize message for LLM API consumption.

**Attributes:**

- [**cache_enabled**](#openhands.sdk.llm.message.Message.cache_enabled) (<code>[bool](#bool)</code>) –
- [**contains_image**](#openhands.sdk.llm.message.Message.contains_image) (<code>[bool](#bool)</code>) – Check if message contains image content.
- [**content**](#openhands.sdk.llm.message.Message.content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) –
- [**force_string_serializer**](#openhands.sdk.llm.message.Message.force_string_serializer) (<code>[bool](#bool)</code>) –
- [**function_calling_enabled**](#openhands.sdk.llm.message.Message.function_calling_enabled) (<code>[bool](#bool)</code>) –
- [**name**](#openhands.sdk.llm.message.Message.name) (<code>[str](#str) | None</code>) –
- [**reasoning_content**](#openhands.sdk.llm.message.Message.reasoning_content) (<code>[str](#str) | None</code>) –
- [**role**](#openhands.sdk.llm.message.Message.role) (<code>[Literal](#typing.Literal)['user', 'system', 'assistant', 'tool']</code>) –
- [**tool_call_id**](#openhands.sdk.llm.message.Message.tool_call_id) (<code>[str](#str) | None</code>) –
- [**tool_calls**](#openhands.sdk.llm.message.Message.tool_calls) (<code>[list](#list)\[[ChatCompletionMessageToolCall](#litellm.ChatCompletionMessageToolCall)\] | None</code>) –
- [**vision_enabled**](#openhands.sdk.llm.message.Message.vision_enabled) (<code>[bool](#bool)</code>) –

###### `openhands.sdk.llm.message.Message.cache_enabled`

```python
cache_enabled: bool = False
```

###### `openhands.sdk.llm.message.Message.contains_image`

```python
contains_image: bool
```

Check if message contains image content.

###### `openhands.sdk.llm.message.Message.content`

```python
content: list[TextContent | ImageContent] = Field(default_factory=list)
```

###### `openhands.sdk.llm.message.Message.force_string_serializer`

```python
force_string_serializer: bool = False
```

###### `openhands.sdk.llm.message.Message.from_litellm_message`

```python
from_litellm_message(message)
```

Convert a LiteLLMMessage to our Message class.

Provider-agnostic mapping for reasoning:

- Prefer `message.reasoning_content` if present (LiteLLM normalized field)

###### `openhands.sdk.llm.message.Message.function_calling_enabled`

```python
function_calling_enabled: bool = False
```

###### `openhands.sdk.llm.message.Message.name`

```python
name: str | None = None
```

###### `openhands.sdk.llm.message.Message.reasoning_content`

```python
reasoning_content: str | None = Field(default=None, description='Intermediate reasoning/thinking content from reasoning models')
```

###### `openhands.sdk.llm.message.Message.role`

```python
role: Literal['user', 'system', 'assistant', 'tool']
```

###### `openhands.sdk.llm.message.Message.to_llm_dict`

```python
to_llm_dict()
```

Serialize message for LLM API consumption.

This method chooses the appropriate serialization format based on the message
configuration and provider capabilities:

- String format: for providers that don't support list of content items
- List format: for providers with vision/prompt caching/tool calls support

###### `openhands.sdk.llm.message.Message.tool_call_id`

```python
tool_call_id: str | None = None
```

###### `openhands.sdk.llm.message.Message.tool_calls`

```python
tool_calls: list[ChatCompletionMessageToolCall] | None = None
```

###### `openhands.sdk.llm.message.Message.vision_enabled`

```python
vision_enabled: bool = False
```

##### `openhands.sdk.llm.message.TextContent`

Bases: <code>[TextContent](#mcp.types.TextContent)</code>, <code>[BaseContent](#openhands.sdk.llm.message.BaseContent)</code>

Text content for messages.

**Functions:**

- [**to_llm_dict**](#openhands.sdk.llm.message.TextContent.to_llm_dict) – Convert to LLM API format.

**Attributes:**

- [**cache_prompt**](#openhands.sdk.llm.message.TextContent.cache_prompt) (<code>[bool](#bool)</code>) –
- [**model_config**](#openhands.sdk.llm.message.TextContent.model_config) –
- [**text**](#openhands.sdk.llm.message.TextContent.text) (<code>[str](#str)</code>) –
- [**type**](#openhands.sdk.llm.message.TextContent.type) (<code>[Literal](#typing.Literal)['text']</code>) –

###### `openhands.sdk.llm.message.TextContent.cache_prompt`

```python
cache_prompt: bool = False
```

###### `openhands.sdk.llm.message.TextContent.model_config`

```python
model_config = ConfigDict(extra='forbid', populate_by_name=True)
```

###### `openhands.sdk.llm.message.TextContent.text`

```python
text: str
```

###### `openhands.sdk.llm.message.TextContent.to_llm_dict`

```python
to_llm_dict()
```

Convert to LLM API format.

###### `openhands.sdk.llm.message.TextContent.type`

```python
type: Literal['text'] = 'text'
```

##### `openhands.sdk.llm.message.content_to_str`

```python
content_to_str(contents)
```

Convert a list of TextContent and ImageContent to a list of strings.

This is primarily used for display purposes.

##### `openhands.sdk.llm.message.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.llm.metadata`

LLM metadata utilities for tracing and telemetry.

**Functions:**

- [**get_llm_metadata**](#openhands.sdk.llm.metadata.get_llm_metadata) – Get metadata for LLM tracing and telemetry.

##### `openhands.sdk.llm.metadata.get_llm_metadata`

```python
get_llm_metadata(model_name, agent_name, session_id=None, user_id=None)
```

Get metadata for LLM tracing and telemetry.

### `openhands.sdk.logger`

Minimal logger setup that encourages per-module loggers.

With Rich for humans and JSON for machines.

<details class="usage" open>
<summary>Usage</summary>
from openhands.sdk.logger import get_logger
logger = get_logger(__name__)
logger.info("Hello from this module!")
</details>

**Functions:**

- [**disable_logger**](#openhands.sdk.logger.disable_logger) – Disable or quiet down a specific logger by name.
- [**get_logger**](#openhands.sdk.logger.get_logger) – Return a logger for the given module name.
- [**setup_logging**](#openhands.sdk.logger.setup_logging) – Configure the root logger. All child loggers inherit this setup.

**Attributes:**

- [**DEBUG**](#openhands.sdk.logger.DEBUG) –
- [**ENV_AUTO_CONFIG**](#openhands.sdk.logger.ENV_AUTO_CONFIG) –
- [**ENV_BACKUP_COUNT**](#openhands.sdk.logger.ENV_BACKUP_COUNT) –
- [**ENV_DEBUG_LLM**](#openhands.sdk.logger.ENV_DEBUG_LLM) –
- [**ENV_JSON**](#openhands.sdk.logger.ENV_JSON) –
- [**ENV_LOG_DIR**](#openhands.sdk.logger.ENV_LOG_DIR) –
- [**ENV_LOG_LEVEL**](#openhands.sdk.logger.ENV_LOG_LEVEL) –
- [**ENV_LOG_LEVEL_STR**](#openhands.sdk.logger.ENV_LOG_LEVEL_STR) –
- [**ENV_LOG_TO_FILE**](#openhands.sdk.logger.ENV_LOG_TO_FILE) –
- [**ENV_RICH_TRACEBACKS**](#openhands.sdk.logger.ENV_RICH_TRACEBACKS) –
- [**ENV_ROTATE_WHEN**](#openhands.sdk.logger.ENV_ROTATE_WHEN) –
- [**IN_CI**](#openhands.sdk.logger.IN_CI) –
- [**LEVEL_MAP**](#openhands.sdk.logger.LEVEL_MAP) –
- [**confirmation**](#openhands.sdk.logger.confirmation) –

#### `openhands.sdk.logger.DEBUG`

```python
DEBUG = os.environ.get('DEBUG', 'false').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_AUTO_CONFIG`

```python
ENV_AUTO_CONFIG = os.getenv('LOG_AUTO_CONFIG', 'true').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_BACKUP_COUNT`

```python
ENV_BACKUP_COUNT = int(os.getenv('LOG_BACKUP_COUNT', '7'))
```

#### `openhands.sdk.logger.ENV_DEBUG_LLM`

```python
ENV_DEBUG_LLM = os.getenv('DEBUG_LLM', 'false').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_JSON`

```python
ENV_JSON = os.getenv('LOG_JSON', 'false').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_LOG_DIR`

```python
ENV_LOG_DIR = os.getenv('LOG_DIR', 'logs')
```

#### `openhands.sdk.logger.ENV_LOG_LEVEL`

```python
ENV_LOG_LEVEL = LEVEL_MAP.get(ENV_LOG_LEVEL_STR, logging.INFO)
```

#### `openhands.sdk.logger.ENV_LOG_LEVEL_STR`

```python
ENV_LOG_LEVEL_STR = os.getenv('LOG_LEVEL', 'INFO').upper()
```

#### `openhands.sdk.logger.ENV_LOG_TO_FILE`

```python
ENV_LOG_TO_FILE = os.getenv('LOG_TO_FILE', 'false').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_RICH_TRACEBACKS`

```python
ENV_RICH_TRACEBACKS = os.getenv('LOG_RICH_TRACEBACKS', 'true').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.ENV_ROTATE_WHEN`

```python
ENV_ROTATE_WHEN = os.getenv('LOG_ROTATE_WHEN', 'midnight')
```

#### `openhands.sdk.logger.IN_CI`

```python
IN_CI = os.getenv('CI', 'false').lower() in {'1', 'true', 'yes'}
```

#### `openhands.sdk.logger.LEVEL_MAP`

```python
LEVEL_MAP = logging.getLevelNamesMapping() if hasattr(logging, 'getLevelNamesMapping') else logging._nameToLevel
```

#### `openhands.sdk.logger.confirmation`

```python
confirmation = input("\n⚠️ WARNING: You are enabling DEBUG_LLM which may expose sensitive information like API keys.\nThis should NEVER be enabled in production.\nType 'y' to confirm you understand the risks: ")
```

#### `openhands.sdk.logger.disable_logger`

```python
disable_logger(name, level=logging.CRITICAL)
```

Disable or quiet down a specific logger by name.

#### `openhands.sdk.logger.get_logger`

```python
get_logger(name)
```

Return a logger for the given module name.

#### `openhands.sdk.logger.setup_logging`

```python
setup_logging(level=None, log_to_file=None, log_dir=None, fmt=None, when=None, backup_count=None)
```

Configure the root logger. All child loggers inherit this setup.

### `openhands.sdk.mcp`

MCP (Model Context Protocol) integration for agent-sdk.

**Modules:**

- [**client**](#openhands.sdk.mcp.client) – Minimal sync helpers on top of fastmcp.Client, preserving original behavior.
- [**definition**](#openhands.sdk.mcp.definition) – MCPTool definition and implementation.
- [**tool**](#openhands.sdk.mcp.tool) – Utility functions for MCP integration.
- [**utils**](#openhands.sdk.mcp.utils) – Utility functions for MCP integration.

**Classes:**

- [**MCPClient**](#openhands.sdk.mcp.MCPClient) – Behaves exactly like fastmcp.Client (same constructor & async API).
- [**MCPTool**](#openhands.sdk.mcp.MCPTool) – MCP Tool that wraps an MCP client and provides tool functionality.
- [**MCPToolExecutor**](#openhands.sdk.mcp.MCPToolExecutor) – Executor for MCP tools.
- [**MCPToolObservation**](#openhands.sdk.mcp.MCPToolObservation) – Observation from MCP tool execution.

**Functions:**

- [**create_mcp_tools**](#openhands.sdk.mcp.create_mcp_tools) – Create MCP tools from MCP configuration.

#### `openhands.sdk.mcp.MCPClient`

```python
MCPClient(*args, **kwargs)
```

Bases: <code>[Client](#fastmcp.Client)</code>

Behaves exactly like fastmcp.Client (same constructor & async API).

<details class="owns-a-background-event-loop-and-offers" open>
<summary>Owns a background event loop and offers</summary>
- call_async_from_sync(awaitable_or_fn, *args, timeout=None, **kwargs)
- call_sync_from_async(fn, *args, **kwargs)  # await this from async code
</details>

**Functions:**

- [**call_async_from_sync**](#openhands.sdk.mcp.MCPClient.call_async_from_sync) – Run a coroutine or async function on this client's loop from sync code.
- [**call_sync_from_async**](#openhands.sdk.mcp.MCPClient.call_sync_from_async) – Await running a blocking function in the threadpool from async code.
- [**sync_close**](#openhands.sdk.mcp.MCPClient.sync_close) – Close the client synchronously.

Initialize the MCP client with background event loop support.

##### `openhands.sdk.mcp.MCPClient.call_async_from_sync`

```python
call_async_from_sync(awaitable_or_fn, *args, timeout, **kwargs)
```

Run a coroutine or async function on this client's loop from sync code.

<details class="usage" open>
<summary>Usage</summary>
mcp.call_async_from_sync(async_fn, arg1, kw=...)
mcp.call_async_from_sync(coro)
</details>

##### `openhands.sdk.mcp.MCPClient.call_sync_from_async`

```python
call_sync_from_async(fn, *args, **kwargs)
```

Await running a blocking function in the threadpool from async code.

##### `openhands.sdk.mcp.MCPClient.sync_close`

```python
sync_close()
```

Close the client synchronously.

#### `openhands.sdk.mcp.MCPTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[MCPActionBase](#openhands.sdk.tool.MCPActionBase), [MCPToolObservation](#openhands.sdk.mcp.MCPToolObservation)\]</code>

MCP Tool that wraps an MCP client and provides tool functionality.

**Functions:**

- [**call**](#openhands.sdk.mcp.MCPTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.mcp.MCPTool.create) – Create an MCPTool from an MCP tool definition.
- [**model_validate**](#openhands.sdk.mcp.MCPTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.mcp.MCPTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.mcp.MCPTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.mcp.MCPTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.mcp.MCPTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.mcp.MCPTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.mcp.MCPTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.mcp.MCPTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.mcp.MCPTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.mcp.MCPTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.mcp.MCPTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.mcp.MCPTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**mcp_tool**](#openhands.sdk.mcp.MCPTool.mcp_tool) (<code>[Tool](#mcp.types.Tool)</code>) –
- [**meta**](#openhands.sdk.mcp.MCPTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.mcp.MCPTool.model_config) –
- [**name**](#openhands.sdk.mcp.MCPTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.mcp.MCPTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.mcp.MCPTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.mcp.MCPTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

##### `openhands.sdk.mcp.MCPTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

##### `openhands.sdk.mcp.MCPTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

##### `openhands.sdk.mcp.MCPTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

##### `openhands.sdk.mcp.MCPTool.create`

```python
create(mcp_tool, mcp_client)
```

Create an MCPTool from an MCP tool definition.

##### `openhands.sdk.mcp.MCPTool.description`

```python
description: str
```

##### `openhands.sdk.mcp.MCPTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.sdk.mcp.MCPTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

##### `openhands.sdk.mcp.MCPTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.mcp.MCPTool.mcp_tool`

```python
mcp_tool: mcp.types.Tool = Field(description='The MCP tool definition.')
```

##### `openhands.sdk.mcp.MCPTool.meta`

```python
meta: dict[str, Any] | None = None
```

##### `openhands.sdk.mcp.MCPTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.sdk.mcp.MCPTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.mcp.MCPTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.mcp.MCPTool.name`

```python
name: str
```

##### `openhands.sdk.mcp.MCPTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

##### `openhands.sdk.mcp.MCPTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

##### `openhands.sdk.mcp.MCPTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

##### `openhands.sdk.mcp.MCPTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.mcp.MCPTool.title`

```python
title: str
```

Get the title for the tool.

##### `openhands.sdk.mcp.MCPTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

##### `openhands.sdk.mcp.MCPTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

#### `openhands.sdk.mcp.MCPToolExecutor`

```python
MCPToolExecutor(tool_name, client)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for MCP tools.

**Functions:**

- [**call_tool**](#openhands.sdk.mcp.MCPToolExecutor.call_tool) – Call an MCP tool asynchronously.
- [**close**](#openhands.sdk.mcp.MCPToolExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**client**](#openhands.sdk.mcp.MCPToolExecutor.client) –
- [**tool_name**](#openhands.sdk.mcp.MCPToolExecutor.tool_name) –

Initialize the MCP tool executor.

##### `openhands.sdk.mcp.MCPToolExecutor.call_tool`

```python
call_tool(action)
```

Call an MCP tool asynchronously.

##### `openhands.sdk.mcp.MCPToolExecutor.client`

```python
client = client
```

##### `openhands.sdk.mcp.MCPToolExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.sdk.mcp.MCPToolExecutor.tool_name`

```python
tool_name = tool_name
```

#### `openhands.sdk.mcp.MCPToolObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

Observation from MCP tool execution.

**Functions:**

- [**from_call_tool_result**](#openhands.sdk.mcp.MCPToolObservation.from_call_tool_result) – Create an MCPToolObservation from a CallToolResult.
- [**from_mcp_schema**](#openhands.sdk.mcp.MCPToolObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.mcp.MCPToolObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.mcp.MCPToolObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.mcp.MCPToolObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.mcp.MCPToolObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.mcp.MCPToolObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Format the observation for agent display.
- [**content**](#openhands.sdk.mcp.MCPToolObservation.content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) –
- [**is_error**](#openhands.sdk.mcp.MCPToolObservation.is_error) (<code>[bool](#bool)</code>) –
- [**kind**](#openhands.sdk.mcp.MCPToolObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.mcp.MCPToolObservation.model_config) –
- [**tool_name**](#openhands.sdk.mcp.MCPToolObservation.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.mcp.MCPToolObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

##### `openhands.sdk.mcp.MCPToolObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Format the observation for agent display.

##### `openhands.sdk.mcp.MCPToolObservation.content`

```python
content: list[TextContent | ImageContent] = Field(default_factory=list, description='Content returned from the MCP tool converted to LLM Ready TextContent or ImageContent')
```

##### `openhands.sdk.mcp.MCPToolObservation.from_call_tool_result`

```python
from_call_tool_result(tool_name, result)
```

Create an MCPToolObservation from a CallToolResult.

##### `openhands.sdk.mcp.MCPToolObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.sdk.mcp.MCPToolObservation.is_error`

```python
is_error: bool = Field(default=False, description='Whether the call resulted in an error')
```

##### `openhands.sdk.mcp.MCPToolObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.mcp.MCPToolObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.sdk.mcp.MCPToolObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.mcp.MCPToolObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.mcp.MCPToolObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.mcp.MCPToolObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.sdk.mcp.MCPToolObservation.tool_name`

```python
tool_name: str = Field(description='Name of the tool that was called')
```

##### `openhands.sdk.mcp.MCPToolObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

#### `openhands.sdk.mcp.client`

Minimal sync helpers on top of fastmcp.Client, preserving original behavior.

**Classes:**

- [**MCPClient**](#openhands.sdk.mcp.client.MCPClient) – Behaves exactly like fastmcp.Client (same constructor & async API).

##### `openhands.sdk.mcp.client.MCPClient`

```python
MCPClient(*args, **kwargs)
```

Bases: <code>[Client](#fastmcp.Client)</code>

Behaves exactly like fastmcp.Client (same constructor & async API).

<details class="owns-a-background-event-loop-and-offers" open>
<summary>Owns a background event loop and offers</summary>
- call_async_from_sync(awaitable_or_fn, *args, timeout=None, **kwargs)
- call_sync_from_async(fn, *args, **kwargs)  # await this from async code
</details>

**Functions:**

- [**call_async_from_sync**](#openhands.sdk.mcp.client.MCPClient.call_async_from_sync) – Run a coroutine or async function on this client's loop from sync code.
- [**call_sync_from_async**](#openhands.sdk.mcp.client.MCPClient.call_sync_from_async) – Await running a blocking function in the threadpool from async code.
- [**sync_close**](#openhands.sdk.mcp.client.MCPClient.sync_close) – Close the client synchronously.

Initialize the MCP client with background event loop support.

###### `openhands.sdk.mcp.client.MCPClient.call_async_from_sync`

```python
call_async_from_sync(awaitable_or_fn, *args, timeout, **kwargs)
```

Run a coroutine or async function on this client's loop from sync code.

<details class="usage" open>
<summary>Usage</summary>
mcp.call_async_from_sync(async_fn, arg1, kw=...)
mcp.call_async_from_sync(coro)
</details>

###### `openhands.sdk.mcp.client.MCPClient.call_sync_from_async`

```python
call_sync_from_async(fn, *args, **kwargs)
```

Await running a blocking function in the threadpool from async code.

###### `openhands.sdk.mcp.client.MCPClient.sync_close`

```python
sync_close()
```

Close the client synchronously.

#### `openhands.sdk.mcp.create_mcp_tools`

```python
create_mcp_tools(config, timeout=30.0)
```

Create MCP tools from MCP configuration.

#### `openhands.sdk.mcp.definition`

MCPTool definition and implementation.

**Classes:**

- [**MCPToolObservation**](#openhands.sdk.mcp.definition.MCPToolObservation) – Observation from MCP tool execution.

**Attributes:**

- [**logger**](#openhands.sdk.mcp.definition.logger) –

##### `openhands.sdk.mcp.definition.MCPToolObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

Observation from MCP tool execution.

**Functions:**

- [**from_call_tool_result**](#openhands.sdk.mcp.definition.MCPToolObservation.from_call_tool_result) – Create an MCPToolObservation from a CallToolResult.
- [**from_mcp_schema**](#openhands.sdk.mcp.definition.MCPToolObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.mcp.definition.MCPToolObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.mcp.definition.MCPToolObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.mcp.definition.MCPToolObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.mcp.definition.MCPToolObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.mcp.definition.MCPToolObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Format the observation for agent display.
- [**content**](#openhands.sdk.mcp.definition.MCPToolObservation.content) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) –
- [**is_error**](#openhands.sdk.mcp.definition.MCPToolObservation.is_error) (<code>[bool](#bool)</code>) –
- [**kind**](#openhands.sdk.mcp.definition.MCPToolObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.mcp.definition.MCPToolObservation.model_config) –
- [**tool_name**](#openhands.sdk.mcp.definition.MCPToolObservation.tool_name) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.mcp.definition.MCPToolObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.sdk.mcp.definition.MCPToolObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Format the observation for agent display.

###### `openhands.sdk.mcp.definition.MCPToolObservation.content`

```python
content: list[TextContent | ImageContent] = Field(default_factory=list, description='Content returned from the MCP tool converted to LLM Ready TextContent or ImageContent')
```

###### `openhands.sdk.mcp.definition.MCPToolObservation.from_call_tool_result`

```python
from_call_tool_result(tool_name, result)
```

Create an MCPToolObservation from a CallToolResult.

###### `openhands.sdk.mcp.definition.MCPToolObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.mcp.definition.MCPToolObservation.is_error`

```python
is_error: bool = Field(default=False, description='Whether the call resulted in an error')
```

###### `openhands.sdk.mcp.definition.MCPToolObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.mcp.definition.MCPToolObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.sdk.mcp.definition.MCPToolObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.mcp.definition.MCPToolObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.mcp.definition.MCPToolObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.mcp.definition.MCPToolObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.mcp.definition.MCPToolObservation.tool_name`

```python
tool_name: str = Field(description='Name of the tool that was called')
```

###### `openhands.sdk.mcp.definition.MCPToolObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

##### `openhands.sdk.mcp.definition.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.sdk.mcp.tool`

Utility functions for MCP integration.

**Classes:**

- [**MCPTool**](#openhands.sdk.mcp.tool.MCPTool) – MCP Tool that wraps an MCP client and provides tool functionality.
- [**MCPToolExecutor**](#openhands.sdk.mcp.tool.MCPToolExecutor) – Executor for MCP tools.

**Functions:**

- [**to_camel_case**](#openhands.sdk.mcp.tool.to_camel_case) – Convert a string to CamelCase.

**Attributes:**

- [**logger**](#openhands.sdk.mcp.tool.logger) –

##### `openhands.sdk.mcp.tool.MCPTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[MCPActionBase](#openhands.sdk.tool.MCPActionBase), [MCPToolObservation](#openhands.sdk.mcp.MCPToolObservation)\]</code>

MCP Tool that wraps an MCP client and provides tool functionality.

**Functions:**

- [**call**](#openhands.sdk.mcp.tool.MCPTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.mcp.tool.MCPTool.create) – Create an MCPTool from an MCP tool definition.
- [**model_validate**](#openhands.sdk.mcp.tool.MCPTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.mcp.tool.MCPTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.mcp.tool.MCPTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.mcp.tool.MCPTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.mcp.tool.MCPTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.mcp.tool.MCPTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.mcp.tool.MCPTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.mcp.tool.MCPTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.mcp.tool.MCPTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.mcp.tool.MCPTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.mcp.tool.MCPTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.mcp.tool.MCPTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**mcp_tool**](#openhands.sdk.mcp.tool.MCPTool.mcp_tool) (<code>[Tool](#mcp.types.Tool)</code>) –
- [**meta**](#openhands.sdk.mcp.tool.MCPTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.mcp.tool.MCPTool.model_config) –
- [**name**](#openhands.sdk.mcp.tool.MCPTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.mcp.tool.MCPTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.mcp.tool.MCPTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.mcp.tool.MCPTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

###### `openhands.sdk.mcp.tool.MCPTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

###### `openhands.sdk.mcp.tool.MCPTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

###### `openhands.sdk.mcp.tool.MCPTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

###### `openhands.sdk.mcp.tool.MCPTool.create`

```python
create(mcp_tool, mcp_client)
```

Create an MCPTool from an MCP tool definition.

###### `openhands.sdk.mcp.tool.MCPTool.description`

```python
description: str
```

###### `openhands.sdk.mcp.tool.MCPTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.sdk.mcp.tool.MCPTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

###### `openhands.sdk.mcp.tool.MCPTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.mcp.tool.MCPTool.mcp_tool`

```python
mcp_tool: mcp.types.Tool = Field(description='The MCP tool definition.')
```

###### `openhands.sdk.mcp.tool.MCPTool.meta`

```python
meta: dict[str, Any] | None = None
```

###### `openhands.sdk.mcp.tool.MCPTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.sdk.mcp.tool.MCPTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.mcp.tool.MCPTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.mcp.tool.MCPTool.name`

```python
name: str
```

###### `openhands.sdk.mcp.tool.MCPTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

###### `openhands.sdk.mcp.tool.MCPTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

###### `openhands.sdk.mcp.tool.MCPTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

###### `openhands.sdk.mcp.tool.MCPTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.mcp.tool.MCPTool.title`

```python
title: str
```

Get the title for the tool.

###### `openhands.sdk.mcp.tool.MCPTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

###### `openhands.sdk.mcp.tool.MCPTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

##### `openhands.sdk.mcp.tool.MCPToolExecutor`

```python
MCPToolExecutor(tool_name, client)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for MCP tools.

**Functions:**

- [**call_tool**](#openhands.sdk.mcp.tool.MCPToolExecutor.call_tool) – Call an MCP tool asynchronously.
- [**close**](#openhands.sdk.mcp.tool.MCPToolExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**client**](#openhands.sdk.mcp.tool.MCPToolExecutor.client) –
- [**tool_name**](#openhands.sdk.mcp.tool.MCPToolExecutor.tool_name) –

Initialize the MCP tool executor.

###### `openhands.sdk.mcp.tool.MCPToolExecutor.call_tool`

```python
call_tool(action)
```

Call an MCP tool asynchronously.

###### `openhands.sdk.mcp.tool.MCPToolExecutor.client`

```python
client = client
```

###### `openhands.sdk.mcp.tool.MCPToolExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

###### `openhands.sdk.mcp.tool.MCPToolExecutor.tool_name`

```python
tool_name = tool_name
```

##### `openhands.sdk.mcp.tool.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.sdk.mcp.tool.to_camel_case`

```python
to_camel_case(s)
```

Convert a string to CamelCase.

#### `openhands.sdk.mcp.utils`

Utility functions for MCP integration.

**Functions:**

- [**create_mcp_tools**](#openhands.sdk.mcp.utils.create_mcp_tools) – Create MCP tools from MCP configuration.
- [**log_handler**](#openhands.sdk.mcp.utils.log_handler) – Handle incoming logs from the MCP server.

**Attributes:**

- [**LOGGING_LEVEL_MAP**](#openhands.sdk.mcp.utils.LOGGING_LEVEL_MAP) –
- [**logger**](#openhands.sdk.mcp.utils.logger) –

##### `openhands.sdk.mcp.utils.LOGGING_LEVEL_MAP`

```python
LOGGING_LEVEL_MAP = logging.getLevelNamesMapping()
```

##### `openhands.sdk.mcp.utils.create_mcp_tools`

```python
create_mcp_tools(config, timeout=30.0)
```

Create MCP tools from MCP configuration.

##### `openhands.sdk.mcp.utils.log_handler`

```python
log_handler(message)
```

Handle incoming logs from the MCP server.

Forwards them to the standard Python logging system.

##### `openhands.sdk.mcp.utils.logger`

```python
logger = get_logger(__name__)
```

### `openhands.sdk.tool`

OpenHands runtime package.

**Modules:**

- [**builtins**](#openhands.sdk.tool.builtins) – Implementing essential tools that doesn't interact with the environment.
- [**schema**](#openhands.sdk.tool.schema) – Tool schema definitions.
- [**security_prompt**](#openhands.sdk.tool.security_prompt) – Security risk assessment constants for tools.
- [**tool**](#openhands.sdk.tool.tool) – Tool framework for defining and executing tools with validation.

**Classes:**

- [**ActionBase**](#openhands.sdk.tool.ActionBase) – Base schema for input action.
- [**MCPActionBase**](#openhands.sdk.tool.MCPActionBase) – Base schema for MCP input action.
- [**ObservationBase**](#openhands.sdk.tool.ObservationBase) – Base schema for output observation.
- [**Tool**](#openhands.sdk.tool.Tool) – Tool that wraps an executor function with input/output validation and schema.
- [**ToolAnnotations**](#openhands.sdk.tool.ToolAnnotations) – Annotations to provide hints about the tool's behavior.
- [**ToolExecutor**](#openhands.sdk.tool.ToolExecutor) – Executor function type for a Tool.

**Attributes:**

- [**Action**](#openhands.sdk.tool.Action) – Type annotation for values that can be any implementation of ActionBase.
- [**BUILT_IN_TOOLS**](#openhands.sdk.tool.BUILT_IN_TOOLS) –
- [**FinishTool**](#openhands.sdk.tool.FinishTool) –
- [**Observation**](#openhands.sdk.tool.Observation) – Type annotation for values that can be any implementation of ObservationBase.
- [**ThinkTool**](#openhands.sdk.tool.ThinkTool) –
- [**ToolType**](#openhands.sdk.tool.ToolType) –

#### `openhands.sdk.tool.Action`

```python
Action = Annotated[ActionBase, DiscriminatedUnionType[ActionBase]]
```

Type annotation for values that can be any implementation of ActionBase.

In most situations, this is equivalent to ActionBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.

#### `openhands.sdk.tool.ActionBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for input action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.ActionBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.ActionBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.ActionBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.ActionBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.ActionBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.ActionBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.ActionBase.model_config) –
- [**security_risk**](#openhands.sdk.tool.ActionBase.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.ActionBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

##### `openhands.sdk.tool.ActionBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.sdk.tool.ActionBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.tool.ActionBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.sdk.tool.ActionBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.tool.ActionBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.tool.ActionBase.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

##### `openhands.sdk.tool.ActionBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.tool.ActionBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.sdk.tool.ActionBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

#### `openhands.sdk.tool.BUILT_IN_TOOLS`

```python
BUILT_IN_TOOLS = [FinishTool, ThinkTool]
```

#### `openhands.sdk.tool.FinishTool`

```python
FinishTool = Tool(name='finish', action_type=FinishAction, observation_type=FinishObservation, description=TOOL_DESCRIPTION, executor=(FinishExecutor()), annotations=(ToolAnnotations(title='finish', readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

#### `openhands.sdk.tool.MCPActionBase`

Bases: <code>[ActionBase](#openhands.sdk.tool.schema.ActionBase)</code>

Base schema for MCP input action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.MCPActionBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.MCPActionBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.MCPActionBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.MCPActionBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_arguments**](#openhands.sdk.tool.MCPActionBase.to_mcp_arguments) – Dump model excluding parent ActionBase fields.
- [**to_mcp_schema**](#openhands.sdk.tool.MCPActionBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.MCPActionBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.MCPActionBase.model_config) –
- [**security_risk**](#openhands.sdk.tool.MCPActionBase.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.MCPActionBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

##### `openhands.sdk.tool.MCPActionBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.sdk.tool.MCPActionBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.tool.MCPActionBase.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.sdk.tool.MCPActionBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.tool.MCPActionBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.tool.MCPActionBase.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

##### `openhands.sdk.tool.MCPActionBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.tool.MCPActionBase.to_mcp_arguments`

```python
to_mcp_arguments()
```

Dump model excluding parent ActionBase fields.

This is used to convert this action to MCP tool call arguments.
The parent fields (e.g., safety_risk, kind) are not part of the MCP tool schema
but are only used for our internal processing.

##### `openhands.sdk.tool.MCPActionBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.sdk.tool.MCPActionBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

#### `openhands.sdk.tool.Observation`

```python
Observation = Annotated[ObservationBase, DiscriminatedUnionType[ObservationBase]]
```

Type annotation for values that can be any implementation of ObservationBase.

In most situations, this is equivalent to ObservationBase. However, when used in
Pydantic BaseModels as a field annotation, it enables polymorphic deserialization by
delaying the discriminator resolution until runtime.

#### `openhands.sdk.tool.ObservationBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for output observation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.ObservationBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.ObservationBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.ObservationBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.ObservationBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.ObservationBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.ObservationBase.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the observation string to show to the agent.
- [**kind**](#openhands.sdk.tool.ObservationBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.ObservationBase.model_config) –
- [**visualize**](#openhands.sdk.tool.ObservationBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

##### `openhands.sdk.tool.ObservationBase.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the observation string to show to the agent.

##### `openhands.sdk.tool.ObservationBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.sdk.tool.ObservationBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.tool.ObservationBase.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.sdk.tool.ObservationBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.tool.ObservationBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.tool.ObservationBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.tool.ObservationBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.sdk.tool.ObservationBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

#### `openhands.sdk.tool.ThinkTool`

```python
ThinkTool = Tool(name='think', description=THINK_DESCRIPTION, action_type=ThinkAction, observation_type=ThinkObservation, executor=(ThinkExecutor()), annotations=(ToolAnnotations(readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

#### `openhands.sdk.tool.Tool`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[Generic](#typing.Generic)\[[ActionT](#openhands.sdk.tool.tool.ActionT), [ObservationT](#openhands.sdk.tool.tool.ObservationT)\]</code>

Tool that wraps an executor function with input/output validation and schema.

- Normalize input/output schemas (class or dict) into both model+schema.
- Validate inputs before execute.
- Coerce outputs only if an output model is defined; else return vanilla JSON.
- Export MCP tool description.

**Functions:**

- [**call**](#openhands.sdk.tool.Tool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.tool.Tool.create) – Create a Tool instance. Placeholder for subclasses.
- [**model_validate**](#openhands.sdk.tool.Tool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.Tool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.tool.Tool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.tool.Tool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.tool.Tool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.tool.Tool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.tool.Tool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.tool.Tool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.tool.Tool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.tool.Tool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.tool.Tool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.tool.Tool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.sdk.tool.Tool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.tool.Tool.model_config) –
- [**name**](#openhands.sdk.tool.Tool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.tool.Tool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.tool.Tool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.tool.Tool.title) (<code>[str](#str)</code>) – Get the title for the tool.

##### `openhands.sdk.tool.Tool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

##### `openhands.sdk.tool.Tool.annotations`

```python
annotations: ToolAnnotations | None = None
```

##### `openhands.sdk.tool.Tool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

##### `openhands.sdk.tool.Tool.create`

```python
create(*args, **kwargs)
```

Create a Tool instance. Placeholder for subclasses.

This can be overridden in subclasses to provide custom initialization logic
(e.g., typically initializing the executor with parameters).

##### `openhands.sdk.tool.Tool.description`

```python
description: str
```

##### `openhands.sdk.tool.Tool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.sdk.tool.Tool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

##### `openhands.sdk.tool.Tool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.sdk.tool.Tool.meta`

```python
meta: dict[str, Any] | None = None
```

##### `openhands.sdk.tool.Tool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.sdk.tool.Tool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.sdk.tool.Tool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.sdk.tool.Tool.name`

```python
name: str
```

##### `openhands.sdk.tool.Tool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

##### `openhands.sdk.tool.Tool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

##### `openhands.sdk.tool.Tool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

##### `openhands.sdk.tool.Tool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.tool.Tool.title`

```python
title: str
```

Get the title for the tool.

##### `openhands.sdk.tool.Tool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

##### `openhands.sdk.tool.Tool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

#### `openhands.sdk.tool.ToolAnnotations`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Annotations to provide hints about the tool's behavior.

Based on Model Context Protocol (MCP) spec:
https://github.com/modelcontextprotocol/modelcontextprotocol/blob/caf3424488b10b4a7b1f8cb634244a450a1f4400/schema/2025-06-18/schema.ts#L838

**Attributes:**

- [**destructiveHint**](#openhands.sdk.tool.ToolAnnotations.destructiveHint) (<code>[bool](#bool)</code>) –
- [**idempotentHint**](#openhands.sdk.tool.ToolAnnotations.idempotentHint) (<code>[bool](#bool)</code>) –
- [**openWorldHint**](#openhands.sdk.tool.ToolAnnotations.openWorldHint) (<code>[bool](#bool)</code>) –
- [**readOnlyHint**](#openhands.sdk.tool.ToolAnnotations.readOnlyHint) (<code>[bool](#bool)</code>) –
- [**title**](#openhands.sdk.tool.ToolAnnotations.title) (<code>[str](#str) | None</code>) –

##### `openhands.sdk.tool.ToolAnnotations.destructiveHint`

```python
destructiveHint: bool = Field(default=True, description='If true, the tool may perform destructive updates to its environment. If false, the tool performs only additive updates. (This property is meaningful only when `readOnlyHint == false`) Default: true')
```

##### `openhands.sdk.tool.ToolAnnotations.idempotentHint`

```python
idempotentHint: bool = Field(default=False, description='If true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment. (This property is meaningful only when `readOnlyHint == false`) Default: false')
```

##### `openhands.sdk.tool.ToolAnnotations.openWorldHint`

```python
openWorldHint: bool = Field(default=True, description="If true, this tool may interact with an 'open world' of external entities. If false, the tool's domain of interaction is closed. For example, the world of a web search tool is open, whereas that of a memory tool is not. Default: true")
```

##### `openhands.sdk.tool.ToolAnnotations.readOnlyHint`

```python
readOnlyHint: bool = Field(default=False, description='If true, the tool does not modify its environment. Default: false')
```

##### `openhands.sdk.tool.ToolAnnotations.title`

```python
title: str | None = Field(default=None, description='A human-readable title for the tool.')
```

#### `openhands.sdk.tool.ToolExecutor`

Bases: <code>[Generic](#typing.Generic)\[[ActionT](#openhands.sdk.tool.tool.ActionT), [ObservationT](#openhands.sdk.tool.tool.ObservationT)\]</code>

Executor function type for a Tool.

**Functions:**

- [**close**](#openhands.sdk.tool.ToolExecutor.close) – Close the executor and clean up resources.

##### `openhands.sdk.tool.ToolExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

#### `openhands.sdk.tool.ToolType`

```python
ToolType = Annotated[Tool[ActionT, ObservationT], DiscriminatedUnionType[Tool]]
```

#### `openhands.sdk.tool.builtins`

Implementing essential tools that doesn't interact with the environment.

These are built in and are *required* for the agent to work.

For tools that require interacting with the environment, add them to `openhands/tools`.

**Modules:**

- [**finish**](#openhands.sdk.tool.builtins.finish) – Finish tool for signaling task completion.
- [**think**](#openhands.sdk.tool.builtins.think) – Think tool for logging thoughts and reasoning.

**Classes:**

- [**FinishAction**](#openhands.sdk.tool.builtins.FinishAction) – Action for finishing a task or conversation.
- [**FinishExecutor**](#openhands.sdk.tool.builtins.FinishExecutor) – Executor for finish tool.
- [**FinishObservation**](#openhands.sdk.tool.builtins.FinishObservation) – Observation for finish action.
- [**ThinkAction**](#openhands.sdk.tool.builtins.ThinkAction) – Action for logging a thought without making any changes.
- [**ThinkExecutor**](#openhands.sdk.tool.builtins.ThinkExecutor) – Executor for the think tool.
- [**ThinkObservation**](#openhands.sdk.tool.builtins.ThinkObservation) – Observation returned after logging a thought.

**Attributes:**

- [**BUILT_IN_TOOLS**](#openhands.sdk.tool.builtins.BUILT_IN_TOOLS) –
- [**FinishTool**](#openhands.sdk.tool.builtins.FinishTool) –
- [**ThinkTool**](#openhands.sdk.tool.builtins.ThinkTool) –

##### `openhands.sdk.tool.builtins.BUILT_IN_TOOLS`

```python
BUILT_IN_TOOLS = [FinishTool, ThinkTool]
```

##### `openhands.sdk.tool.builtins.FinishAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.tool.ActionBase)</code>

Action for finishing a task or conversation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.FinishAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.FinishAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.FinishAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.FinishAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.FinishAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.builtins.FinishAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.tool.builtins.FinishAction.message) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.tool.builtins.FinishAction.model_config) –
- [**security_risk**](#openhands.sdk.tool.builtins.FinishAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.builtins.FinishAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.sdk.tool.builtins.FinishAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.builtins.FinishAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.builtins.FinishAction.message`

```python
message: str = Field(description='Final message to send to the user.')
```

###### `openhands.sdk.tool.builtins.FinishAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.tool.builtins.FinishAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.builtins.FinishAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.builtins.FinishAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.sdk.tool.builtins.FinishAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.builtins.FinishAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.builtins.FinishAction.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

##### `openhands.sdk.tool.builtins.FinishExecutor`

Bases: <code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor)</code>

Executor for finish tool.

**Functions:**

- [**close**](#openhands.sdk.tool.builtins.FinishExecutor.close) – Close the executor and clean up resources.

###### `openhands.sdk.tool.builtins.FinishExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.sdk.tool.builtins.FinishObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.tool.ObservationBase)</code>

Observation for finish action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.FinishObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.FinishObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.FinishObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.FinishObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.FinishObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.builtins.FinishObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) – Return agent observation content.
- [**kind**](#openhands.sdk.tool.builtins.FinishObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.tool.builtins.FinishObservation.message) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.tool.builtins.FinishObservation.model_config) –
- [**visualize**](#openhands.sdk.tool.builtins.FinishObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation - empty since action shows the message.

###### `openhands.sdk.tool.builtins.FinishObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return agent observation content.

###### `openhands.sdk.tool.builtins.FinishObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.builtins.FinishObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.builtins.FinishObservation.message`

```python
message: str = Field(description='Final message sent to the user.')
```

###### `openhands.sdk.tool.builtins.FinishObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.sdk.tool.builtins.FinishObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.builtins.FinishObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.builtins.FinishObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.builtins.FinishObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.builtins.FinishObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation - empty since action shows the message.

##### `openhands.sdk.tool.builtins.FinishTool`

```python
FinishTool = Tool(name='finish', action_type=FinishAction, observation_type=FinishObservation, description=TOOL_DESCRIPTION, executor=(FinishExecutor()), annotations=(ToolAnnotations(title='finish', readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

##### `openhands.sdk.tool.builtins.ThinkAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.tool.ActionBase)</code>

Action for logging a thought without making any changes.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.ThinkAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.ThinkAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.ThinkAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.ThinkAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.ThinkAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.builtins.ThinkAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.builtins.ThinkAction.model_config) –
- [**security_risk**](#openhands.sdk.tool.builtins.ThinkAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**thought**](#openhands.sdk.tool.builtins.ThinkAction.thought) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.tool.builtins.ThinkAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with thinking styling.

###### `openhands.sdk.tool.builtins.ThinkAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.builtins.ThinkAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.builtins.ThinkAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.tool.builtins.ThinkAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.builtins.ThinkAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.builtins.ThinkAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.sdk.tool.builtins.ThinkAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.builtins.ThinkAction.thought`

```python
thought: str = Field(description='The thought to log.')
```

###### `openhands.sdk.tool.builtins.ThinkAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.builtins.ThinkAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with thinking styling.

##### `openhands.sdk.tool.builtins.ThinkExecutor`

Bases: <code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor)</code>

Executor for the think tool.

**Functions:**

- [**close**](#openhands.sdk.tool.builtins.ThinkExecutor.close) – Close the executor and clean up resources.

###### `openhands.sdk.tool.builtins.ThinkExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.sdk.tool.builtins.ThinkObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.tool.ObservationBase)</code>

Observation returned after logging a thought.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.ThinkObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.ThinkObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.ThinkObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.ThinkObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.ThinkObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.builtins.ThinkObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) – Return the observation content for the agent.
- [**content**](#openhands.sdk.tool.builtins.ThinkObservation.content) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.tool.builtins.ThinkObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.builtins.ThinkObservation.model_config) –
- [**visualize**](#openhands.sdk.tool.builtins.ThinkObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation - empty since action shows the thought.

###### `openhands.sdk.tool.builtins.ThinkObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return the observation content for the agent.

###### `openhands.sdk.tool.builtins.ThinkObservation.content`

```python
content: str = Field(default='Your thought has been logged.', description='Confirmation message.')
```

###### `openhands.sdk.tool.builtins.ThinkObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.builtins.ThinkObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.builtins.ThinkObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.sdk.tool.builtins.ThinkObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.builtins.ThinkObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.builtins.ThinkObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.builtins.ThinkObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.builtins.ThinkObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation - empty since action shows the thought.

##### `openhands.sdk.tool.builtins.ThinkTool`

```python
ThinkTool = Tool(name='think', description=THINK_DESCRIPTION, action_type=ThinkAction, observation_type=ThinkObservation, executor=(ThinkExecutor()), annotations=(ToolAnnotations(readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

##### `openhands.sdk.tool.builtins.finish`

Finish tool for signaling task completion.

**Classes:**

- [**FinishAction**](#openhands.sdk.tool.builtins.finish.FinishAction) – Action for finishing a task or conversation.
- [**FinishExecutor**](#openhands.sdk.tool.builtins.finish.FinishExecutor) – Executor for finish tool.
- [**FinishObservation**](#openhands.sdk.tool.builtins.finish.FinishObservation) – Observation for finish action.

**Attributes:**

- [**FinishTool**](#openhands.sdk.tool.builtins.finish.FinishTool) –
- [**TOOL_DESCRIPTION**](#openhands.sdk.tool.builtins.finish.TOOL_DESCRIPTION) –

###### `openhands.sdk.tool.builtins.finish.FinishAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.tool.ActionBase)</code>

Action for finishing a task or conversation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.finish.FinishAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.finish.FinishAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.finish.FinishAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.finish.FinishAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.finish.FinishAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.builtins.finish.FinishAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.tool.builtins.finish.FinishAction.message) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.tool.builtins.finish.FinishAction.model_config) –
- [**security_risk**](#openhands.sdk.tool.builtins.finish.FinishAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.builtins.finish.FinishAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

####### `openhands.sdk.tool.builtins.finish.FinishAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

####### `openhands.sdk.tool.builtins.finish.FinishAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

####### `openhands.sdk.tool.builtins.finish.FinishAction.message`

```python
message: str = Field(description='Final message to send to the user.')
```

####### `openhands.sdk.tool.builtins.finish.FinishAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

####### `openhands.sdk.tool.builtins.finish.FinishAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

####### `openhands.sdk.tool.builtins.finish.FinishAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

####### `openhands.sdk.tool.builtins.finish.FinishAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

####### `openhands.sdk.tool.builtins.finish.FinishAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

####### `openhands.sdk.tool.builtins.finish.FinishAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

####### `openhands.sdk.tool.builtins.finish.FinishAction.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

###### `openhands.sdk.tool.builtins.finish.FinishExecutor`

Bases: <code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor)</code>

Executor for finish tool.

**Functions:**

- [**close**](#openhands.sdk.tool.builtins.finish.FinishExecutor.close) – Close the executor and clean up resources.

####### `openhands.sdk.tool.builtins.finish.FinishExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

###### `openhands.sdk.tool.builtins.finish.FinishObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.tool.ObservationBase)</code>

Observation for finish action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.finish.FinishObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.finish.FinishObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.finish.FinishObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.finish.FinishObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.finish.FinishObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.builtins.finish.FinishObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) – Return agent observation content.
- [**kind**](#openhands.sdk.tool.builtins.finish.FinishObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**message**](#openhands.sdk.tool.builtins.finish.FinishObservation.message) (<code>[str](#str)</code>) –
- [**model_config**](#openhands.sdk.tool.builtins.finish.FinishObservation.model_config) –
- [**visualize**](#openhands.sdk.tool.builtins.finish.FinishObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation - empty since action shows the message.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return agent observation content.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.message`

```python
message: str = Field(description='Final message sent to the user.')
```

####### `openhands.sdk.tool.builtins.finish.FinishObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

####### `openhands.sdk.tool.builtins.finish.FinishObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

####### `openhands.sdk.tool.builtins.finish.FinishObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation - empty since action shows the message.

###### `openhands.sdk.tool.builtins.finish.FinishTool`

```python
FinishTool = Tool(name='finish', action_type=FinishAction, observation_type=FinishObservation, description=TOOL_DESCRIPTION, executor=(FinishExecutor()), annotations=(ToolAnnotations(title='finish', readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

###### `openhands.sdk.tool.builtins.finish.TOOL_DESCRIPTION`

```python
TOOL_DESCRIPTION = "Signals the completion of the current task or conversation.\n\nUse this tool when:\n- You have successfully completed the user's requested task\n- You cannot proceed further due to technical limitations or missing information\n\nThe message should include:\n- A clear summary of actions taken and their results\n- Any next steps for the user\n- Explanation if you're unable to complete the task\n- Any follow-up questions if more information is needed\n"
```

##### `openhands.sdk.tool.builtins.think`

Think tool for logging thoughts and reasoning.

**Classes:**

- [**ThinkAction**](#openhands.sdk.tool.builtins.think.ThinkAction) – Action for logging a thought without making any changes.
- [**ThinkExecutor**](#openhands.sdk.tool.builtins.think.ThinkExecutor) – Executor for the think tool.
- [**ThinkObservation**](#openhands.sdk.tool.builtins.think.ThinkObservation) – Observation returned after logging a thought.

**Attributes:**

- [**THINK_DESCRIPTION**](#openhands.sdk.tool.builtins.think.THINK_DESCRIPTION) –
- [**ThinkTool**](#openhands.sdk.tool.builtins.think.ThinkTool) –

###### `openhands.sdk.tool.builtins.think.THINK_DESCRIPTION`

```python
THINK_DESCRIPTION = 'Use the tool to think about something. It will not obtain new information or make any changes to the repository, but just log the thought. Use it when complex reasoning or brainstorming is needed.\n\nCommon use cases:\n1. When exploring a repository and discovering the source of a bug, call this tool to brainstorm several unique ways of fixing the bug, and assess which change(s) are likely to be simplest and most effective.\n2. After receiving test results, use this tool to brainstorm ways to fix failing tests.\n3. When planning a complex refactoring, use this tool to outline different approaches and their tradeoffs.\n4. When designing a new feature, use this tool to think through architecture decisions and implementation details.\n5. When debugging a complex issue, use this tool to organize your thoughts and hypotheses.\n\nThe tool simply logs your thought process for better transparency and does not execute any code or make changes.'
```

###### `openhands.sdk.tool.builtins.think.ThinkAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.tool.ActionBase)</code>

Action for logging a thought without making any changes.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.think.ThinkAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.think.ThinkAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.think.ThinkAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.think.ThinkAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.think.ThinkAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.builtins.think.ThinkAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.builtins.think.ThinkAction.model_config) –
- [**security_risk**](#openhands.sdk.tool.builtins.think.ThinkAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**thought**](#openhands.sdk.tool.builtins.think.ThinkAction.thought) (<code>[str](#str)</code>) –
- [**visualize**](#openhands.sdk.tool.builtins.think.ThinkAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with thinking styling.

####### `openhands.sdk.tool.builtins.think.ThinkAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

####### `openhands.sdk.tool.builtins.think.ThinkAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

####### `openhands.sdk.tool.builtins.think.ThinkAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

####### `openhands.sdk.tool.builtins.think.ThinkAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

####### `openhands.sdk.tool.builtins.think.ThinkAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

####### `openhands.sdk.tool.builtins.think.ThinkAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

####### `openhands.sdk.tool.builtins.think.ThinkAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

####### `openhands.sdk.tool.builtins.think.ThinkAction.thought`

```python
thought: str = Field(description='The thought to log.')
```

####### `openhands.sdk.tool.builtins.think.ThinkAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

####### `openhands.sdk.tool.builtins.think.ThinkAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with thinking styling.

###### `openhands.sdk.tool.builtins.think.ThinkExecutor`

Bases: <code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor)</code>

Executor for the think tool.

**Functions:**

- [**close**](#openhands.sdk.tool.builtins.think.ThinkExecutor.close) – Close the executor and clean up resources.

####### `openhands.sdk.tool.builtins.think.ThinkExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

###### `openhands.sdk.tool.builtins.think.ThinkObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.tool.ObservationBase)</code>

Observation returned after logging a thought.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.builtins.think.ThinkObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.builtins.think.ThinkObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.builtins.think.ThinkObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.builtins.think.ThinkObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.builtins.think.ThinkObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.builtins.think.ThinkObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.message.TextContent) | [ImageContent](#openhands.sdk.llm.message.ImageContent)\]</code>) – Return the observation content for the agent.
- [**content**](#openhands.sdk.tool.builtins.think.ThinkObservation.content) (<code>[str](#str)</code>) –
- [**kind**](#openhands.sdk.tool.builtins.think.ThinkObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.builtins.think.ThinkObservation.model_config) –
- [**visualize**](#openhands.sdk.tool.builtins.think.ThinkObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation - empty since action shows the thought.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return the observation content for the agent.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.content`

```python
content: str = Field(default='Your thought has been logged.', description='Confirmation message.')
```

####### `openhands.sdk.tool.builtins.think.ThinkObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

####### `openhands.sdk.tool.builtins.think.ThinkObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

####### `openhands.sdk.tool.builtins.think.ThinkObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation - empty since action shows the thought.

###### `openhands.sdk.tool.builtins.think.ThinkTool`

```python
ThinkTool = Tool(name='think', description=THINK_DESCRIPTION, action_type=ThinkAction, observation_type=ThinkObservation, executor=(ThinkExecutor()), annotations=(ToolAnnotations(readOnlyHint=True, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

#### `openhands.sdk.tool.schema`

Tool schema definitions.

**Classes:**

- [**ActionBase**](#openhands.sdk.tool.schema.ActionBase) – Base schema for input action.
- [**MCPActionBase**](#openhands.sdk.tool.schema.MCPActionBase) – Base schema for MCP input action.
- [**ObservationBase**](#openhands.sdk.tool.schema.ObservationBase) – Base schema for output observation.
- [**Schema**](#openhands.sdk.tool.schema.Schema) – Base schema for input action / output observation.

**Functions:**

- [**py_type**](#openhands.sdk.tool.schema.py_type) – Map JSON schema types to Python types.

**Attributes:**

- [**Action**](#openhands.sdk.tool.schema.Action) – Type annotation for values that can be any implementation of ActionBase.
- [**Observation**](#openhands.sdk.tool.schema.Observation) – Type annotation for values that can be any implementation of ObservationBase.
- [**S**](#openhands.sdk.tool.schema.S) –

##### `openhands.sdk.tool.schema.Action`

```python
Action = Annotated[ActionBase, DiscriminatedUnionType[ActionBase]]
```

Type annotation for values that can be any implementation of ActionBase.

In most situations, this is equivalent to ActionBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.

##### `openhands.sdk.tool.schema.ActionBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for input action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.schema.ActionBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.schema.ActionBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.schema.ActionBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.schema.ActionBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.schema.ActionBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.schema.ActionBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.schema.ActionBase.model_config) –
- [**security_risk**](#openhands.sdk.tool.schema.ActionBase.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.schema.ActionBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.sdk.tool.schema.ActionBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.schema.ActionBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.schema.ActionBase.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.tool.schema.ActionBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.schema.ActionBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.schema.ActionBase.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.sdk.tool.schema.ActionBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.schema.ActionBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.schema.ActionBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

##### `openhands.sdk.tool.schema.MCPActionBase`

Bases: <code>[ActionBase](#openhands.sdk.tool.schema.ActionBase)</code>

Base schema for MCP input action.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.schema.MCPActionBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.schema.MCPActionBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.schema.MCPActionBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.schema.MCPActionBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_arguments**](#openhands.sdk.tool.schema.MCPActionBase.to_mcp_arguments) – Dump model excluding parent ActionBase fields.
- [**to_mcp_schema**](#openhands.sdk.tool.schema.MCPActionBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**kind**](#openhands.sdk.tool.schema.MCPActionBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.schema.MCPActionBase.model_config) –
- [**security_risk**](#openhands.sdk.tool.schema.MCPActionBase.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**visualize**](#openhands.sdk.tool.schema.MCPActionBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.sdk.tool.schema.MCPActionBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.schema.MCPActionBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.schema.MCPActionBase.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.sdk.tool.schema.MCPActionBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.schema.MCPActionBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.schema.MCPActionBase.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.sdk.tool.schema.MCPActionBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.schema.MCPActionBase.to_mcp_arguments`

```python
to_mcp_arguments()
```

Dump model excluding parent ActionBase fields.

This is used to convert this action to MCP tool call arguments.
The parent fields (e.g., safety_risk, kind) are not part of the MCP tool schema
but are only used for our internal processing.

###### `openhands.sdk.tool.schema.MCPActionBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.schema.MCPActionBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

##### `openhands.sdk.tool.schema.Observation`

```python
Observation = Annotated[ObservationBase, DiscriminatedUnionType[ObservationBase]]
```

Type annotation for values that can be any implementation of ObservationBase.

In most situations, this is equivalent to ObservationBase. However, when used in
Pydantic BaseModels as a field annotation, it enables polymorphic deserialization by
delaying the discriminator resolution until runtime.

##### `openhands.sdk.tool.schema.ObservationBase`

Bases: <code>[Schema](#openhands.sdk.tool.schema.Schema)</code>, <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>

Base schema for output observation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.schema.ObservationBase.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.sdk.tool.schema.ObservationBase.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.schema.ObservationBase.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.tool.schema.ObservationBase.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.sdk.tool.schema.ObservationBase.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.sdk.tool.schema.ObservationBase.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the observation string to show to the agent.
- [**kind**](#openhands.sdk.tool.schema.ObservationBase.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.sdk.tool.schema.ObservationBase.model_config) –
- [**visualize**](#openhands.sdk.tool.schema.ObservationBase.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.sdk.tool.schema.ObservationBase.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the observation string to show to the agent.

###### `openhands.sdk.tool.schema.ObservationBase.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.schema.ObservationBase.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.schema.ObservationBase.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.sdk.tool.schema.ObservationBase.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.schema.ObservationBase.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.schema.ObservationBase.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.schema.ObservationBase.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.sdk.tool.schema.ObservationBase.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

##### `openhands.sdk.tool.schema.S`

```python
S = TypeVar('S', bound='Schema')
```

##### `openhands.sdk.tool.schema.Schema`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Base schema for input action / output observation.

**Functions:**

- [**from_mcp_schema**](#openhands.sdk.tool.schema.Schema.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**to_mcp_schema**](#openhands.sdk.tool.schema.Schema.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**model_config**](#openhands.sdk.tool.schema.Schema.model_config) –

###### `openhands.sdk.tool.schema.Schema.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.sdk.tool.schema.Schema.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.sdk.tool.schema.Schema.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.sdk.tool.schema.py_type`

```python
py_type(spec)
```

Map JSON schema types to Python types.

#### `openhands.sdk.tool.security_prompt`

Security risk assessment constants for tools.

**Attributes:**

- [**SECURITY_RISK_DESC**](#openhands.sdk.tool.security_prompt.SECURITY_RISK_DESC) –
- [**SECURITY_RISK_LITERAL**](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL) –

##### `openhands.sdk.tool.security_prompt.SECURITY_RISK_DESC`

```python
SECURITY_RISK_DESC = "The LLM's assessment of the safety risk of this action."
```

##### `openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL`

```python
SECURITY_RISK_LITERAL = Literal['LOW', 'MEDIUM', 'HIGH', 'UNKNOWN']
```

#### `openhands.sdk.tool.tool`

Tool framework for defining and executing tools with validation.

**Classes:**

- [**Tool**](#openhands.sdk.tool.tool.Tool) – Tool that wraps an executor function with input/output validation and schema.
- [**ToolAnnotations**](#openhands.sdk.tool.tool.ToolAnnotations) – Annotations to provide hints about the tool's behavior.
- [**ToolExecutor**](#openhands.sdk.tool.tool.ToolExecutor) – Executor function type for a Tool.

**Attributes:**

- [**ActionT**](#openhands.sdk.tool.tool.ActionT) –
- [**ObservationT**](#openhands.sdk.tool.tool.ObservationT) –
- [**ToolType**](#openhands.sdk.tool.tool.ToolType) –

##### `openhands.sdk.tool.tool.ActionT`

```python
ActionT = TypeVar('ActionT', bound=ActionBase)
```

##### `openhands.sdk.tool.tool.ObservationT`

```python
ObservationT = TypeVar('ObservationT', bound=ObservationBase)
```

##### `openhands.sdk.tool.tool.Tool`

Bases: <code>[DiscriminatedUnionMixin](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin)</code>, <code>[Generic](#typing.Generic)\[[ActionT](#openhands.sdk.tool.tool.ActionT), [ObservationT](#openhands.sdk.tool.tool.ObservationT)\]</code>

Tool that wraps an executor function with input/output validation and schema.

- Normalize input/output schemas (class or dict) into both model+schema.
- Validate inputs before execute.
- Coerce outputs only if an output model is defined; else return vanilla JSON.
- Export MCP tool description.

**Functions:**

- [**call**](#openhands.sdk.tool.tool.Tool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.sdk.tool.tool.Tool.create) – Create a Tool instance. Placeholder for subclasses.
- [**model_validate**](#openhands.sdk.tool.tool.Tool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.tool.tool.Tool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.sdk.tool.tool.Tool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.sdk.tool.tool.Tool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.sdk.tool.tool.Tool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.sdk.tool.tool.Tool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.sdk.tool.tool.Tool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.sdk.tool.tool.Tool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.sdk.tool.tool.Tool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.sdk.tool.tool.Tool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.sdk.tool.tool.Tool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.sdk.tool.tool.Tool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.sdk.tool.tool.Tool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.sdk.tool.tool.Tool.model_config) –
- [**name**](#openhands.sdk.tool.tool.Tool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.sdk.tool.tool.Tool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.sdk.tool.tool.Tool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.sdk.tool.tool.Tool.title) (<code>[str](#str)</code>) – Get the title for the tool.

###### `openhands.sdk.tool.tool.Tool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

###### `openhands.sdk.tool.tool.Tool.annotations`

```python
annotations: ToolAnnotations | None = None
```

###### `openhands.sdk.tool.tool.Tool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

###### `openhands.sdk.tool.tool.Tool.create`

```python
create(*args, **kwargs)
```

Create a Tool instance. Placeholder for subclasses.

This can be overridden in subclasses to provide custom initialization logic
(e.g., typically initializing the executor with parameters).

###### `openhands.sdk.tool.tool.Tool.description`

```python
description: str
```

###### `openhands.sdk.tool.tool.Tool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.sdk.tool.tool.Tool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

###### `openhands.sdk.tool.tool.Tool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.tool.tool.Tool.meta`

```python
meta: dict[str, Any] | None = None
```

###### `openhands.sdk.tool.tool.Tool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.sdk.tool.tool.Tool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.tool.tool.Tool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.tool.tool.Tool.name`

```python
name: str
```

###### `openhands.sdk.tool.tool.Tool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

###### `openhands.sdk.tool.tool.Tool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

###### `openhands.sdk.tool.tool.Tool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

###### `openhands.sdk.tool.tool.Tool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.sdk.tool.tool.Tool.title`

```python
title: str
```

Get the title for the tool.

###### `openhands.sdk.tool.tool.Tool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

###### `openhands.sdk.tool.tool.Tool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

##### `openhands.sdk.tool.tool.ToolAnnotations`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Annotations to provide hints about the tool's behavior.

Based on Model Context Protocol (MCP) spec:
https://github.com/modelcontextprotocol/modelcontextprotocol/blob/caf3424488b10b4a7b1f8cb634244a450a1f4400/schema/2025-06-18/schema.ts#L838

**Attributes:**

- [**destructiveHint**](#openhands.sdk.tool.tool.ToolAnnotations.destructiveHint) (<code>[bool](#bool)</code>) –
- [**idempotentHint**](#openhands.sdk.tool.tool.ToolAnnotations.idempotentHint) (<code>[bool](#bool)</code>) –
- [**openWorldHint**](#openhands.sdk.tool.tool.ToolAnnotations.openWorldHint) (<code>[bool](#bool)</code>) –
- [**readOnlyHint**](#openhands.sdk.tool.tool.ToolAnnotations.readOnlyHint) (<code>[bool](#bool)</code>) –
- [**title**](#openhands.sdk.tool.tool.ToolAnnotations.title) (<code>[str](#str) | None</code>) –

###### `openhands.sdk.tool.tool.ToolAnnotations.destructiveHint`

```python
destructiveHint: bool = Field(default=True, description='If true, the tool may perform destructive updates to its environment. If false, the tool performs only additive updates. (This property is meaningful only when `readOnlyHint == false`) Default: true')
```

###### `openhands.sdk.tool.tool.ToolAnnotations.idempotentHint`

```python
idempotentHint: bool = Field(default=False, description='If true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment. (This property is meaningful only when `readOnlyHint == false`) Default: false')
```

###### `openhands.sdk.tool.tool.ToolAnnotations.openWorldHint`

```python
openWorldHint: bool = Field(default=True, description="If true, this tool may interact with an 'open world' of external entities. If false, the tool's domain of interaction is closed. For example, the world of a web search tool is open, whereas that of a memory tool is not. Default: true")
```

###### `openhands.sdk.tool.tool.ToolAnnotations.readOnlyHint`

```python
readOnlyHint: bool = Field(default=False, description='If true, the tool does not modify its environment. Default: false')
```

###### `openhands.sdk.tool.tool.ToolAnnotations.title`

```python
title: str | None = Field(default=None, description='A human-readable title for the tool.')
```

##### `openhands.sdk.tool.tool.ToolExecutor`

Bases: <code>[Generic](#typing.Generic)\[[ActionT](#openhands.sdk.tool.tool.ActionT), [ObservationT](#openhands.sdk.tool.tool.ObservationT)\]</code>

Executor function type for a Tool.

**Functions:**

- [**close**](#openhands.sdk.tool.tool.ToolExecutor.close) – Close the executor and clean up resources.

###### `openhands.sdk.tool.tool.ToolExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.sdk.tool.tool.ToolType`

```python
ToolType = Annotated[Tool[ActionT, ObservationT], DiscriminatedUnionType[Tool]]
```

### `openhands.sdk.utils`

Utility functions for the OpenHands SDK.

**Modules:**

- [**discriminated_union**](#openhands.sdk.utils.discriminated_union) – Utility for creating and managing discriminated unions of Pydantic models.
- [**json**](#openhands.sdk.utils.json) – JSON utilities with custom encoding for OpenHands objects.
- [**protocol**](#openhands.sdk.utils.protocol) –
- [**pydantic_diff**](#openhands.sdk.utils.pydantic_diff) – Utilities for computing and formatting diffs between Pydantic models.
- [**truncate**](#openhands.sdk.utils.truncate) – Utility functions for truncating text content.

**Classes:**

- [**ListLike**](#openhands.sdk.utils.ListLike) –

**Functions:**

- [**maybe_truncate**](#openhands.sdk.utils.maybe_truncate) – Truncate the middle of content if it exceeds the specified length.

**Attributes:**

- [**DEFAULT_TEXT_CONTENT_LIMIT**](#openhands.sdk.utils.DEFAULT_TEXT_CONTENT_LIMIT) –
- [**DEFAULT_TRUNCATE_NOTICE**](#openhands.sdk.utils.DEFAULT_TRUNCATE_NOTICE) –

#### `openhands.sdk.utils.DEFAULT_TEXT_CONTENT_LIMIT`

```python
DEFAULT_TEXT_CONTENT_LIMIT = 50000
```

#### `openhands.sdk.utils.DEFAULT_TRUNCATE_NOTICE`

```python
DEFAULT_TRUNCATE_NOTICE = '<response clipped><NOTE>Due to the max output limit, only part of the full response has been shown to you.</NOTE>'
```

#### `openhands.sdk.utils.ListLike`

Bases: <code>[Protocol](#typing.Protocol)\[[T](#openhands.sdk.utils.protocol.T)\]</code>

**Functions:**

- [**append**](#openhands.sdk.utils.ListLike.append) –

##### `openhands.sdk.utils.ListLike.append`

```python
append(__object)
```

#### `openhands.sdk.utils.discriminated_union`

Utility for creating and managing discriminated unions of Pydantic models.

Pydantic provides native support for disciriminated unions via the `Union` type and
the `discriminator` argument to `Field`. However, this requires that all possible
types in the union be known at the time the field is defined. This can be limiting
in scenarios where new types may be defined later.

To address this, we provide a `DiscriminatedUnionMixin` base class that models can
inherit from to automatically register themselves as part of a discriminated union.
We also provide a `DiscriminatedUnionType` type wrapper that can be used in Pydantic
models to indicate that a field should be treated as a discriminated union of all
subclasses of a given base class.

Importantly, this approach allows us to _delay_ the resolution of the union types
until validation time, meaning that new subclasses can be defined and registered
at any time before validation occurs.

Example usage:

```
from typing import Annotated
from pydantic import BaseModel

from openhands.sdk.utils.discriminated_union import (
    DiscriminatedUnionMixin,
    DiscriminatedUnionType
)

# The base class for the union is tagged with DiscriminatedUnionMixin
class Animal(BaseModel, DiscriminatedUnionMixin):
    name: str

# We develop a special type to represent the discriminated union of all Animals.
# This acts just like Animal, but the annotation tells Pydantic to treat it as a
# discriminated union of all subclasses of Animal (defined so far or in the future).
AnyAnimal = Annotated[Animal, DiscriminatedUnionType[Animal]]

class Dog(Animal):
    breed: str

class Cat(Animal):
    color: str

class Zoo(BaseModel):
    residents: list[AnyAnimal]

# Even animals defined after the Zoo class can be included without issue
class Mouse(Animal):
    size: str

zoo = Zoo(residents=[
    Dog(name="Fido", breed="Labrador"),
    Cat(name="Whiskers", color="Tabby"),
    Mouse(name="Jerry", size="Small")
])

serialized_zoo = zoo.model_dump_json()
deserialized_zoo = Zoo.model_validate_json(serialized_zoo)

assert zoo == deserialized_zoo
```

**Classes:**

- [**DiscriminatedUnionMixin**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin) – A Base class for members of tagged unions discriminated by the class name.
- [**DiscriminatedUnionType**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionType) – A type wrapper that enables discriminated union validation for Pydantic fields.

**Functions:**

- [**kind_of**](#openhands.sdk.utils.discriminated_union.kind_of) – Get the kind string for a given class.
- [**resolve_kind**](#openhands.sdk.utils.discriminated_union.resolve_kind) – Resolve a kind string back to the corresponding class.

**Attributes:**

- [**T**](#openhands.sdk.utils.discriminated_union.T) –

##### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

A Base class for members of tagged unions discriminated by the class name.

This class provides automatic subclass registration and discriminated union
functionality. Each subclass is automatically registered when defined and
can be used for polymorphic serialization/deserialization.

Child classes will automatically have a type field defined, which is used as a
discriminator for union types.

**Functions:**

- [**model_validate**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.target_subclass) – Get the subclass corresponding to a given kind name.

**Attributes:**

- [**kind**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.

###### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionMixin.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionType`

```python
DiscriminatedUnionType(cls)
```

Bases: <code>[Generic](#typing.Generic)\[[T](#openhands.sdk.utils.discriminated_union.T)\]</code>

A type wrapper that enables discriminated union validation for Pydantic fields.

The wrapped type must be a subclass of `DiscriminatedUnionMixin`.

**Attributes:**

- [**base_class**](#openhands.sdk.utils.discriminated_union.DiscriminatedUnionType.base_class) –

Initialize DiscriminatedUnion with base class.

###### `openhands.sdk.utils.discriminated_union.DiscriminatedUnionType.base_class`

```python
base_class = cls
```

##### `openhands.sdk.utils.discriminated_union.T`

```python
T = TypeVar('T', bound='DiscriminatedUnionMixin')
```

##### `openhands.sdk.utils.discriminated_union.kind_of`

```python
kind_of(t)
```

Get the kind string for a given class.

##### `openhands.sdk.utils.discriminated_union.resolve_kind`

```python
resolve_kind(kind)
```

Resolve a kind string back to the corresponding class.

#### `openhands.sdk.utils.json`

JSON utilities with custom encoding for OpenHands objects.

**Classes:**

- [**OpenHandsJSONEncoder**](#openhands.sdk.utils.json.OpenHandsJSONEncoder) – Custom JSON encoder that handles datetime and other OH objects.

**Functions:**

- [**dumps**](#openhands.sdk.utils.json.dumps) – Serialize an object to JSON string format.
- [**loads**](#openhands.sdk.utils.json.loads) – Parse a JSON string and return the corresponding Python object.

##### `openhands.sdk.utils.json.OpenHandsJSONEncoder`

Bases: <code>[JSONEncoder](#json.JSONEncoder)</code>

Custom JSON encoder that handles datetime and other OH objects.

**Functions:**

- [**default**](#openhands.sdk.utils.json.OpenHandsJSONEncoder.default) – Handle serialization of custom objects.

###### `openhands.sdk.utils.json.OpenHandsJSONEncoder.default`

```python
default(o)
```

Handle serialization of custom objects.

##### `openhands.sdk.utils.json.dumps`

```python
dumps(obj, **kwargs)
```

Serialize an object to JSON string format.

##### `openhands.sdk.utils.json.loads`

```python
loads(json_str, **kwargs)
```

Parse a JSON string and return the corresponding Python object.

#### `openhands.sdk.utils.maybe_truncate`

```python
maybe_truncate(content, truncate_after=None, truncate_notice=DEFAULT_TRUNCATE_NOTICE)
```

Truncate the middle of content if it exceeds the specified length.

Keeps the head and tail of the content to preserve context at both ends.

**Parameters:**

- **content** (<code>[str](#str)</code>) – The text content to potentially truncate
- **truncate_after** (<code>[int](#int) | None</code>) – Maximum length before truncation. If None, no truncation occurs
- **truncate_notice** (<code>[str](#str)</code>) – Notice to insert in the middle when content is truncated

**Returns:**

- <code>[str](#str)</code> – Original content if under limit, or truncated content with head and tail
- <code>[str](#str)</code> – preserved

#### `openhands.sdk.utils.protocol`

**Classes:**

- [**ListLike**](#openhands.sdk.utils.protocol.ListLike) –

**Attributes:**

- [**T**](#openhands.sdk.utils.protocol.T) –

##### `openhands.sdk.utils.protocol.ListLike`

Bases: <code>[Protocol](#typing.Protocol)\[[T](#openhands.sdk.utils.protocol.T)\]</code>

**Functions:**

- [**append**](#openhands.sdk.utils.protocol.ListLike.append) –

###### `openhands.sdk.utils.protocol.ListLike.append`

```python
append(__object)
```

##### `openhands.sdk.utils.protocol.T`

```python
T = TypeVar('T')
```

#### `openhands.sdk.utils.pydantic_diff`

Utilities for computing and formatting diffs between Pydantic models.

**Functions:**

- [**pretty_pydantic_diff**](#openhands.sdk.utils.pydantic_diff.pretty_pydantic_diff) – Generate a pretty-printed diff between two Pydantic models.

##### `openhands.sdk.utils.pydantic_diff.pretty_pydantic_diff`

```python
pretty_pydantic_diff(a, b)
```

Generate a pretty-printed diff between two Pydantic models.

#### `openhands.sdk.utils.truncate`

Utility functions for truncating text content.

**Functions:**

- [**maybe_truncate**](#openhands.sdk.utils.truncate.maybe_truncate) – Truncate the middle of content if it exceeds the specified length.

**Attributes:**

- [**DEFAULT_TEXT_CONTENT_LIMIT**](#openhands.sdk.utils.truncate.DEFAULT_TEXT_CONTENT_LIMIT) –
- [**DEFAULT_TRUNCATE_NOTICE**](#openhands.sdk.utils.truncate.DEFAULT_TRUNCATE_NOTICE) –

##### `openhands.sdk.utils.truncate.DEFAULT_TEXT_CONTENT_LIMIT`

```python
DEFAULT_TEXT_CONTENT_LIMIT = 50000
```

##### `openhands.sdk.utils.truncate.DEFAULT_TRUNCATE_NOTICE`

```python
DEFAULT_TRUNCATE_NOTICE = '<response clipped><NOTE>Due to the max output limit, only part of the full response has been shown to you.</NOTE>'
```

##### `openhands.sdk.utils.truncate.maybe_truncate`

```python
maybe_truncate(content, truncate_after=None, truncate_notice=DEFAULT_TRUNCATE_NOTICE)
```

Truncate the middle of content if it exceeds the specified length.

Keeps the head and tail of the content to preserve context at both ends.

**Parameters:**

- **content** (<code>[str](#str)</code>) – The text content to potentially truncate
- **truncate_after** (<code>[int](#int) | None</code>) – Maximum length before truncation. If None, no truncation occurs
- **truncate_notice** (<code>[str](#str)</code>) – Notice to insert in the middle when content is truncated

**Returns:**

- <code>[str](#str)</code> – Original content if under limit, or truncated content with head and tail
- <code>[str](#str)</code> – preserved
