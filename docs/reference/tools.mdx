## `openhands.tools`

Runtime tools package.

**Modules:**

- [**execute_bash**](#openhands.tools.execute_bash) – Bash execution tool for running shell commands.
- [**str_replace_editor**](#openhands.tools.str_replace_editor) – String replace editor tool for file editing operations.
- [**task_tracker**](#openhands.tools.task_tracker) – Task tracker tool for managing development tasks.
- [**utils**](#openhands.tools.utils) – Shared utilities.

**Classes:**

- [**BashExecutor**](#openhands.tools.BashExecutor) – Executor for bash commands using terminal sessions.
- [**BashTool**](#openhands.tools.BashTool) – A Tool subclass that automatically initializes a BashExecutor with auto-detection.
- [**ExecuteBashAction**](#openhands.tools.ExecuteBashAction) – Schema for bash command execution.
- [**ExecuteBashObservation**](#openhands.tools.ExecuteBashObservation) – A ToolResult that can be rendered as a CLI output.
- [**FileEditorExecutor**](#openhands.tools.FileEditorExecutor) – Executor for file editor operations.
- [**FileEditorTool**](#openhands.tools.FileEditorTool) – A Tool subclass that automatically initializes a FileEditorExecutor.
- [**StrReplaceEditorAction**](#openhands.tools.StrReplaceEditorAction) – Schema for string replace editor operations.
- [**StrReplaceEditorObservation**](#openhands.tools.StrReplaceEditorObservation) – A ToolResult that can be rendered as a CLI output.
- [**TaskTrackerAction**](#openhands.tools.TaskTrackerAction) – An action where the agent writes or updates a task list for task management.
- [**TaskTrackerExecutor**](#openhands.tools.TaskTrackerExecutor) – Executor for the task tracker tool.
- [**TaskTrackerObservation**](#openhands.tools.TaskTrackerObservation) – Data class representing the result of a task tracking operation.
- [**TaskTrackerTool**](#openhands.tools.TaskTrackerTool) – A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Attributes:**

- [**execute_bash_tool**](#openhands.tools.execute_bash_tool) –
- [**str_replace_editor_tool**](#openhands.tools.str_replace_editor_tool) –
- [**task_tracker_tool**](#openhands.tools.task_tracker_tool) –

### `openhands.tools.BashExecutor`

```python
BashExecutor(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for bash commands using terminal sessions.

**Functions:**

- [**close**](#openhands.tools.BashExecutor.close) – Close the terminal session and clean up resources.

**Attributes:**

- [**session**](#openhands.tools.BashExecutor.session) –

Initialize BashExecutor with auto-detected or specified session type.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – Working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities

#### `openhands.tools.BashExecutor.close`

```python
close()
```

Close the terminal session and clean up resources.

#### `openhands.tools.BashExecutor.session`

```python
session = create_terminal_session(work_dir=working_dir, username=username, no_change_timeout_seconds=no_change_timeout_seconds, terminal_type=terminal_type)
```

### `openhands.tools.BashTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[ExecuteBashAction](#openhands.tools.execute_bash.definition.ExecuteBashAction), [ExecuteBashObservation](#openhands.tools.execute_bash.definition.ExecuteBashObservation)\]</code>

A Tool subclass that automatically initializes a BashExecutor with auto-detection.

**Functions:**

- [**call**](#openhands.tools.BashTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.BashTool.create) – Initialize BashTool with executor parameters.
- [**model_validate**](#openhands.tools.BashTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.BashTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.BashTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.BashTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.BashTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.BashTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.BashTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.BashTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.BashTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.BashTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.BashTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.BashTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.BashTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.BashTool.model_config) –
- [**name**](#openhands.tools.BashTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.BashTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.BashTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.BashTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

#### `openhands.tools.BashTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

#### `openhands.tools.BashTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

#### `openhands.tools.BashTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

#### `openhands.tools.BashTool.create`

```python
create(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Initialize BashTool with executor parameters.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – The working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities:
  \- On Windows: PowerShell if available, otherwise subprocess
  \- On Unix-like: tmux if available, otherwise subprocess

#### `openhands.tools.BashTool.description`

```python
description: str
```

#### `openhands.tools.BashTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.tools.BashTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

#### `openhands.tools.BashTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.BashTool.meta`

```python
meta: dict[str, Any] | None = None
```

#### `openhands.tools.BashTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.tools.BashTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.BashTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.BashTool.name`

```python
name: str
```

#### `openhands.tools.BashTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

#### `openhands.tools.BashTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

#### `openhands.tools.BashTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

#### `openhands.tools.BashTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.BashTool.title`

```python
title: str
```

Get the title for the tool.

#### `openhands.tools.BashTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

#### `openhands.tools.BashTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

### `openhands.tools.ExecuteBashAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for bash command execution.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.ExecuteBashAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.ExecuteBashAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.ExecuteBashAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.ExecuteBashAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.ExecuteBashAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.ExecuteBashAction.command) (<code>[str](#str)</code>) –
- [**is_input**](#openhands.tools.ExecuteBashAction.is_input) (<code>[bool](#bool)</code>) –
- [**kind**](#openhands.tools.ExecuteBashAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.ExecuteBashAction.model_config) –
- [**security_risk**](#openhands.tools.ExecuteBashAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**timeout**](#openhands.tools.ExecuteBashAction.timeout) (<code>[float](#float) | None</code>) –
- [**visualize**](#openhands.tools.ExecuteBashAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with PS1-style bash prompt.

#### `openhands.tools.ExecuteBashAction.command`

```python
command: str = Field(description='The bash command to execute. Can be empty string to view additional logs when previous exit code is `-1`. Can be `C-c` (Ctrl+C) to interrupt the currently running process. Note: You can only execute one bash command at a time. If you need to run multiple commands sequentially, you can use `&&` or `;` to chain them together.')
```

#### `openhands.tools.ExecuteBashAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.ExecuteBashAction.is_input`

```python
is_input: bool = Field(default=False, description='If True, the command is an input to the running process. If False, the command is a bash command to be executed in the terminal. Default is False.')
```

#### `openhands.tools.ExecuteBashAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.ExecuteBashAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.tools.ExecuteBashAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.ExecuteBashAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.ExecuteBashAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

#### `openhands.tools.ExecuteBashAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.ExecuteBashAction.timeout`

```python
timeout: float | None = Field(default=None, description=f'Optional. Sets a maximum time limit (in seconds) for running the command. If the command takes longer than this limit, you’ll be asked whether to continue or stop it. If you don’t set a value, the command will instead pause and ask for confirmation when it produces no new output for {NO_CHANGE_TIMEOUT_SECONDS} seconds. Use a higher value if the command is expected to take a long time (like installation or testing), or if it has a known fixed duration (like sleep).')
```

#### `openhands.tools.ExecuteBashAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.ExecuteBashAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with PS1-style bash prompt.

### `openhands.tools.ExecuteBashObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.ExecuteBashObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.ExecuteBashObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.ExecuteBashObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.ExecuteBashObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.ExecuteBashObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.ExecuteBashObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with formatted output and metadata.
- [**command**](#openhands.tools.ExecuteBashObservation.command) (<code>[str](#str) | None</code>) –
- [**command_id**](#openhands.tools.ExecuteBashObservation.command_id) (<code>[int](#int) | None</code>) – Get the command ID from metadata.
- [**error**](#openhands.tools.ExecuteBashObservation.error) (<code>[bool](#bool)</code>) –
- [**exit_code**](#openhands.tools.ExecuteBashObservation.exit_code) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.ExecuteBashObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**metadata**](#openhands.tools.ExecuteBashObservation.metadata) (<code>[CmdOutputMetadata](#openhands.tools.execute_bash.metadata.CmdOutputMetadata)</code>) –
- [**model_config**](#openhands.tools.ExecuteBashObservation.model_config) –
- [**output**](#openhands.tools.ExecuteBashObservation.output) (<code>[str](#str)</code>) –
- [**timeout**](#openhands.tools.ExecuteBashObservation.timeout) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.ExecuteBashObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with terminal-style output formatting.

#### `openhands.tools.ExecuteBashObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with formatted output and metadata.

#### `openhands.tools.ExecuteBashObservation.command`

```python
command: str | None = Field(default=None, description='The bash command that was executed. Can be empty string if the observation is from a previous command that hit soft timeout and is not yet finished.')
```

#### `openhands.tools.ExecuteBashObservation.command_id`

```python
command_id: int | None
```

Get the command ID from metadata.

#### `openhands.tools.ExecuteBashObservation.error`

```python
error: bool = Field(default=False, description='Whether there was an error during command execution.')
```

#### `openhands.tools.ExecuteBashObservation.exit_code`

```python
exit_code: int | None = Field(default=None, description='The exit code of the command. -1 indicates the process hit the soft timeout and is not yet finished.')
```

#### `openhands.tools.ExecuteBashObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.ExecuteBashObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.ExecuteBashObservation.metadata`

```python
metadata: CmdOutputMetadata = Field(default_factory=CmdOutputMetadata, description='Additional metadata captured from PS1 after command execution.')
```

#### `openhands.tools.ExecuteBashObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

#### `openhands.tools.ExecuteBashObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.ExecuteBashObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.ExecuteBashObservation.output`

```python
output: str = Field(description='The raw output from the tool.')
```

#### `openhands.tools.ExecuteBashObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.ExecuteBashObservation.timeout`

```python
timeout: bool = Field(default=False, description='Whether the command execution timed out.')
```

#### `openhands.tools.ExecuteBashObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.ExecuteBashObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with terminal-style output formatting.

### `openhands.tools.FileEditorExecutor`

```python
FileEditorExecutor(workspace_root=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for file editor operations.

**Functions:**

- [**close**](#openhands.tools.FileEditorExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**editor**](#openhands.tools.FileEditorExecutor.editor) –

Initialize the file editor executor.

#### `openhands.tools.FileEditorExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

#### `openhands.tools.FileEditorExecutor.editor`

```python
editor = FileEditor(workspace_root=workspace_root)
```

### `openhands.tools.FileEditorTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[StrReplaceEditorAction](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction), [StrReplaceEditorObservation](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation)\]</code>

A Tool subclass that automatically initializes a FileEditorExecutor.

**Functions:**

- [**call**](#openhands.tools.FileEditorTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.FileEditorTool.create) – Initialize FileEditorTool with a FileEditorExecutor.
- [**model_validate**](#openhands.tools.FileEditorTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.FileEditorTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.FileEditorTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.FileEditorTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.FileEditorTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.FileEditorTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.FileEditorTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.FileEditorTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.FileEditorTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.FileEditorTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.FileEditorTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.FileEditorTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.FileEditorTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.FileEditorTool.model_config) –
- [**name**](#openhands.tools.FileEditorTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.FileEditorTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.FileEditorTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.FileEditorTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

#### `openhands.tools.FileEditorTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

#### `openhands.tools.FileEditorTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

#### `openhands.tools.FileEditorTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

#### `openhands.tools.FileEditorTool.create`

```python
create(workspace_root=None)
```

Initialize FileEditorTool with a FileEditorExecutor.

#### `openhands.tools.FileEditorTool.description`

```python
description: str
```

#### `openhands.tools.FileEditorTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.tools.FileEditorTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

#### `openhands.tools.FileEditorTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.FileEditorTool.meta`

```python
meta: dict[str, Any] | None = None
```

#### `openhands.tools.FileEditorTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.tools.FileEditorTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.FileEditorTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.FileEditorTool.name`

```python
name: str
```

#### `openhands.tools.FileEditorTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

#### `openhands.tools.FileEditorTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

#### `openhands.tools.FileEditorTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

#### `openhands.tools.FileEditorTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.FileEditorTool.title`

```python
title: str
```

Get the title for the tool.

#### `openhands.tools.FileEditorTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

#### `openhands.tools.FileEditorTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

### `openhands.tools.StrReplaceEditorAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for string replace editor operations.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.StrReplaceEditorAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.StrReplaceEditorAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.StrReplaceEditorAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.StrReplaceEditorAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.StrReplaceEditorAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.StrReplaceEditorAction.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**file_text**](#openhands.tools.StrReplaceEditorAction.file_text) (<code>[str](#str) | None</code>) –
- [**insert_line**](#openhands.tools.StrReplaceEditorAction.insert_line) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.StrReplaceEditorAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.StrReplaceEditorAction.model_config) –
- [**new_str**](#openhands.tools.StrReplaceEditorAction.new_str) (<code>[str](#str) | None</code>) –
- [**old_str**](#openhands.tools.StrReplaceEditorAction.old_str) (<code>[str](#str) | None</code>) –
- [**path**](#openhands.tools.StrReplaceEditorAction.path) (<code>[str](#str)</code>) –
- [**security_risk**](#openhands.tools.StrReplaceEditorAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**view_range**](#openhands.tools.StrReplaceEditorAction.view_range) (<code>[list](#list)\[[int](#int)\] | None</code>) –
- [**visualize**](#openhands.tools.StrReplaceEditorAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

#### `openhands.tools.StrReplaceEditorAction.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

#### `openhands.tools.StrReplaceEditorAction.file_text`

```python
file_text: str | None = Field(default=None, description='Required parameter of `create` command, with the content of the file to be created.')
```

#### `openhands.tools.StrReplaceEditorAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.StrReplaceEditorAction.insert_line`

```python
insert_line: int | None = Field(default=None, description='Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.')
```

#### `openhands.tools.StrReplaceEditorAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.StrReplaceEditorAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.tools.StrReplaceEditorAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.StrReplaceEditorAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.StrReplaceEditorAction.new_str`

```python
new_str: str | None = Field(default=None, description='Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert.')
```

#### `openhands.tools.StrReplaceEditorAction.old_str`

```python
old_str: str | None = Field(default=None, description='Required parameter of `str_replace` command containing the string in `path` to replace.')
```

#### `openhands.tools.StrReplaceEditorAction.path`

```python
path: str = Field(description='Absolute path to file or directory, e.g. `/workspace/file.py` or `/workspace`.')
```

#### `openhands.tools.StrReplaceEditorAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

#### `openhands.tools.StrReplaceEditorAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.StrReplaceEditorAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.StrReplaceEditorAction.view_range`

```python
view_range: list[int] | None = Field(default=None, description='Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.')
```

#### `openhands.tools.StrReplaceEditorAction.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

### `openhands.tools.StrReplaceEditorObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.StrReplaceEditorObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.StrReplaceEditorObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.StrReplaceEditorObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.StrReplaceEditorObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.StrReplaceEditorObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.StrReplaceEditorObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with output or error message.
- [**command**](#openhands.tools.StrReplaceEditorObservation.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**error**](#openhands.tools.StrReplaceEditorObservation.error) (<code>[str](#str) | None</code>) –
- [**kind**](#openhands.tools.StrReplaceEditorObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.StrReplaceEditorObservation.model_config) –
- [**new_content**](#openhands.tools.StrReplaceEditorObservation.new_content) (<code>[str](#str) | None</code>) –
- [**old_content**](#openhands.tools.StrReplaceEditorObservation.old_content) (<code>[str](#str) | None</code>) –
- [**output**](#openhands.tools.StrReplaceEditorObservation.output) (<code>[str](#str)</code>) –
- [**path**](#openhands.tools.StrReplaceEditorObservation.path) (<code>[str](#str) | None</code>) –
- [**prev_exist**](#openhands.tools.StrReplaceEditorObservation.prev_exist) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.StrReplaceEditorObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this observation.

#### `openhands.tools.StrReplaceEditorObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with output or error message.

#### `openhands.tools.StrReplaceEditorObservation.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

#### `openhands.tools.StrReplaceEditorObservation.error`

```python
error: str | None = Field(default=None, description='Error message if any.')
```

#### `openhands.tools.StrReplaceEditorObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.StrReplaceEditorObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.StrReplaceEditorObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

#### `openhands.tools.StrReplaceEditorObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.StrReplaceEditorObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.StrReplaceEditorObservation.new_content`

```python
new_content: str | None = Field(default=None, description='The content of the file after the edit.')
```

#### `openhands.tools.StrReplaceEditorObservation.old_content`

```python
old_content: str | None = Field(default=None, description='The content of the file before the edit.')
```

#### `openhands.tools.StrReplaceEditorObservation.output`

```python
output: str = Field(default='', description='The output message from the tool for the LLM to see.')
```

#### `openhands.tools.StrReplaceEditorObservation.path`

```python
path: str | None = Field(default=None, description='The file path that was edited.')
```

#### `openhands.tools.StrReplaceEditorObservation.prev_exist`

```python
prev_exist: bool = Field(default=True, description='Indicates if the file previously existed. If not, it was created.')
```

#### `openhands.tools.StrReplaceEditorObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.StrReplaceEditorObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.StrReplaceEditorObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this observation.

Shows diff visualization for meaningful changes (file creation, successful
edits), otherwise falls back to agent observation.

### `openhands.tools.TaskTrackerAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

An action where the agent writes or updates a task list for task management.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.TaskTrackerAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.TaskTrackerAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.TaskTrackerAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.TaskTrackerAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.TaskTrackerAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.TaskTrackerAction.command) (<code>[Literal](#typing.Literal)['view', 'plan']</code>) –
- [**kind**](#openhands.tools.TaskTrackerAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.TaskTrackerAction.model_config) –
- [**security_risk**](#openhands.tools.TaskTrackerAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**task_list**](#openhands.tools.TaskTrackerAction.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.TaskTrackerAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task management styling.

#### `openhands.tools.TaskTrackerAction.command`

```python
command: Literal['view', 'plan'] = Field(default='view', description='The command to execute. `view` shows the current task list. `plan` creates or updates the task list based on provided requirements and progress. Always `view` the current list before making changes.')
```

#### `openhands.tools.TaskTrackerAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.TaskTrackerAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.TaskTrackerAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

#### `openhands.tools.TaskTrackerAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.TaskTrackerAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.TaskTrackerAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

#### `openhands.tools.TaskTrackerAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.TaskTrackerAction.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The full task list. Required parameter of `plan` command.')
```

#### `openhands.tools.TaskTrackerAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.TaskTrackerAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with task management styling.

### `openhands.tools.TaskTrackerExecutor`

```python
TaskTrackerExecutor(save_dir=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for the task tracker tool.

**Functions:**

- [**close**](#openhands.tools.TaskTrackerExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**save_dir**](#openhands.tools.TaskTrackerExecutor.save_dir) –

Initialize TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.md

#### `openhands.tools.TaskTrackerExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

#### `openhands.tools.TaskTrackerExecutor.save_dir`

```python
save_dir = Path(save_dir) if save_dir else None
```

### `openhands.tools.TaskTrackerObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

Data class representing the result of a task tracking operation.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.TaskTrackerObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.TaskTrackerObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.TaskTrackerObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.TaskTrackerObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.TaskTrackerObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.TaskTrackerObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.TextContent) | [ImageContent](#openhands.sdk.ImageContent)\]</code>) – Return the observation content for the agent.
- [**command**](#openhands.tools.TaskTrackerObservation.command) (<code>[str](#str)</code>) –
- [**content**](#openhands.tools.TaskTrackerObservation.content) (<code>[str](#str)</code>) –
- [**kind**](#openhands.tools.TaskTrackerObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.TaskTrackerObservation.model_config) –
- [**task_list**](#openhands.tools.TaskTrackerObservation.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.TaskTrackerObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task list formatting.

#### `openhands.tools.TaskTrackerObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return the observation content for the agent.

#### `openhands.tools.TaskTrackerObservation.command`

```python
command: str = Field(default='', description='The command that was executed')
```

#### `openhands.tools.TaskTrackerObservation.content`

```python
content: str = Field(default='', description='The formatted task list or status message')
```

#### `openhands.tools.TaskTrackerObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

#### `openhands.tools.TaskTrackerObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.TaskTrackerObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

#### `openhands.tools.TaskTrackerObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.TaskTrackerObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.TaskTrackerObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.TaskTrackerObservation.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The current task list')
```

#### `openhands.tools.TaskTrackerObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

#### `openhands.tools.TaskTrackerObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with task list formatting.

### `openhands.tools.TaskTrackerTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[TaskTrackerAction](#openhands.tools.task_tracker.definition.TaskTrackerAction), [TaskTrackerObservation](#openhands.tools.task_tracker.definition.TaskTrackerObservation)\]</code>

A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Functions:**

- [**call**](#openhands.tools.TaskTrackerTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.TaskTrackerTool.create) – Initialize TaskTrackerTool with a TaskTrackerExecutor.
- [**model_validate**](#openhands.tools.TaskTrackerTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.TaskTrackerTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.TaskTrackerTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.TaskTrackerTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.TaskTrackerTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.TaskTrackerTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.TaskTrackerTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.TaskTrackerTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.TaskTrackerTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.TaskTrackerTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.TaskTrackerTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.TaskTrackerTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.TaskTrackerTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.TaskTrackerTool.model_config) –
- [**name**](#openhands.tools.TaskTrackerTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.TaskTrackerTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.TaskTrackerTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.TaskTrackerTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

#### `openhands.tools.TaskTrackerTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

#### `openhands.tools.TaskTrackerTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

#### `openhands.tools.TaskTrackerTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

#### `openhands.tools.TaskTrackerTool.create`

```python
create(save_dir=None)
```

Initialize TaskTrackerTool with a TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.json

#### `openhands.tools.TaskTrackerTool.description`

```python
description: str
```

#### `openhands.tools.TaskTrackerTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

#### `openhands.tools.TaskTrackerTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

#### `openhands.tools.TaskTrackerTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

#### `openhands.tools.TaskTrackerTool.meta`

```python
meta: dict[str, Any] | None = None
```

#### `openhands.tools.TaskTrackerTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

#### `openhands.tools.TaskTrackerTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

#### `openhands.tools.TaskTrackerTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

#### `openhands.tools.TaskTrackerTool.name`

```python
name: str
```

#### `openhands.tools.TaskTrackerTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

#### `openhands.tools.TaskTrackerTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

#### `openhands.tools.TaskTrackerTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

#### `openhands.tools.TaskTrackerTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

#### `openhands.tools.TaskTrackerTool.title`

```python
title: str
```

Get the title for the tool.

#### `openhands.tools.TaskTrackerTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

#### `openhands.tools.TaskTrackerTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

### `openhands.tools.execute_bash`

Bash execution tool for running shell commands.

**Modules:**

- [**constants**](#openhands.tools.execute_bash.constants) – Constants for bash execution tools.
- [**definition**](#openhands.tools.execute_bash.definition) – Execute bash tool implementation.
- [**impl**](#openhands.tools.execute_bash.impl) – Bash command execution implementation.
- [**metadata**](#openhands.tools.execute_bash.metadata) – Metadata for bash command execution.
- [**terminal**](#openhands.tools.execute_bash.terminal) – Terminal session management for bash execution.

**Classes:**

- [**BashExecutor**](#openhands.tools.execute_bash.BashExecutor) – Executor for bash commands using terminal sessions.
- [**BashTool**](#openhands.tools.execute_bash.BashTool) – A Tool subclass that automatically initializes a BashExecutor with auto-detection.
- [**ExecuteBashAction**](#openhands.tools.execute_bash.ExecuteBashAction) – Schema for bash command execution.
- [**ExecuteBashObservation**](#openhands.tools.execute_bash.ExecuteBashObservation) – A ToolResult that can be rendered as a CLI output.
- [**TerminalCommandStatus**](#openhands.tools.execute_bash.TerminalCommandStatus) – Status of a terminal command execution.
- [**TerminalSession**](#openhands.tools.execute_bash.TerminalSession) – Unified bash session that works with any TerminalInterface backend.

**Functions:**

- [**create_terminal_session**](#openhands.tools.execute_bash.create_terminal_session) – Create an appropriate terminal session based on system capabilities.

**Attributes:**

- [**execute_bash_tool**](#openhands.tools.execute_bash.execute_bash_tool) –

#### `openhands.tools.execute_bash.BashExecutor`

```python
BashExecutor(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for bash commands using terminal sessions.

**Functions:**

- [**close**](#openhands.tools.execute_bash.BashExecutor.close) – Close the terminal session and clean up resources.

**Attributes:**

- [**session**](#openhands.tools.execute_bash.BashExecutor.session) –

Initialize BashExecutor with auto-detected or specified session type.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – Working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities

##### `openhands.tools.execute_bash.BashExecutor.close`

```python
close()
```

Close the terminal session and clean up resources.

##### `openhands.tools.execute_bash.BashExecutor.session`

```python
session = create_terminal_session(work_dir=working_dir, username=username, no_change_timeout_seconds=no_change_timeout_seconds, terminal_type=terminal_type)
```

#### `openhands.tools.execute_bash.BashTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[ExecuteBashAction](#openhands.tools.execute_bash.definition.ExecuteBashAction), [ExecuteBashObservation](#openhands.tools.execute_bash.definition.ExecuteBashObservation)\]</code>

A Tool subclass that automatically initializes a BashExecutor with auto-detection.

**Functions:**

- [**call**](#openhands.tools.execute_bash.BashTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.execute_bash.BashTool.create) – Initialize BashTool with executor parameters.
- [**model_validate**](#openhands.tools.execute_bash.BashTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.BashTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.execute_bash.BashTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.execute_bash.BashTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.execute_bash.BashTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.execute_bash.BashTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.execute_bash.BashTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.execute_bash.BashTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.execute_bash.BashTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.execute_bash.BashTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.execute_bash.BashTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.execute_bash.BashTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.execute_bash.BashTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.execute_bash.BashTool.model_config) –
- [**name**](#openhands.tools.execute_bash.BashTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.execute_bash.BashTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.execute_bash.BashTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.execute_bash.BashTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

##### `openhands.tools.execute_bash.BashTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

##### `openhands.tools.execute_bash.BashTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

##### `openhands.tools.execute_bash.BashTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

##### `openhands.tools.execute_bash.BashTool.create`

```python
create(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Initialize BashTool with executor parameters.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – The working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities:
  \- On Windows: PowerShell if available, otherwise subprocess
  \- On Unix-like: tmux if available, otherwise subprocess

##### `openhands.tools.execute_bash.BashTool.description`

```python
description: str
```

##### `openhands.tools.execute_bash.BashTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.tools.execute_bash.BashTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

##### `openhands.tools.execute_bash.BashTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.execute_bash.BashTool.meta`

```python
meta: dict[str, Any] | None = None
```

##### `openhands.tools.execute_bash.BashTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.tools.execute_bash.BashTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.execute_bash.BashTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.execute_bash.BashTool.name`

```python
name: str
```

##### `openhands.tools.execute_bash.BashTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

##### `openhands.tools.execute_bash.BashTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

##### `openhands.tools.execute_bash.BashTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

##### `openhands.tools.execute_bash.BashTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.execute_bash.BashTool.title`

```python
title: str
```

Get the title for the tool.

##### `openhands.tools.execute_bash.BashTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

##### `openhands.tools.execute_bash.BashTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

#### `openhands.tools.execute_bash.ExecuteBashAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for bash command execution.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.execute_bash.ExecuteBashAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.execute_bash.ExecuteBashAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.ExecuteBashAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.execute_bash.ExecuteBashAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.execute_bash.ExecuteBashAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.execute_bash.ExecuteBashAction.command) (<code>[str](#str)</code>) –
- [**is_input**](#openhands.tools.execute_bash.ExecuteBashAction.is_input) (<code>[bool](#bool)</code>) –
- [**kind**](#openhands.tools.execute_bash.ExecuteBashAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.execute_bash.ExecuteBashAction.model_config) –
- [**security_risk**](#openhands.tools.execute_bash.ExecuteBashAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**timeout**](#openhands.tools.execute_bash.ExecuteBashAction.timeout) (<code>[float](#float) | None</code>) –
- [**visualize**](#openhands.tools.execute_bash.ExecuteBashAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with PS1-style bash prompt.

##### `openhands.tools.execute_bash.ExecuteBashAction.command`

```python
command: str = Field(description='The bash command to execute. Can be empty string to view additional logs when previous exit code is `-1`. Can be `C-c` (Ctrl+C) to interrupt the currently running process. Note: You can only execute one bash command at a time. If you need to run multiple commands sequentially, you can use `&&` or `;` to chain them together.')
```

##### `openhands.tools.execute_bash.ExecuteBashAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.execute_bash.ExecuteBashAction.is_input`

```python
is_input: bool = Field(default=False, description='If True, the command is an input to the running process. If False, the command is a bash command to be executed in the terminal. Default is False.')
```

##### `openhands.tools.execute_bash.ExecuteBashAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.execute_bash.ExecuteBashAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.tools.execute_bash.ExecuteBashAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.execute_bash.ExecuteBashAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.execute_bash.ExecuteBashAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

##### `openhands.tools.execute_bash.ExecuteBashAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.execute_bash.ExecuteBashAction.timeout`

```python
timeout: float | None = Field(default=None, description=f'Optional. Sets a maximum time limit (in seconds) for running the command. If the command takes longer than this limit, you’ll be asked whether to continue or stop it. If you don’t set a value, the command will instead pause and ask for confirmation when it produces no new output for {NO_CHANGE_TIMEOUT_SECONDS} seconds. Use a higher value if the command is expected to take a long time (like installation or testing), or if it has a known fixed duration (like sleep).')
```

##### `openhands.tools.execute_bash.ExecuteBashAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.execute_bash.ExecuteBashAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with PS1-style bash prompt.

#### `openhands.tools.execute_bash.ExecuteBashObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.execute_bash.ExecuteBashObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.execute_bash.ExecuteBashObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.ExecuteBashObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.execute_bash.ExecuteBashObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.execute_bash.ExecuteBashObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.execute_bash.ExecuteBashObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with formatted output and metadata.
- [**command**](#openhands.tools.execute_bash.ExecuteBashObservation.command) (<code>[str](#str) | None</code>) –
- [**command_id**](#openhands.tools.execute_bash.ExecuteBashObservation.command_id) (<code>[int](#int) | None</code>) – Get the command ID from metadata.
- [**error**](#openhands.tools.execute_bash.ExecuteBashObservation.error) (<code>[bool](#bool)</code>) –
- [**exit_code**](#openhands.tools.execute_bash.ExecuteBashObservation.exit_code) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.execute_bash.ExecuteBashObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**metadata**](#openhands.tools.execute_bash.ExecuteBashObservation.metadata) (<code>[CmdOutputMetadata](#openhands.tools.execute_bash.metadata.CmdOutputMetadata)</code>) –
- [**model_config**](#openhands.tools.execute_bash.ExecuteBashObservation.model_config) –
- [**output**](#openhands.tools.execute_bash.ExecuteBashObservation.output) (<code>[str](#str)</code>) –
- [**timeout**](#openhands.tools.execute_bash.ExecuteBashObservation.timeout) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.execute_bash.ExecuteBashObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with terminal-style output formatting.

##### `openhands.tools.execute_bash.ExecuteBashObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with formatted output and metadata.

##### `openhands.tools.execute_bash.ExecuteBashObservation.command`

```python
command: str | None = Field(default=None, description='The bash command that was executed. Can be empty string if the observation is from a previous command that hit soft timeout and is not yet finished.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.command_id`

```python
command_id: int | None
```

Get the command ID from metadata.

##### `openhands.tools.execute_bash.ExecuteBashObservation.error`

```python
error: bool = Field(default=False, description='Whether there was an error during command execution.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.exit_code`

```python
exit_code: int | None = Field(default=None, description='The exit code of the command. -1 indicates the process hit the soft timeout and is not yet finished.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.execute_bash.ExecuteBashObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.execute_bash.ExecuteBashObservation.metadata`

```python
metadata: CmdOutputMetadata = Field(default_factory=CmdOutputMetadata, description='Additional metadata captured from PS1 after command execution.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.execute_bash.ExecuteBashObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.execute_bash.ExecuteBashObservation.output`

```python
output: str = Field(description='The raw output from the tool.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.execute_bash.ExecuteBashObservation.timeout`

```python
timeout: bool = Field(default=False, description='Whether the command execution timed out.')
```

##### `openhands.tools.execute_bash.ExecuteBashObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.execute_bash.ExecuteBashObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with terminal-style output formatting.

#### `openhands.tools.execute_bash.TerminalCommandStatus`

Bases: <code>[Enum](#enum.Enum)</code>

Status of a terminal command execution.

**Attributes:**

- [**COMPLETED**](#openhands.tools.execute_bash.TerminalCommandStatus.COMPLETED) –
- [**CONTINUE**](#openhands.tools.execute_bash.TerminalCommandStatus.CONTINUE) –
- [**HARD_TIMEOUT**](#openhands.tools.execute_bash.TerminalCommandStatus.HARD_TIMEOUT) –
- [**INTERRUPTED**](#openhands.tools.execute_bash.TerminalCommandStatus.INTERRUPTED) –
- [**NO_CHANGE_TIMEOUT**](#openhands.tools.execute_bash.TerminalCommandStatus.NO_CHANGE_TIMEOUT) –

##### `openhands.tools.execute_bash.TerminalCommandStatus.COMPLETED`

```python
COMPLETED = 'completed'
```

##### `openhands.tools.execute_bash.TerminalCommandStatus.CONTINUE`

```python
CONTINUE = 'continue'
```

##### `openhands.tools.execute_bash.TerminalCommandStatus.HARD_TIMEOUT`

```python
HARD_TIMEOUT = 'hard_timeout'
```

##### `openhands.tools.execute_bash.TerminalCommandStatus.INTERRUPTED`

```python
INTERRUPTED = 'interrupted'
```

##### `openhands.tools.execute_bash.TerminalCommandStatus.NO_CHANGE_TIMEOUT`

```python
NO_CHANGE_TIMEOUT = 'no_change_timeout'
```

#### `openhands.tools.execute_bash.TerminalSession`

```python
TerminalSession(terminal, no_change_timeout_seconds=None)
```

Bases: <code>[TerminalSessionBase](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase)</code>

Unified bash session that works with any TerminalInterface backend.

This class contains all the session controller logic (timeouts, command parsing,
output processing) while delegating terminal operations to the TerminalInterface.

**Functions:**

- [**close**](#openhands.tools.execute_bash.TerminalSession.close) – Clean up the terminal backend.
- [**execute**](#openhands.tools.execute_bash.TerminalSession.execute) – Execute a command using the terminal backend.
- [**initialize**](#openhands.tools.execute_bash.TerminalSession.initialize) – Initialize the terminal backend.
- [**interrupt**](#openhands.tools.execute_bash.TerminalSession.interrupt) – Interrupt the currently running command (equivalent to Ctrl+C).
- [**is_running**](#openhands.tools.execute_bash.TerminalSession.is_running) – Check if a command is currently running.

**Attributes:**

- [**cwd**](#openhands.tools.execute_bash.TerminalSession.cwd) (<code>[str](#str)</code>) – Get the current working directory.
- [**no_change_timeout_seconds**](#openhands.tools.execute_bash.TerminalSession.no_change_timeout_seconds) –
- [**prev_output**](#openhands.tools.execute_bash.TerminalSession.prev_output) (<code>[str](#str)</code>) –
- [**prev_status**](#openhands.tools.execute_bash.TerminalSession.prev_status) (<code>[TerminalCommandStatus](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus) | None</code>) –
- [**terminal**](#openhands.tools.execute_bash.TerminalSession.terminal) –
- [**username**](#openhands.tools.execute_bash.TerminalSession.username) –
- [**work_dir**](#openhands.tools.execute_bash.TerminalSession.work_dir) –

Initialize the unified session with a terminal backend.

**Parameters:**

- **terminal** (<code>[TerminalInterface](#openhands.tools.execute_bash.terminal.interface.TerminalInterface)</code>) – The terminal backend to use
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change

##### `openhands.tools.execute_bash.TerminalSession.close`

```python
close()
```

Clean up the terminal backend.

##### `openhands.tools.execute_bash.TerminalSession.cwd`

```python
cwd: str
```

Get the current working directory.

##### `openhands.tools.execute_bash.TerminalSession.execute`

```python
execute(action)
```

Execute a command using the terminal backend.

##### `openhands.tools.execute_bash.TerminalSession.initialize`

```python
initialize()
```

Initialize the terminal backend.

##### `openhands.tools.execute_bash.TerminalSession.interrupt`

```python
interrupt()
```

Interrupt the currently running command (equivalent to Ctrl+C).

##### `openhands.tools.execute_bash.TerminalSession.is_running`

```python
is_running()
```

Check if a command is currently running.

##### `openhands.tools.execute_bash.TerminalSession.no_change_timeout_seconds`

```python
no_change_timeout_seconds = no_change_timeout_seconds or NO_CHANGE_TIMEOUT_SECONDS
```

##### `openhands.tools.execute_bash.TerminalSession.prev_output`

```python
prev_output: str = ''
```

##### `openhands.tools.execute_bash.TerminalSession.prev_status`

```python
prev_status: TerminalCommandStatus | None = None
```

##### `openhands.tools.execute_bash.TerminalSession.terminal`

```python
terminal = terminal
```

##### `openhands.tools.execute_bash.TerminalSession.username`

```python
username = username
```

##### `openhands.tools.execute_bash.TerminalSession.work_dir`

```python
work_dir = work_dir
```

#### `openhands.tools.execute_bash.constants`

Constants for bash execution tools.

**Attributes:**

- [**CMD_OUTPUT_METADATA_PS1_REGEX**](#openhands.tools.execute_bash.constants.CMD_OUTPUT_METADATA_PS1_REGEX) –
- [**CMD_OUTPUT_PS1_BEGIN**](#openhands.tools.execute_bash.constants.CMD_OUTPUT_PS1_BEGIN) –
- [**CMD_OUTPUT_PS1_END**](#openhands.tools.execute_bash.constants.CMD_OUTPUT_PS1_END) –
- [**HISTORY_LIMIT**](#openhands.tools.execute_bash.constants.HISTORY_LIMIT) –
- [**MAX_CMD_OUTPUT_SIZE**](#openhands.tools.execute_bash.constants.MAX_CMD_OUTPUT_SIZE) (<code>[int](#int)</code>) –
- [**NO_CHANGE_TIMEOUT_SECONDS**](#openhands.tools.execute_bash.constants.NO_CHANGE_TIMEOUT_SECONDS) –
- [**POLL_INTERVAL**](#openhands.tools.execute_bash.constants.POLL_INTERVAL) –
- [**TIMEOUT_MESSAGE_TEMPLATE**](#openhands.tools.execute_bash.constants.TIMEOUT_MESSAGE_TEMPLATE) –

##### `openhands.tools.execute_bash.constants.CMD_OUTPUT_METADATA_PS1_REGEX`

```python
CMD_OUTPUT_METADATA_PS1_REGEX = re.compile(f'^{CMD_OUTPUT_PS1_BEGIN.strip()}(.*?){CMD_OUTPUT_PS1_END.strip()}', re.DOTALL | re.MULTILINE)
```

##### `openhands.tools.execute_bash.constants.CMD_OUTPUT_PS1_BEGIN`

```python
CMD_OUTPUT_PS1_BEGIN = '\n###PS1JSON###\n'
```

##### `openhands.tools.execute_bash.constants.CMD_OUTPUT_PS1_END`

```python
CMD_OUTPUT_PS1_END = '\n###PS1END###'
```

##### `openhands.tools.execute_bash.constants.HISTORY_LIMIT`

```python
HISTORY_LIMIT = 10000
```

##### `openhands.tools.execute_bash.constants.MAX_CMD_OUTPUT_SIZE`

```python
MAX_CMD_OUTPUT_SIZE: int = 30000
```

##### `openhands.tools.execute_bash.constants.NO_CHANGE_TIMEOUT_SECONDS`

```python
NO_CHANGE_TIMEOUT_SECONDS = 30
```

##### `openhands.tools.execute_bash.constants.POLL_INTERVAL`

```python
POLL_INTERVAL = 0.5
```

##### `openhands.tools.execute_bash.constants.TIMEOUT_MESSAGE_TEMPLATE`

```python
TIMEOUT_MESSAGE_TEMPLATE = 'You may wait longer to see additional output by sending empty command \'\', send other commands to interact with the current process, send keys ("C-c", "C-z", "C-d") to interrupt/kill the previous command before sending your new command, or use the timeout parameter in execute_bash for future commands.'
```

#### `openhands.tools.execute_bash.create_terminal_session`

```python
create_terminal_session(work_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Create an appropriate terminal session based on system capabilities.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the session
- **username** (<code>[str](#str) | None</code>) – Optional username for the session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type ('tmux', 'subprocess')
  If None, auto-detect based on system capabilities

**Returns:**

- <code>[TerminalSession](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession)</code> – TerminalSession instance

**Raises:**

- <code>[RuntimeError](#RuntimeError)</code> – If the requested session type is not available

#### `openhands.tools.execute_bash.definition`

Execute bash tool implementation.

**Classes:**

- [**BashTool**](#openhands.tools.execute_bash.definition.BashTool) – A Tool subclass that automatically initializes a BashExecutor with auto-detection.
- [**ExecuteBashAction**](#openhands.tools.execute_bash.definition.ExecuteBashAction) – Schema for bash command execution.
- [**ExecuteBashObservation**](#openhands.tools.execute_bash.definition.ExecuteBashObservation) – A ToolResult that can be rendered as a CLI output.

**Attributes:**

- [**TOOL_DESCRIPTION**](#openhands.tools.execute_bash.definition.TOOL_DESCRIPTION) –
- [**execute_bash_tool**](#openhands.tools.execute_bash.definition.execute_bash_tool) –

##### `openhands.tools.execute_bash.definition.BashTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[ExecuteBashAction](#openhands.tools.execute_bash.definition.ExecuteBashAction), [ExecuteBashObservation](#openhands.tools.execute_bash.definition.ExecuteBashObservation)\]</code>

A Tool subclass that automatically initializes a BashExecutor with auto-detection.

**Functions:**

- [**call**](#openhands.tools.execute_bash.definition.BashTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.execute_bash.definition.BashTool.create) – Initialize BashTool with executor parameters.
- [**model_validate**](#openhands.tools.execute_bash.definition.BashTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.definition.BashTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.execute_bash.definition.BashTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.execute_bash.definition.BashTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.execute_bash.definition.BashTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.execute_bash.definition.BashTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.execute_bash.definition.BashTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.execute_bash.definition.BashTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.execute_bash.definition.BashTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.execute_bash.definition.BashTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.execute_bash.definition.BashTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.execute_bash.definition.BashTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.execute_bash.definition.BashTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.execute_bash.definition.BashTool.model_config) –
- [**name**](#openhands.tools.execute_bash.definition.BashTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.execute_bash.definition.BashTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.execute_bash.definition.BashTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.execute_bash.definition.BashTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

###### `openhands.tools.execute_bash.definition.BashTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

###### `openhands.tools.execute_bash.definition.BashTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

###### `openhands.tools.execute_bash.definition.BashTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

###### `openhands.tools.execute_bash.definition.BashTool.create`

```python
create(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Initialize BashTool with executor parameters.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – The working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities:
  \- On Windows: PowerShell if available, otherwise subprocess
  \- On Unix-like: tmux if available, otherwise subprocess

###### `openhands.tools.execute_bash.definition.BashTool.description`

```python
description: str
```

###### `openhands.tools.execute_bash.definition.BashTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.tools.execute_bash.definition.BashTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

###### `openhands.tools.execute_bash.definition.BashTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.execute_bash.definition.BashTool.meta`

```python
meta: dict[str, Any] | None = None
```

###### `openhands.tools.execute_bash.definition.BashTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.tools.execute_bash.definition.BashTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.execute_bash.definition.BashTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.execute_bash.definition.BashTool.name`

```python
name: str
```

###### `openhands.tools.execute_bash.definition.BashTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

###### `openhands.tools.execute_bash.definition.BashTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

###### `openhands.tools.execute_bash.definition.BashTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

###### `openhands.tools.execute_bash.definition.BashTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.execute_bash.definition.BashTool.title`

```python
title: str
```

Get the title for the tool.

###### `openhands.tools.execute_bash.definition.BashTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

###### `openhands.tools.execute_bash.definition.BashTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

##### `openhands.tools.execute_bash.definition.ExecuteBashAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for bash command execution.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.execute_bash.definition.ExecuteBashAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.execute_bash.definition.ExecuteBashAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.definition.ExecuteBashAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.execute_bash.definition.ExecuteBashAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.execute_bash.definition.ExecuteBashAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.execute_bash.definition.ExecuteBashAction.command) (<code>[str](#str)</code>) –
- [**is_input**](#openhands.tools.execute_bash.definition.ExecuteBashAction.is_input) (<code>[bool](#bool)</code>) –
- [**kind**](#openhands.tools.execute_bash.definition.ExecuteBashAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.execute_bash.definition.ExecuteBashAction.model_config) –
- [**security_risk**](#openhands.tools.execute_bash.definition.ExecuteBashAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**timeout**](#openhands.tools.execute_bash.definition.ExecuteBashAction.timeout) (<code>[float](#float) | None</code>) –
- [**visualize**](#openhands.tools.execute_bash.definition.ExecuteBashAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with PS1-style bash prompt.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.command`

```python
command: str = Field(description='The bash command to execute. Can be empty string to view additional logs when previous exit code is `-1`. Can be `C-c` (Ctrl+C) to interrupt the currently running process. Note: You can only execute one bash command at a time. If you need to run multiple commands sequentially, you can use `&&` or `;` to chain them together.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.is_input`

```python
is_input: bool = Field(default=False, description='If True, the command is an input to the running process. If False, the command is a bash command to be executed in the terminal. Default is False.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.timeout`

```python
timeout: float | None = Field(default=None, description=f'Optional. Sets a maximum time limit (in seconds) for running the command. If the command takes longer than this limit, you’ll be asked whether to continue or stop it. If you don’t set a value, the command will instead pause and ask for confirmation when it produces no new output for {NO_CHANGE_TIMEOUT_SECONDS} seconds. Use a higher value if the command is expected to take a long time (like installation or testing), or if it has a known fixed duration (like sleep).')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.execute_bash.definition.ExecuteBashAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with PS1-style bash prompt.

##### `openhands.tools.execute_bash.definition.ExecuteBashObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with formatted output and metadata.
- [**command**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.command) (<code>[str](#str) | None</code>) –
- [**command_id**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.command_id) (<code>[int](#int) | None</code>) – Get the command ID from metadata.
- [**error**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.error) (<code>[bool](#bool)</code>) –
- [**exit_code**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.exit_code) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**metadata**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.metadata) (<code>[CmdOutputMetadata](#openhands.tools.execute_bash.metadata.CmdOutputMetadata)</code>) –
- [**model_config**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.model_config) –
- [**output**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.output) (<code>[str](#str)</code>) –
- [**timeout**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.timeout) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.execute_bash.definition.ExecuteBashObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with terminal-style output formatting.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with formatted output and metadata.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.command`

```python
command: str | None = Field(default=None, description='The bash command that was executed. Can be empty string if the observation is from a previous command that hit soft timeout and is not yet finished.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.command_id`

```python
command_id: int | None
```

Get the command ID from metadata.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.error`

```python
error: bool = Field(default=False, description='Whether there was an error during command execution.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.exit_code`

```python
exit_code: int | None = Field(default=None, description='The exit code of the command. -1 indicates the process hit the soft timeout and is not yet finished.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.metadata`

```python
metadata: CmdOutputMetadata = Field(default_factory=CmdOutputMetadata, description='Additional metadata captured from PS1 after command execution.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.output`

```python
output: str = Field(description='The raw output from the tool.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.timeout`

```python
timeout: bool = Field(default=False, description='Whether the command execution timed out.')
```

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.execute_bash.definition.ExecuteBashObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with terminal-style output formatting.

##### `openhands.tools.execute_bash.definition.TOOL_DESCRIPTION`

```python
TOOL_DESCRIPTION = 'Execute a bash command in the terminal within a persistent shell session.\n\n\n### Command Execution\n* One command at a time: You can only execute one bash command at a time. If you need to run multiple commands sequentially, use `&&` or `;` to chain them together.\n* Persistent session: Commands execute in a persistent shell session where environment variables, virtual environments, and working directory persist between commands.\n* Soft timeout: Commands have a soft timeout of 10 seconds, once that\'s reached, you have the option to continue or interrupt the command (see section below for details)\n* Shell options: Do NOT use `set -e`, `set -eu`, or `set -euo pipefail` in shell scripts or commands in this environment. The runtime may not support them and can cause unusable shell sessions. If you want to run multi-line bash commands, write the commands to a file and then run it, instead.\n\n### Long-running Commands\n* For commands that may run indefinitely, run them in the background and redirect output to a file, e.g. `python3 app.py > server.log 2>&1 &`.\n* For commands that may run for a long time (e.g. installation or testing commands), or commands that run for a fixed amount of time (e.g. sleep), you should set the "timeout" parameter of your function call to an appropriate value.\n* If a bash command returns exit code `-1`, this means the process hit the soft timeout and is not yet finished. By setting `is_input` to `true`, you can:\n  - Send empty `command` to retrieve additional logs\n  - Send text (set `command` to the text) to STDIN of the running process\n  - Send control commands like `C-c` (Ctrl+C), `C-d` (Ctrl+D), or `C-z` (Ctrl+Z) to interrupt the process\n  - If you do C-c, you can re-start the process with a longer "timeout" parameter to let it run to completion\n\n### Best Practices\n* Directory verification: Before creating new directories or files, first verify the parent directory exists and is the correct location.\n* Directory management: Try to maintain working directory by using absolute paths and avoiding excessive use of `cd`.\n\n### Output Handling\n* Output truncation: If the output exceeds a maximum length, it will be truncated before being returned.\n'
```

##### `openhands.tools.execute_bash.definition.execute_bash_tool`

```python
execute_bash_tool = Tool(name='execute_bash', action_type=ExecuteBashAction, observation_type=ExecuteBashObservation, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='execute_bash', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=True)))
```

#### `openhands.tools.execute_bash.execute_bash_tool`

```python
execute_bash_tool = Tool(name='execute_bash', action_type=ExecuteBashAction, observation_type=ExecuteBashObservation, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='execute_bash', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=True)))
```

#### `openhands.tools.execute_bash.impl`

Bash command execution implementation.

**Classes:**

- [**BashExecutor**](#openhands.tools.execute_bash.impl.BashExecutor) – Executor for bash commands using terminal sessions.

##### `openhands.tools.execute_bash.impl.BashExecutor`

```python
BashExecutor(working_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for bash commands using terminal sessions.

**Functions:**

- [**close**](#openhands.tools.execute_bash.impl.BashExecutor.close) – Close the terminal session and clean up resources.

**Attributes:**

- [**session**](#openhands.tools.execute_bash.impl.BashExecutor.session) –

Initialize BashExecutor with auto-detected or specified session type.

**Parameters:**

- **working_dir** (<code>[str](#str)</code>) – Working directory for bash commands
- **username** (<code>[str](#str) | None</code>) – Optional username for the bash session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type:
  ('tmux', 'subprocess').
  If None, auto-detect based on system capabilities

###### `openhands.tools.execute_bash.impl.BashExecutor.close`

```python
close()
```

Close the terminal session and clean up resources.

###### `openhands.tools.execute_bash.impl.BashExecutor.session`

```python
session = create_terminal_session(work_dir=working_dir, username=username, no_change_timeout_seconds=no_change_timeout_seconds, terminal_type=terminal_type)
```

#### `openhands.tools.execute_bash.metadata`

Metadata for bash command execution.

**Classes:**

- [**CmdOutputMetadata**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata) – Additional metadata captured from PS1.

**Attributes:**

- [**logger**](#openhands.tools.execute_bash.metadata.logger) –

##### `openhands.tools.execute_bash.metadata.CmdOutputMetadata`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Additional metadata captured from PS1.

**Functions:**

- [**from_ps1_match**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.from_ps1_match) – Extract the required metadata from a PS1 prompt.
- [**matches_ps1_metadata**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.matches_ps1_metadata) – Find all PS1 metadata matches in the given string.
- [**to_ps1_prompt**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.to_ps1_prompt) – Convert the required metadata into a PS1 prompt.

**Attributes:**

- [**exit_code**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.exit_code) (<code>[int](#int)</code>) –
- [**hostname**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.hostname) (<code>[str](#str) | None</code>) –
- [**pid**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.pid) (<code>[int](#int)</code>) –
- [**prefix**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.prefix) (<code>[str](#str)</code>) –
- [**py_interpreter_path**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.py_interpreter_path) (<code>[str](#str) | None</code>) –
- [**suffix**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.suffix) (<code>[str](#str)</code>) –
- [**username**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.username) (<code>[str](#str) | None</code>) –
- [**working_dir**](#openhands.tools.execute_bash.metadata.CmdOutputMetadata.working_dir) (<code>[str](#str) | None</code>) –

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.exit_code`

```python
exit_code: int = Field(default=(-1), description='The exit code of the last executed command.')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.from_ps1_match`

```python
from_ps1_match(match)
```

Extract the required metadata from a PS1 prompt.

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.hostname`

```python
hostname: str | None = Field(default=None, description='The hostname of the machine.')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.matches_ps1_metadata`

```python
matches_ps1_metadata(string)
```

Find all PS1 metadata matches in the given string.

**Parameters:**

- **string** (<code>[str](#str)</code>) – The string to search for PS1 metadata patterns.

**Returns:**

- <code>[list](#list)\[[Match](#re.Match)\[[str](#str)\]\]</code> – List of regex matches containing valid PS1 metadata.

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.pid`

```python
pid: int = Field(default=(-1), description='The process ID of the last executed command.')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.prefix`

```python
prefix: str = Field(default='', description='Prefix to add to command output')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.py_interpreter_path`

```python
py_interpreter_path: str | None = Field(default=None, description='The path to the current Python interpreter, if any.')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.suffix`

```python
suffix: str = Field(default='', description='Suffix to add to command output')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.to_ps1_prompt`

```python
to_ps1_prompt()
```

Convert the required metadata into a PS1 prompt.

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.username`

```python
username: str | None = Field(default=None, description='The username of the current user.')
```

###### `openhands.tools.execute_bash.metadata.CmdOutputMetadata.working_dir`

```python
working_dir: str | None = Field(default=None, description='The current working directory.')
```

##### `openhands.tools.execute_bash.metadata.logger`

```python
logger = get_logger(__name__)
```

#### `openhands.tools.execute_bash.terminal`

Terminal session management for bash execution.

**Modules:**

- [**factory**](#openhands.tools.execute_bash.terminal.factory) – Factory for creating appropriate terminal sessions based on system capabilities.
- [**interface**](#openhands.tools.execute_bash.terminal.interface) – Abstract interface for terminal backends.
- [**subprocess_terminal**](#openhands.tools.execute_bash.terminal.subprocess_terminal) – PTY-based terminal backend implementation (replaces pipe-based subprocess).
- [**terminal_session**](#openhands.tools.execute_bash.terminal.terminal_session) – Unified terminal session using TerminalInterface backends.
- [**tmux_terminal**](#openhands.tools.execute_bash.terminal.tmux_terminal) – Tmux-based terminal backend implementation.

**Classes:**

- [**SubprocessTerminal**](#openhands.tools.execute_bash.terminal.SubprocessTerminal) – PTY-backed terminal backend.
- [**TerminalCommandStatus**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus) – Status of a terminal command execution.
- [**TerminalInterface**](#openhands.tools.execute_bash.terminal.TerminalInterface) – Abstract interface for terminal backends.
- [**TerminalSession**](#openhands.tools.execute_bash.terminal.TerminalSession) – Unified bash session that works with any TerminalInterface backend.
- [**TerminalSessionBase**](#openhands.tools.execute_bash.terminal.TerminalSessionBase) – Abstract base class for terminal sessions.
- [**TmuxTerminal**](#openhands.tools.execute_bash.terminal.TmuxTerminal) – Tmux-based terminal backend.

**Functions:**

- [**create_terminal_session**](#openhands.tools.execute_bash.terminal.create_terminal_session) – Create an appropriate terminal session based on system capabilities.

##### `openhands.tools.execute_bash.terminal.SubprocessTerminal`

```python
SubprocessTerminal(work_dir, username=None)
```

Bases: <code>[TerminalInterface](#openhands.tools.execute_bash.terminal.TerminalInterface)</code>

PTY-backed terminal backend.

Creates an interactive bash in a pseudoterminal (PTY) so programs behave as if
attached to a real terminal. Initialization uses a sentinel-based handshake
and prompt detection instead of blind sleeps.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.clear_screen) – Drop buffered output up to the most recent PS1 block; do not emit ^L.
- [**close**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.close) – Clean up the PTY terminal.
- [**initialize**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.initialize) – Initialize the PTY terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.interrupt) – Send SIGINT to the PTY process group (fallback to signal-based interrupt).
- [**is_powershell**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.is_running) – Heuristic: command running if not at PS1 prompt and process alive.
- [**read_screen**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.read_screen) – Read the current terminal screen content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.send_keys) – Send keystrokes to the PTY.

**Attributes:**

- [**PS1**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.PS1) –
- [**closed**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**output_buffer**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.output_buffer) (<code>[Deque](#typing.Deque)\[[str](#str)\]</code>) –
- [**output_lock**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.output_lock) –
- [**process**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.process) (<code>[Popen](#subprocess.Popen) | None</code>) –
- [**reader_thread**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.reader_thread) (<code>[Thread](#threading.Thread) | None</code>) –
- [**username**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.SubprocessTerminal.work_dir) –

Initialize SubprocessTerminal with working directory and username.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.PS1`

```python
PS1 = CmdOutputMetadata.to_ps1_prompt()
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.clear_screen`

```python
clear_screen()
```

Drop buffered output up to the most recent PS1 block; do not emit ^L.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.close`

```python
close()
```

Clean up the PTY terminal.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.closed`

```python
closed: bool
```

Check if the terminal is closed.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.initialize`

```python
initialize()
```

Initialize the PTY terminal session.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.interrupt`

```python
interrupt()
```

Send SIGINT to the PTY process group (fallback to signal-based interrupt).

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.is_running`

```python
is_running()
```

Heuristic: command running if not at PS1 prompt and process alive.

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.output_buffer`

```python
output_buffer: Deque[str] = deque(maxlen=(HISTORY_LIMIT + 50))
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.output_lock`

```python
output_lock = threading.Lock()
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.process`

```python
process: subprocess.Popen | None = None
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.read_screen`

```python
read_screen()
```

Read the current terminal screen content.

The content we return should NOT contains carriage returns (CR, \\r).

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.reader_thread`

```python
reader_thread: threading.Thread | None = None
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.send_keys`

```python
send_keys(text, enter=True)
```

Send keystrokes to the PTY.

<details class="supports" open>
<summary>Supports</summary>
- Plain text
- Ctrl sequences: 'C-a'..'C-z' (Ctrl+C sends ^C byte)
- Special names: 'ENTER','TAB','BS','ESC','UP','DOWN','LEFT','RIGHT',
                 'HOME','END','PGUP','PGDN','C-L','C-D'
</details>

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.username`

```python
username = username
```

###### `openhands.tools.execute_bash.terminal.SubprocessTerminal.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.TerminalCommandStatus`

Bases: <code>[Enum](#enum.Enum)</code>

Status of a terminal command execution.

**Attributes:**

- [**COMPLETED**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus.COMPLETED) –
- [**CONTINUE**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus.CONTINUE) –
- [**HARD_TIMEOUT**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus.HARD_TIMEOUT) –
- [**INTERRUPTED**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus.INTERRUPTED) –
- [**NO_CHANGE_TIMEOUT**](#openhands.tools.execute_bash.terminal.TerminalCommandStatus.NO_CHANGE_TIMEOUT) –

###### `openhands.tools.execute_bash.terminal.TerminalCommandStatus.COMPLETED`

```python
COMPLETED = 'completed'
```

###### `openhands.tools.execute_bash.terminal.TerminalCommandStatus.CONTINUE`

```python
CONTINUE = 'continue'
```

###### `openhands.tools.execute_bash.terminal.TerminalCommandStatus.HARD_TIMEOUT`

```python
HARD_TIMEOUT = 'hard_timeout'
```

###### `openhands.tools.execute_bash.terminal.TerminalCommandStatus.INTERRUPTED`

```python
INTERRUPTED = 'interrupted'
```

###### `openhands.tools.execute_bash.terminal.TerminalCommandStatus.NO_CHANGE_TIMEOUT`

```python
NO_CHANGE_TIMEOUT = 'no_change_timeout'
```

##### `openhands.tools.execute_bash.terminal.TerminalInterface`

```python
TerminalInterface(work_dir, username=None)
```

Bases: <code>[ABC](#abc.ABC)</code>

Abstract interface for terminal backends.

This interface abstracts the low-level terminal operations, allowing
different backends (tmux, subprocess, PowerShell) to be used with
the same high-level session controller logic.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.TerminalInterface.clear_screen) – Clear the terminal screen and history.
- [**close**](#openhands.tools.execute_bash.terminal.TerminalInterface.close) – Clean up the terminal backend.
- [**initialize**](#openhands.tools.execute_bash.terminal.TerminalInterface.initialize) – Initialize the terminal backend.
- [**interrupt**](#openhands.tools.execute_bash.terminal.TerminalInterface.interrupt) – Send interrupt signal (Ctrl+C) to the terminal.
- [**is_powershell**](#openhands.tools.execute_bash.terminal.TerminalInterface.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.TerminalInterface.is_running) – Check if a command is currently running in the terminal.
- [**read_screen**](#openhands.tools.execute_bash.terminal.TerminalInterface.read_screen) – Read the current terminal screen content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.TerminalInterface.send_keys) – Send text/keys to the terminal.

**Attributes:**

- [**closed**](#openhands.tools.execute_bash.terminal.TerminalInterface.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.TerminalInterface.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**username**](#openhands.tools.execute_bash.terminal.TerminalInterface.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.TerminalInterface.work_dir) –

Initialize the terminal interface.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the terminal
- **username** (<code>[str](#str) | None</code>) – Optional username for the terminal session

###### `openhands.tools.execute_bash.terminal.TerminalInterface.clear_screen`

```python
clear_screen()
```

Clear the terminal screen and history.

###### `openhands.tools.execute_bash.terminal.TerminalInterface.close`

```python
close()
```

Clean up the terminal backend.

This should properly terminate the terminal session and
clean up any resources.

###### `openhands.tools.execute_bash.terminal.TerminalInterface.closed`

```python
closed: bool
```

Check if the terminal is closed.

###### `openhands.tools.execute_bash.terminal.TerminalInterface.initialize`

```python
initialize()
```

Initialize the terminal backend.

This should set up the terminal session, configure the shell,
and prepare it for command execution.

###### `openhands.tools.execute_bash.terminal.TerminalInterface.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

###### `openhands.tools.execute_bash.terminal.TerminalInterface.interrupt`

```python
interrupt()
```

Send interrupt signal (Ctrl+C) to the terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was sent successfully, False otherwise

###### `openhands.tools.execute_bash.terminal.TerminalInterface.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

###### `openhands.tools.execute_bash.terminal.TerminalInterface.is_running`

```python
is_running()
```

Check if a command is currently running in the terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if a command is running, False otherwise

###### `openhands.tools.execute_bash.terminal.TerminalInterface.read_screen`

```python
read_screen()
```

Read the current terminal screen content.

**Returns:**

- <code>[str](#str)</code> – Current visible content of the terminal screen

###### `openhands.tools.execute_bash.terminal.TerminalInterface.send_keys`

```python
send_keys(text, enter=True)
```

Send text/keys to the terminal.

**Parameters:**

- **text** (<code>[str](#str)</code>) – Text or key sequence to send
- **enter** (<code>[bool](#bool)</code>) – Whether to send Enter key after the text

###### `openhands.tools.execute_bash.terminal.TerminalInterface.username`

```python
username = username
```

###### `openhands.tools.execute_bash.terminal.TerminalInterface.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.TerminalSession`

```python
TerminalSession(terminal, no_change_timeout_seconds=None)
```

Bases: <code>[TerminalSessionBase](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase)</code>

Unified bash session that works with any TerminalInterface backend.

This class contains all the session controller logic (timeouts, command parsing,
output processing) while delegating terminal operations to the TerminalInterface.

**Functions:**

- [**close**](#openhands.tools.execute_bash.terminal.TerminalSession.close) – Clean up the terminal backend.
- [**execute**](#openhands.tools.execute_bash.terminal.TerminalSession.execute) – Execute a command using the terminal backend.
- [**initialize**](#openhands.tools.execute_bash.terminal.TerminalSession.initialize) – Initialize the terminal backend.
- [**interrupt**](#openhands.tools.execute_bash.terminal.TerminalSession.interrupt) – Interrupt the currently running command (equivalent to Ctrl+C).
- [**is_running**](#openhands.tools.execute_bash.terminal.TerminalSession.is_running) – Check if a command is currently running.

**Attributes:**

- [**cwd**](#openhands.tools.execute_bash.terminal.TerminalSession.cwd) (<code>[str](#str)</code>) – Get the current working directory.
- [**no_change_timeout_seconds**](#openhands.tools.execute_bash.terminal.TerminalSession.no_change_timeout_seconds) –
- [**prev_output**](#openhands.tools.execute_bash.terminal.TerminalSession.prev_output) (<code>[str](#str)</code>) –
- [**prev_status**](#openhands.tools.execute_bash.terminal.TerminalSession.prev_status) (<code>[TerminalCommandStatus](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus) | None</code>) –
- [**terminal**](#openhands.tools.execute_bash.terminal.TerminalSession.terminal) –
- [**username**](#openhands.tools.execute_bash.terminal.TerminalSession.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.TerminalSession.work_dir) –

Initialize the unified session with a terminal backend.

**Parameters:**

- **terminal** (<code>[TerminalInterface](#openhands.tools.execute_bash.terminal.interface.TerminalInterface)</code>) – The terminal backend to use
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change

###### `openhands.tools.execute_bash.terminal.TerminalSession.close`

```python
close()
```

Clean up the terminal backend.

###### `openhands.tools.execute_bash.terminal.TerminalSession.cwd`

```python
cwd: str
```

Get the current working directory.

###### `openhands.tools.execute_bash.terminal.TerminalSession.execute`

```python
execute(action)
```

Execute a command using the terminal backend.

###### `openhands.tools.execute_bash.terminal.TerminalSession.initialize`

```python
initialize()
```

Initialize the terminal backend.

###### `openhands.tools.execute_bash.terminal.TerminalSession.interrupt`

```python
interrupt()
```

Interrupt the currently running command (equivalent to Ctrl+C).

###### `openhands.tools.execute_bash.terminal.TerminalSession.is_running`

```python
is_running()
```

Check if a command is currently running.

###### `openhands.tools.execute_bash.terminal.TerminalSession.no_change_timeout_seconds`

```python
no_change_timeout_seconds = no_change_timeout_seconds or NO_CHANGE_TIMEOUT_SECONDS
```

###### `openhands.tools.execute_bash.terminal.TerminalSession.prev_output`

```python
prev_output: str = ''
```

###### `openhands.tools.execute_bash.terminal.TerminalSession.prev_status`

```python
prev_status: TerminalCommandStatus | None = None
```

###### `openhands.tools.execute_bash.terminal.TerminalSession.terminal`

```python
terminal = terminal
```

###### `openhands.tools.execute_bash.terminal.TerminalSession.username`

```python
username = username
```

###### `openhands.tools.execute_bash.terminal.TerminalSession.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.TerminalSessionBase`

```python
TerminalSessionBase(work_dir, username=None, no_change_timeout_seconds=None)
```

Bases: <code>[ABC](#abc.ABC)</code>

Abstract base class for terminal sessions.

This class defines the common interface for all terminal session implementations,
including tmux-based, subprocess-based, and PowerShell-based sessions.

**Functions:**

- [**close**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.close) – Clean up the terminal session.
- [**execute**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.execute) – Execute a command in the terminal session.
- [**initialize**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.initialize) – Initialize the terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.interrupt) – Interrupt the currently running command (equivalent to Ctrl+C).
- [**is_running**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.is_running) – Check if a command is currently running.

**Attributes:**

- [**cwd**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.cwd) (<code>[str](#str)</code>) – Get the current working directory.
- [**no_change_timeout_seconds**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.no_change_timeout_seconds) –
- [**username**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.TerminalSessionBase.work_dir) –

Initialize the terminal session.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the session
- **username** (<code>[str](#str) | None</code>) – Optional username for the session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.close`

```python
close()
```

Clean up the terminal session.

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.cwd`

```python
cwd: str
```

Get the current working directory.

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.execute`

```python
execute(action)
```

Execute a command in the terminal session.

**Parameters:**

- **action** (<code>[ExecuteBashAction](#openhands.tools.execute_bash.definition.ExecuteBashAction)</code>) – The bash action to execute

**Returns:**

- <code>[ExecuteBashObservation](#openhands.tools.execute_bash.definition.ExecuteBashObservation)</code> – ExecuteBashObservation with the command result

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.initialize`

```python
initialize()
```

Initialize the terminal session.

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.interrupt`

```python
interrupt()
```

Interrupt the currently running command (equivalent to Ctrl+C).

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was successful, False otherwise

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.is_running`

```python
is_running()
```

Check if a command is currently running.

**Returns:**

- <code>[bool](#bool)</code> – True if a command is running, False otherwise

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.no_change_timeout_seconds`

```python
no_change_timeout_seconds = no_change_timeout_seconds
```

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.username`

```python
username = username
```

###### `openhands.tools.execute_bash.terminal.TerminalSessionBase.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.TmuxTerminal`

```python
TmuxTerminal(work_dir, username=None)
```

Bases: <code>[TerminalInterface](#openhands.tools.execute_bash.terminal.TerminalInterface)</code>

Tmux-based terminal backend.

This backend uses tmux to provide a persistent terminal session
with full screen capture and history management capabilities.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.TmuxTerminal.clear_screen) – Clear the tmux pane screen and history.
- [**close**](#openhands.tools.execute_bash.terminal.TmuxTerminal.close) – Clean up the tmux session.
- [**initialize**](#openhands.tools.execute_bash.terminal.TmuxTerminal.initialize) – Initialize the tmux terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.TmuxTerminal.interrupt) – Send interrupt signal (Ctrl+C) to the tmux pane.
- [**is_powershell**](#openhands.tools.execute_bash.terminal.TmuxTerminal.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.TmuxTerminal.is_running) – Check if a command is currently running.
- [**read_screen**](#openhands.tools.execute_bash.terminal.TmuxTerminal.read_screen) – Read the current tmux pane content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.TmuxTerminal.send_keys) – Send text/keys to the tmux pane.

**Attributes:**

- [**PS1**](#openhands.tools.execute_bash.terminal.TmuxTerminal.PS1) –
- [**closed**](#openhands.tools.execute_bash.terminal.TmuxTerminal.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.TmuxTerminal.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**username**](#openhands.tools.execute_bash.terminal.TmuxTerminal.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.TmuxTerminal.work_dir) –

Initialize the tmux terminal with working directory and username.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.PS1`

```python
PS1 = CmdOutputMetadata.to_ps1_prompt()
```

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.clear_screen`

```python
clear_screen()
```

Clear the tmux pane screen and history.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.close`

```python
close()
```

Clean up the tmux session.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.closed`

```python
closed: bool
```

Check if the terminal is closed.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.initialize`

```python
initialize()
```

Initialize the tmux terminal session.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.interrupt`

```python
interrupt()
```

Send interrupt signal (Ctrl+C) to the tmux pane.

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was sent successfully, False otherwise

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.is_running`

```python
is_running()
```

Check if a command is currently running.

For tmux, we determine this by checking if the terminal
is ready for new commands (ends with prompt).

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.read_screen`

```python
read_screen()
```

Read the current tmux pane content.

**Returns:**

- <code>[str](#str)</code> – Current visible content of the tmux pane

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.send_keys`

```python
send_keys(text, enter=True)
```

Send text/keys to the tmux pane.

**Parameters:**

- **text** (<code>[str](#str)</code>) – Text or key sequence to send
- **enter** (<code>[bool](#bool)</code>) – Whether to send Enter key after the text

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.username`

```python
username = username
```

###### `openhands.tools.execute_bash.terminal.TmuxTerminal.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.create_terminal_session`

```python
create_terminal_session(work_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Create an appropriate terminal session based on system capabilities.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the session
- **username** (<code>[str](#str) | None</code>) – Optional username for the session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type ('tmux', 'subprocess')
  If None, auto-detect based on system capabilities

**Returns:**

- <code>[TerminalSession](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession)</code> – TerminalSession instance

**Raises:**

- <code>[RuntimeError](#RuntimeError)</code> – If the requested session type is not available

##### `openhands.tools.execute_bash.terminal.factory`

Factory for creating appropriate terminal sessions based on system capabilities.

**Functions:**

- [**create_terminal_session**](#openhands.tools.execute_bash.terminal.factory.create_terminal_session) – Create an appropriate terminal session based on system capabilities.

**Attributes:**

- [**logger**](#openhands.tools.execute_bash.terminal.factory.logger) –

###### `openhands.tools.execute_bash.terminal.factory.create_terminal_session`

```python
create_terminal_session(work_dir, username=None, no_change_timeout_seconds=None, terminal_type=None)
```

Create an appropriate terminal session based on system capabilities.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the session
- **username** (<code>[str](#str) | None</code>) – Optional username for the session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change
- **terminal_type** (<code>[Literal](#typing.Literal)['tmux', 'subprocess'] | None</code>) – Force a specific session type ('tmux', 'subprocess')
  If None, auto-detect based on system capabilities

**Returns:**

- <code>[TerminalSession](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession)</code> – TerminalSession instance

**Raises:**

- <code>[RuntimeError](#RuntimeError)</code> – If the requested session type is not available

###### `openhands.tools.execute_bash.terminal.factory.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.tools.execute_bash.terminal.interface`

Abstract interface for terminal backends.

**Classes:**

- [**TerminalInterface**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface) – Abstract interface for terminal backends.
- [**TerminalSessionBase**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase) – Abstract base class for terminal sessions.

###### `openhands.tools.execute_bash.terminal.interface.TerminalInterface`

```python
TerminalInterface(work_dir, username=None)
```

Bases: <code>[ABC](#abc.ABC)</code>

Abstract interface for terminal backends.

This interface abstracts the low-level terminal operations, allowing
different backends (tmux, subprocess, PowerShell) to be used with
the same high-level session controller logic.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.clear_screen) – Clear the terminal screen and history.
- [**close**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.close) – Clean up the terminal backend.
- [**initialize**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.initialize) – Initialize the terminal backend.
- [**interrupt**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.interrupt) – Send interrupt signal (Ctrl+C) to the terminal.
- [**is_powershell**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.is_running) – Check if a command is currently running in the terminal.
- [**read_screen**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.read_screen) – Read the current terminal screen content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.send_keys) – Send text/keys to the terminal.

**Attributes:**

- [**closed**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**username**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.interface.TerminalInterface.work_dir) –

Initialize the terminal interface.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the terminal
- **username** (<code>[str](#str) | None</code>) – Optional username for the terminal session

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.clear_screen`

```python
clear_screen()
```

Clear the terminal screen and history.

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.close`

```python
close()
```

Clean up the terminal backend.

This should properly terminate the terminal session and
clean up any resources.

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.closed`

```python
closed: bool
```

Check if the terminal is closed.

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.initialize`

```python
initialize()
```

Initialize the terminal backend.

This should set up the terminal session, configure the shell,
and prepare it for command execution.

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.interrupt`

```python
interrupt()
```

Send interrupt signal (Ctrl+C) to the terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was sent successfully, False otherwise

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.is_running`

```python
is_running()
```

Check if a command is currently running in the terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if a command is running, False otherwise

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.read_screen`

```python
read_screen()
```

Read the current terminal screen content.

**Returns:**

- <code>[str](#str)</code> – Current visible content of the terminal screen

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.send_keys`

```python
send_keys(text, enter=True)
```

Send text/keys to the terminal.

**Parameters:**

- **text** (<code>[str](#str)</code>) – Text or key sequence to send
- **enter** (<code>[bool](#bool)</code>) – Whether to send Enter key after the text

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.username`

```python
username = username
```

####### `openhands.tools.execute_bash.terminal.interface.TerminalInterface.work_dir`

```python
work_dir = work_dir
```

###### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase`

```python
TerminalSessionBase(work_dir, username=None, no_change_timeout_seconds=None)
```

Bases: <code>[ABC](#abc.ABC)</code>

Abstract base class for terminal sessions.

This class defines the common interface for all terminal session implementations,
including tmux-based, subprocess-based, and PowerShell-based sessions.

**Functions:**

- [**close**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.close) – Clean up the terminal session.
- [**execute**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.execute) – Execute a command in the terminal session.
- [**initialize**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.initialize) – Initialize the terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.interrupt) – Interrupt the currently running command (equivalent to Ctrl+C).
- [**is_running**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.is_running) – Check if a command is currently running.

**Attributes:**

- [**cwd**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.cwd) (<code>[str](#str)</code>) – Get the current working directory.
- [**no_change_timeout_seconds**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.no_change_timeout_seconds) –
- [**username**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.work_dir) –

Initialize the terminal session.

**Parameters:**

- **work_dir** (<code>[str](#str)</code>) – Working directory for the session
- **username** (<code>[str](#str) | None</code>) – Optional username for the session
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.close`

```python
close()
```

Clean up the terminal session.

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.cwd`

```python
cwd: str
```

Get the current working directory.

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.execute`

```python
execute(action)
```

Execute a command in the terminal session.

**Parameters:**

- **action** (<code>[ExecuteBashAction](#openhands.tools.execute_bash.definition.ExecuteBashAction)</code>) – The bash action to execute

**Returns:**

- <code>[ExecuteBashObservation](#openhands.tools.execute_bash.definition.ExecuteBashObservation)</code> – ExecuteBashObservation with the command result

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.initialize`

```python
initialize()
```

Initialize the terminal session.

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.interrupt`

```python
interrupt()
```

Interrupt the currently running command (equivalent to Ctrl+C).

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was successful, False otherwise

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.is_running`

```python
is_running()
```

Check if a command is currently running.

**Returns:**

- <code>[bool](#bool)</code> – True if a command is running, False otherwise

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.no_change_timeout_seconds`

```python
no_change_timeout_seconds = no_change_timeout_seconds
```

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.username`

```python
username = username
```

####### `openhands.tools.execute_bash.terminal.interface.TerminalSessionBase.work_dir`

```python
work_dir = work_dir
```

##### `openhands.tools.execute_bash.terminal.subprocess_terminal`

PTY-based terminal backend implementation (replaces pipe-based subprocess).

**Classes:**

- [**SubprocessTerminal**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal) – PTY-backed terminal backend.

**Attributes:**

- [**ENTER**](#openhands.tools.execute_bash.terminal.subprocess_terminal.ENTER) –
- [**logger**](#openhands.tools.execute_bash.terminal.subprocess_terminal.logger) –

###### `openhands.tools.execute_bash.terminal.subprocess_terminal.ENTER`

```python
ENTER = b'\n'
```

###### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal`

```python
SubprocessTerminal(work_dir, username=None)
```

Bases: <code>[TerminalInterface](#openhands.tools.execute_bash.terminal.TerminalInterface)</code>

PTY-backed terminal backend.

Creates an interactive bash in a pseudoterminal (PTY) so programs behave as if
attached to a real terminal. Initialization uses a sentinel-based handshake
and prompt detection instead of blind sleeps.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.clear_screen) – Drop buffered output up to the most recent PS1 block; do not emit ^L.
- [**close**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.close) – Clean up the PTY terminal.
- [**initialize**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.initialize) – Initialize the PTY terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.interrupt) – Send SIGINT to the PTY process group (fallback to signal-based interrupt).
- [**is_powershell**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.is_running) – Heuristic: command running if not at PS1 prompt and process alive.
- [**read_screen**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.read_screen) – Read the current terminal screen content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.send_keys) – Send keystrokes to the PTY.

**Attributes:**

- [**PS1**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.PS1) –
- [**closed**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**output_buffer**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.output_buffer) (<code>[Deque](#typing.Deque)\[[str](#str)\]</code>) –
- [**output_lock**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.output_lock) –
- [**process**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.process) (<code>[Popen](#subprocess.Popen) | None</code>) –
- [**reader_thread**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.reader_thread) (<code>[Thread](#threading.Thread) | None</code>) –
- [**username**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.work_dir) –

Initialize SubprocessTerminal with working directory and username.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.PS1`

```python
PS1 = CmdOutputMetadata.to_ps1_prompt()
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.clear_screen`

```python
clear_screen()
```

Drop buffered output up to the most recent PS1 block; do not emit ^L.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.close`

```python
close()
```

Clean up the PTY terminal.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.closed`

```python
closed: bool
```

Check if the terminal is closed.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.initialize`

```python
initialize()
```

Initialize the PTY terminal session.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.interrupt`

```python
interrupt()
```

Send SIGINT to the PTY process group (fallback to signal-based interrupt).

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.is_running`

```python
is_running()
```

Heuristic: command running if not at PS1 prompt and process alive.

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.output_buffer`

```python
output_buffer: Deque[str] = deque(maxlen=(HISTORY_LIMIT + 50))
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.output_lock`

```python
output_lock = threading.Lock()
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.process`

```python
process: subprocess.Popen | None = None
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.read_screen`

```python
read_screen()
```

Read the current terminal screen content.

The content we return should NOT contains carriage returns (CR, \\r).

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.reader_thread`

```python
reader_thread: threading.Thread | None = None
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.send_keys`

```python
send_keys(text, enter=True)
```

Send keystrokes to the PTY.

<details class="supports" open>
<summary>Supports</summary>
- Plain text
- Ctrl sequences: 'C-a'..'C-z' (Ctrl+C sends ^C byte)
- Special names: 'ENTER','TAB','BS','ESC','UP','DOWN','LEFT','RIGHT',
                 'HOME','END','PGUP','PGDN','C-L','C-D'
</details>

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.username`

```python
username = username
```

####### `openhands.tools.execute_bash.terminal.subprocess_terminal.SubprocessTerminal.work_dir`

```python
work_dir = work_dir
```

###### `openhands.tools.execute_bash.terminal.subprocess_terminal.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.tools.execute_bash.terminal.terminal_session`

Unified terminal session using TerminalInterface backends.

**Classes:**

- [**TerminalCommandStatus**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus) – Status of a terminal command execution.
- [**TerminalSession**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession) – Unified bash session that works with any TerminalInterface backend.

**Attributes:**

- [**logger**](#openhands.tools.execute_bash.terminal.terminal_session.logger) –

###### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus`

Bases: <code>[Enum](#enum.Enum)</code>

Status of a terminal command execution.

**Attributes:**

- [**COMPLETED**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.COMPLETED) –
- [**CONTINUE**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.CONTINUE) –
- [**HARD_TIMEOUT**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.HARD_TIMEOUT) –
- [**INTERRUPTED**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.INTERRUPTED) –
- [**NO_CHANGE_TIMEOUT**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.NO_CHANGE_TIMEOUT) –

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.COMPLETED`

```python
COMPLETED = 'completed'
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.CONTINUE`

```python
CONTINUE = 'continue'
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.HARD_TIMEOUT`

```python
HARD_TIMEOUT = 'hard_timeout'
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.INTERRUPTED`

```python
INTERRUPTED = 'interrupted'
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus.NO_CHANGE_TIMEOUT`

```python
NO_CHANGE_TIMEOUT = 'no_change_timeout'
```

###### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession`

```python
TerminalSession(terminal, no_change_timeout_seconds=None)
```

Bases: <code>[TerminalSessionBase](#openhands.tools.execute_bash.terminal.interface.TerminalSessionBase)</code>

Unified bash session that works with any TerminalInterface backend.

This class contains all the session controller logic (timeouts, command parsing,
output processing) while delegating terminal operations to the TerminalInterface.

**Functions:**

- [**close**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.close) – Clean up the terminal backend.
- [**execute**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.execute) – Execute a command using the terminal backend.
- [**initialize**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.initialize) – Initialize the terminal backend.
- [**interrupt**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.interrupt) – Interrupt the currently running command (equivalent to Ctrl+C).
- [**is_running**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.is_running) – Check if a command is currently running.

**Attributes:**

- [**cwd**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.cwd) (<code>[str](#str)</code>) – Get the current working directory.
- [**no_change_timeout_seconds**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.no_change_timeout_seconds) –
- [**prev_output**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.prev_output) (<code>[str](#str)</code>) –
- [**prev_status**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.prev_status) (<code>[TerminalCommandStatus](#openhands.tools.execute_bash.terminal.terminal_session.TerminalCommandStatus) | None</code>) –
- [**terminal**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.terminal) –
- [**username**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.work_dir) –

Initialize the unified session with a terminal backend.

**Parameters:**

- **terminal** (<code>[TerminalInterface](#openhands.tools.execute_bash.terminal.interface.TerminalInterface)</code>) – The terminal backend to use
- **no_change_timeout_seconds** (<code>[int](#int) | None</code>) – Timeout for no output change

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.close`

```python
close()
```

Clean up the terminal backend.

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.cwd`

```python
cwd: str
```

Get the current working directory.

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.execute`

```python
execute(action)
```

Execute a command using the terminal backend.

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.initialize`

```python
initialize()
```

Initialize the terminal backend.

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.interrupt`

```python
interrupt()
```

Interrupt the currently running command (equivalent to Ctrl+C).

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.is_running`

```python
is_running()
```

Check if a command is currently running.

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.no_change_timeout_seconds`

```python
no_change_timeout_seconds = no_change_timeout_seconds or NO_CHANGE_TIMEOUT_SECONDS
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.prev_output`

```python
prev_output: str = ''
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.prev_status`

```python
prev_status: TerminalCommandStatus | None = None
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.terminal`

```python
terminal = terminal
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.username`

```python
username = username
```

####### `openhands.tools.execute_bash.terminal.terminal_session.TerminalSession.work_dir`

```python
work_dir = work_dir
```

###### `openhands.tools.execute_bash.terminal.terminal_session.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.tools.execute_bash.terminal.tmux_terminal`

Tmux-based terminal backend implementation.

**Classes:**

- [**TmuxTerminal**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal) – Tmux-based terminal backend.

**Attributes:**

- [**logger**](#openhands.tools.execute_bash.terminal.tmux_terminal.logger) –

###### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal`

```python
TmuxTerminal(work_dir, username=None)
```

Bases: <code>[TerminalInterface](#openhands.tools.execute_bash.terminal.TerminalInterface)</code>

Tmux-based terminal backend.

This backend uses tmux to provide a persistent terminal session
with full screen capture and history management capabilities.

**Functions:**

- [**clear_screen**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.clear_screen) – Clear the tmux pane screen and history.
- [**close**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.close) – Clean up the tmux session.
- [**initialize**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.initialize) – Initialize the tmux terminal session.
- [**interrupt**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.interrupt) – Send interrupt signal (Ctrl+C) to the tmux pane.
- [**is_powershell**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.is_powershell) – Check if this is a PowerShell terminal.
- [**is_running**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.is_running) – Check if a command is currently running.
- [**read_screen**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.read_screen) – Read the current tmux pane content.
- [**send_keys**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.send_keys) – Send text/keys to the tmux pane.

**Attributes:**

- [**PS1**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.PS1) –
- [**closed**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.closed) (<code>[bool](#bool)</code>) – Check if the terminal is closed.
- [**initialized**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.initialized) (<code>[bool](#bool)</code>) – Check if the terminal is initialized.
- [**username**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.username) –
- [**work_dir**](#openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.work_dir) –

Initialize the tmux terminal with working directory and username.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.PS1`

```python
PS1 = CmdOutputMetadata.to_ps1_prompt()
```

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.clear_screen`

```python
clear_screen()
```

Clear the tmux pane screen and history.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.close`

```python
close()
```

Clean up the tmux session.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.closed`

```python
closed: bool
```

Check if the terminal is closed.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.initialize`

```python
initialize()
```

Initialize the tmux terminal session.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.initialized`

```python
initialized: bool
```

Check if the terminal is initialized.

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.interrupt`

```python
interrupt()
```

Send interrupt signal (Ctrl+C) to the tmux pane.

**Returns:**

- <code>[bool](#bool)</code> – True if interrupt was sent successfully, False otherwise

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.is_powershell`

```python
is_powershell()
```

Check if this is a PowerShell terminal.

**Returns:**

- <code>[bool](#bool)</code> – True if this is a PowerShell terminal, False otherwise

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.is_running`

```python
is_running()
```

Check if a command is currently running.

For tmux, we determine this by checking if the terminal
is ready for new commands (ends with prompt).

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.read_screen`

```python
read_screen()
```

Read the current tmux pane content.

**Returns:**

- <code>[str](#str)</code> – Current visible content of the tmux pane

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.send_keys`

```python
send_keys(text, enter=True)
```

Send text/keys to the tmux pane.

**Parameters:**

- **text** (<code>[str](#str)</code>) – Text or key sequence to send
- **enter** (<code>[bool](#bool)</code>) – Whether to send Enter key after the text

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.username`

```python
username = username
```

####### `openhands.tools.execute_bash.terminal.tmux_terminal.TmuxTerminal.work_dir`

```python
work_dir = work_dir
```

###### `openhands.tools.execute_bash.terminal.tmux_terminal.logger`

```python
logger = get_logger(__name__)
```

### `openhands.tools.execute_bash_tool`

```python
execute_bash_tool = Tool(name='execute_bash', action_type=ExecuteBashAction, observation_type=ExecuteBashObservation, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='execute_bash', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=True)))
```

### `openhands.tools.str_replace_editor`

String replace editor tool for file editing operations.

**Modules:**

- [**definition**](#openhands.tools.str_replace_editor.definition) – String replace editor tool implementation.
- [**editor**](#openhands.tools.str_replace_editor.editor) – File editor implementation for viewing, creating, and editing files.
- [**exceptions**](#openhands.tools.str_replace_editor.exceptions) – Exception classes for the str_replace_editor tool.
- [**impl**](#openhands.tools.str_replace_editor.impl) – File editor tool implementation and executor.
- [**utils**](#openhands.tools.str_replace_editor.utils) – Utility functions for the string replace editor tool.

**Classes:**

- [**FileEditorExecutor**](#openhands.tools.str_replace_editor.FileEditorExecutor) – Executor for file editor operations.
- [**FileEditorTool**](#openhands.tools.str_replace_editor.FileEditorTool) – A Tool subclass that automatically initializes a FileEditorExecutor.
- [**StrReplaceEditorAction**](#openhands.tools.str_replace_editor.StrReplaceEditorAction) – Schema for string replace editor operations.
- [**StrReplaceEditorObservation**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation) – A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**file_editor**](#openhands.tools.str_replace_editor.file_editor) – Execute file editing operations using a global FileEditor instance.

**Attributes:**

- [**str_replace_editor_tool**](#openhands.tools.str_replace_editor.str_replace_editor_tool) –

#### `openhands.tools.str_replace_editor.FileEditorExecutor`

```python
FileEditorExecutor(workspace_root=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for file editor operations.

**Functions:**

- [**close**](#openhands.tools.str_replace_editor.FileEditorExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**editor**](#openhands.tools.str_replace_editor.FileEditorExecutor.editor) –

Initialize the file editor executor.

##### `openhands.tools.str_replace_editor.FileEditorExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.tools.str_replace_editor.FileEditorExecutor.editor`

```python
editor = FileEditor(workspace_root=workspace_root)
```

#### `openhands.tools.str_replace_editor.FileEditorTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[StrReplaceEditorAction](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction), [StrReplaceEditorObservation](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation)\]</code>

A Tool subclass that automatically initializes a FileEditorExecutor.

**Functions:**

- [**call**](#openhands.tools.str_replace_editor.FileEditorTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.str_replace_editor.FileEditorTool.create) – Initialize FileEditorTool with a FileEditorExecutor.
- [**model_validate**](#openhands.tools.str_replace_editor.FileEditorTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.FileEditorTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.str_replace_editor.FileEditorTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.str_replace_editor.FileEditorTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.str_replace_editor.FileEditorTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.str_replace_editor.FileEditorTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.str_replace_editor.FileEditorTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.str_replace_editor.FileEditorTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.str_replace_editor.FileEditorTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.str_replace_editor.FileEditorTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.str_replace_editor.FileEditorTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.str_replace_editor.FileEditorTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.str_replace_editor.FileEditorTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.str_replace_editor.FileEditorTool.model_config) –
- [**name**](#openhands.tools.str_replace_editor.FileEditorTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.str_replace_editor.FileEditorTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.str_replace_editor.FileEditorTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.str_replace_editor.FileEditorTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

##### `openhands.tools.str_replace_editor.FileEditorTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

##### `openhands.tools.str_replace_editor.FileEditorTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

##### `openhands.tools.str_replace_editor.FileEditorTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

##### `openhands.tools.str_replace_editor.FileEditorTool.create`

```python
create(workspace_root=None)
```

Initialize FileEditorTool with a FileEditorExecutor.

##### `openhands.tools.str_replace_editor.FileEditorTool.description`

```python
description: str
```

##### `openhands.tools.str_replace_editor.FileEditorTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.tools.str_replace_editor.FileEditorTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

##### `openhands.tools.str_replace_editor.FileEditorTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.str_replace_editor.FileEditorTool.meta`

```python
meta: dict[str, Any] | None = None
```

##### `openhands.tools.str_replace_editor.FileEditorTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.tools.str_replace_editor.FileEditorTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.str_replace_editor.FileEditorTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.str_replace_editor.FileEditorTool.name`

```python
name: str
```

##### `openhands.tools.str_replace_editor.FileEditorTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

##### `openhands.tools.str_replace_editor.FileEditorTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

##### `openhands.tools.str_replace_editor.FileEditorTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

##### `openhands.tools.str_replace_editor.FileEditorTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.str_replace_editor.FileEditorTool.title`

```python
title: str
```

Get the title for the tool.

##### `openhands.tools.str_replace_editor.FileEditorTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

##### `openhands.tools.str_replace_editor.FileEditorTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

#### `openhands.tools.str_replace_editor.StrReplaceEditorAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for string replace editor operations.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**file_text**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.file_text) (<code>[str](#str) | None</code>) –
- [**insert_line**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.insert_line) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.model_config) –
- [**new_str**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.new_str) (<code>[str](#str) | None</code>) –
- [**old_str**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.old_str) (<code>[str](#str) | None</code>) –
- [**path**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.path) (<code>[str](#str)</code>) –
- [**security_risk**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**view_range**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.view_range) (<code>[list](#list)\[[int](#int)\] | None</code>) –
- [**visualize**](#openhands.tools.str_replace_editor.StrReplaceEditorAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.file_text`

```python
file_text: str | None = Field(default=None, description='Required parameter of `create` command, with the content of the file to be created.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.insert_line`

```python
insert_line: int | None = Field(default=None, description='Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.new_str`

```python
new_str: str | None = Field(default=None, description='Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.old_str`

```python
old_str: str | None = Field(default=None, description='Required parameter of `str_replace` command containing the string in `path` to replace.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.path`

```python
path: str = Field(description='Absolute path to file or directory, e.g. `/workspace/file.py` or `/workspace`.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.view_range`

```python
view_range: list[int] | None = Field(default=None, description='Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorAction.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

#### `openhands.tools.str_replace_editor.StrReplaceEditorObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with output or error message.
- [**command**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**error**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.error) (<code>[str](#str) | None</code>) –
- [**kind**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_config) –
- [**new_content**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.new_content) (<code>[str](#str) | None</code>) –
- [**old_content**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.old_content) (<code>[str](#str) | None</code>) –
- [**output**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.output) (<code>[str](#str)</code>) –
- [**path**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.path) (<code>[str](#str) | None</code>) –
- [**prev_exist**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.prev_exist) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.str_replace_editor.StrReplaceEditorObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this observation.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with output or error message.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.error`

```python
error: str | None = Field(default=None, description='Error message if any.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.new_content`

```python
new_content: str | None = Field(default=None, description='The content of the file after the edit.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.old_content`

```python
old_content: str | None = Field(default=None, description='The content of the file before the edit.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.output`

```python
output: str = Field(default='', description='The output message from the tool for the LLM to see.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.path`

```python
path: str | None = Field(default=None, description='The file path that was edited.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.prev_exist`

```python
prev_exist: bool = Field(default=True, description='Indicates if the file previously existed. If not, it was created.')
```

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.str_replace_editor.StrReplaceEditorObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this observation.

Shows diff visualization for meaningful changes (file creation, successful
edits), otherwise falls back to agent observation.

#### `openhands.tools.str_replace_editor.definition`

String replace editor tool implementation.

**Classes:**

- [**FileEditorTool**](#openhands.tools.str_replace_editor.definition.FileEditorTool) – A Tool subclass that automatically initializes a FileEditorExecutor.
- [**StrReplaceEditorAction**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction) – Schema for string replace editor operations.
- [**StrReplaceEditorObservation**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation) – A ToolResult that can be rendered as a CLI output.

**Attributes:**

- [**Command**](#openhands.tools.str_replace_editor.definition.Command) –
- [**CommandLiteral**](#openhands.tools.str_replace_editor.definition.CommandLiteral) –
- [**TOOL_DESCRIPTION**](#openhands.tools.str_replace_editor.definition.TOOL_DESCRIPTION) –
- [**str_replace_editor_tool**](#openhands.tools.str_replace_editor.definition.str_replace_editor_tool) –

##### `openhands.tools.str_replace_editor.definition.Command`

```python
Command = Literal['view', 'create', 'str_replace', 'insert', 'undo_edit']
```

##### `openhands.tools.str_replace_editor.definition.CommandLiteral`

```python
CommandLiteral = Literal['view', 'create', 'str_replace', 'insert', 'undo_edit']
```

##### `openhands.tools.str_replace_editor.definition.FileEditorTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[StrReplaceEditorAction](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction), [StrReplaceEditorObservation](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation)\]</code>

A Tool subclass that automatically initializes a FileEditorExecutor.

**Functions:**

- [**call**](#openhands.tools.str_replace_editor.definition.FileEditorTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.str_replace_editor.definition.FileEditorTool.create) – Initialize FileEditorTool with a FileEditorExecutor.
- [**model_validate**](#openhands.tools.str_replace_editor.definition.FileEditorTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.definition.FileEditorTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.str_replace_editor.definition.FileEditorTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.str_replace_editor.definition.FileEditorTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.str_replace_editor.definition.FileEditorTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.str_replace_editor.definition.FileEditorTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.str_replace_editor.definition.FileEditorTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.str_replace_editor.definition.FileEditorTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.str_replace_editor.definition.FileEditorTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.str_replace_editor.definition.FileEditorTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.str_replace_editor.definition.FileEditorTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.str_replace_editor.definition.FileEditorTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.str_replace_editor.definition.FileEditorTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.str_replace_editor.definition.FileEditorTool.model_config) –
- [**name**](#openhands.tools.str_replace_editor.definition.FileEditorTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.str_replace_editor.definition.FileEditorTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.str_replace_editor.definition.FileEditorTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.str_replace_editor.definition.FileEditorTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.create`

```python
create(workspace_root=None)
```

Initialize FileEditorTool with a FileEditorExecutor.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.description`

```python
description: str
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.meta`

```python
meta: dict[str, Any] | None = None
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.name`

```python
name: str
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.title`

```python
title: str
```

Get the title for the tool.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

###### `openhands.tools.str_replace_editor.definition.FileEditorTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

##### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

Schema for string replace editor operations.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**file_text**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.file_text) (<code>[str](#str) | None</code>) –
- [**insert_line**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.insert_line) (<code>[int](#int) | None</code>) –
- [**kind**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_config) –
- [**new_str**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.new_str) (<code>[str](#str) | None</code>) –
- [**old_str**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.old_str) (<code>[str](#str) | None</code>) –
- [**path**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.path) (<code>[str](#str)</code>) –
- [**security_risk**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**view_range**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.view_range) (<code>[list](#list)\[[int](#int)\] | None</code>) –
- [**visualize**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this action.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.file_text`

```python
file_text: str | None = Field(default=None, description='Required parameter of `create` command, with the content of the file to be created.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.insert_line`

```python
insert_line: int | None = Field(default=None, description='Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.new_str`

```python
new_str: str | None = Field(default=None, description='Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.old_str`

```python
old_str: str | None = Field(default=None, description='Required parameter of `str_replace` command containing the string in `path` to replace.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.path`

```python
path: str = Field(description='Absolute path to file or directory, e.g. `/workspace/file.py` or `/workspace`.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.view_range`

```python
view_range: list[int] | None = Field(default=None, description='Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorAction.visualize`

```python
visualize: Text
```

Return Rich Text representation of this action.

This method can be overridden by subclasses to customize visualization.
The base implementation displays all action fields systematically.

##### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

A ToolResult that can be rendered as a CLI output.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.llm.TextContent) | [ImageContent](#openhands.sdk.llm.ImageContent)\]</code>) – Get the agent observation with output or error message.
- [**command**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.command) (<code>[CommandLiteral](#openhands.tools.str_replace_editor.definition.CommandLiteral)</code>) –
- [**error**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.error) (<code>[str](#str) | None</code>) –
- [**kind**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_config) –
- [**new_content**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.new_content) (<code>[str](#str) | None</code>) –
- [**old_content**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.old_content) (<code>[str](#str) | None</code>) –
- [**output**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.output) (<code>[str](#str)</code>) –
- [**path**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.path) (<code>[str](#str) | None</code>) –
- [**prev_exist**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.prev_exist) (<code>[bool](#bool)</code>) –
- [**visualize**](#openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation of this observation.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Get the agent observation with output or error message.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.command`

```python
command: CommandLiteral = Field(description='The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.error`

```python
error: str | None = Field(default=None, description='Error message if any.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.new_content`

```python
new_content: str | None = Field(default=None, description='The content of the file after the edit.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.old_content`

```python
old_content: str | None = Field(default=None, description='The content of the file before the edit.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.output`

```python
output: str = Field(default='', description='The output message from the tool for the LLM to see.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.path`

```python
path: str | None = Field(default=None, description='The file path that was edited.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.prev_exist`

```python
prev_exist: bool = Field(default=True, description='Indicates if the file previously existed. If not, it was created.')
```

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.str_replace_editor.definition.StrReplaceEditorObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation of this observation.

Shows diff visualization for meaningful changes (file creation, successful
edits), otherwise falls back to agent observation.

##### `openhands.tools.str_replace_editor.definition.TOOL_DESCRIPTION`

```python
TOOL_DESCRIPTION = 'Custom editing tool for viewing, creating and editing files in plain-text format\n* State is persistent across command calls and discussions with the user\n* If `path` is a text file, `view` displays the result of applying `cat -n`. If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep\n* The following binary file extensions can be viewed in Markdown format: [".xlsx", ".pptx", ".wav", ".mp3", ".m4a", ".flac", ".pdf", ".docx"]. IT DOES NOT HANDLE IMAGES.\n* The `create` command cannot be used if the specified `path` already exists as a file\n* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`\n* The `undo_edit` command will revert the last edit made to the file at `path`\n* This tool can be used for creating and editing files in plain-text format.\n\n\nBefore using this tool:\n1. Use the view tool to understand the file\'s contents and context\n2. Verify the directory path is correct (only applicable when creating new files):\n   - Use the view tool to verify the parent directory exists and is the correct location\n\nWhen making edits:\n   - Ensure the edit results in idiomatic, correct code\n   - Do not leave the code in a broken state\n   - Always use absolute file paths (starting with /)\n\nCRITICAL REQUIREMENTS FOR USING THIS TOOL:\n\n1. EXACT MATCHING: The `old_str` parameter must match EXACTLY one or more consecutive lines from the file, including all whitespace and indentation. The tool will fail if `old_str` matches multiple locations or doesn\'t match exactly with the file content.\n\n2. UNIQUENESS: The `old_str` must uniquely identify a single instance in the file:\n   - Include sufficient context before and after the change point (3-5 lines recommended)\n   - If not unique, the replacement will not be performed\n\n3. REPLACEMENT: The `new_str` parameter should contain the edited lines that replace the `old_str`. Both strings must be different.\n\nRemember: when making multiple file edits in a row to the same file, you should prefer to send all edits in a single message with multiple calls to this tool, rather than multiple messages with a single call each.\n'
```

##### `openhands.tools.str_replace_editor.definition.str_replace_editor_tool`

```python
str_replace_editor_tool = Tool(name='str_replace_editor', action_type=StrReplaceEditorAction, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='str_replace_editor', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=False)))
```

#### `openhands.tools.str_replace_editor.editor`

File editor implementation for viewing, creating, and editing files.

**Classes:**

- [**FileEditor**](#openhands.tools.str_replace_editor.editor.FileEditor) – A filesystem editor tool for viewing, creating, navigating, and editing files.

##### `openhands.tools.str_replace_editor.editor.FileEditor`

```python
FileEditor(workspace_root=None, max_file_size_mb=None)
```

A filesystem editor tool for viewing, creating, navigating, and editing files.

**Functions:**

- [**insert**](#openhands.tools.str_replace_editor.editor.FileEditor.insert) – Insert text at a specified line in a file.
- [**read_file**](#openhands.tools.str_replace_editor.editor.FileEditor.read_file) – Read content from a file.
- [**str_replace**](#openhands.tools.str_replace_editor.editor.FileEditor.str_replace) – Replace old_str with new_str in the file content.
- [**undo_edit**](#openhands.tools.str_replace_editor.editor.FileEditor.undo_edit) – Implement the undo_edit command.
- [**validate_file**](#openhands.tools.str_replace_editor.editor.FileEditor.validate_file) – Validate a file for reading or editing operations.
- [**validate_path**](#openhands.tools.str_replace_editor.editor.FileEditor.validate_path) – Check that the path/command combination is valid.
- [**view**](#openhands.tools.str_replace_editor.editor.FileEditor.view) – View the contents of a file or a directory.
- [**write_file**](#openhands.tools.str_replace_editor.editor.FileEditor.write_file) – Write content to a file.

**Attributes:**

- [**MAX_FILE_SIZE_MB**](#openhands.tools.str_replace_editor.editor.FileEditor.MAX_FILE_SIZE_MB) –

Initialize the editor.

**Parameters:**

- **max_file_size_mb** (<code>[int](#int) | None</code>) – Maximum file size in MB. If None, uses the default
  MAX_FILE_SIZE_MB.
- **workspace_root** (<code>[str](#str) | None</code>) – Root directory that serves as the current working
  directory for relative path suggestions. Must be an absolute path.
  If None, no path suggestions will be provided for relative paths.

###### `openhands.tools.str_replace_editor.editor.FileEditor.MAX_FILE_SIZE_MB`

```python
MAX_FILE_SIZE_MB = 10
```

###### `openhands.tools.str_replace_editor.editor.FileEditor.insert`

```python
insert(path, insert_line, new_str, encoding='utf-8')
```

Insert text at a specified line in a file.

###### `openhands.tools.str_replace_editor.editor.FileEditor.read_file`

```python
read_file(path, start_line=None, end_line=None, encoding='utf-8')
```

Read content from a file.

###### `openhands.tools.str_replace_editor.editor.FileEditor.str_replace`

```python
str_replace(path, old_str, new_str)
```

Replace old_str with new_str in the file content.

###### `openhands.tools.str_replace_editor.editor.FileEditor.undo_edit`

```python
undo_edit(path)
```

Implement the undo_edit command.

###### `openhands.tools.str_replace_editor.editor.FileEditor.validate_file`

```python
validate_file(path)
```

Validate a file for reading or editing operations.

**Parameters:**

- **path** (<code>[Path](#pathlib.Path)</code>) – Path to the file to validate

**Raises:**

- <code>[FileValidationError](#openhands.tools.str_replace_editor.exceptions.FileValidationError)</code> – If the file fails validation

###### `openhands.tools.str_replace_editor.editor.FileEditor.validate_path`

```python
validate_path(command, path)
```

Check that the path/command combination is valid.

Validates:

1. Path is absolute
1. Path and command are compatible

###### `openhands.tools.str_replace_editor.editor.FileEditor.view`

```python
view(path, view_range=None)
```

View the contents of a file or a directory.

###### `openhands.tools.str_replace_editor.editor.FileEditor.write_file`

```python
write_file(path, file_text, encoding='utf-8')
```

Write content to a file.

#### `openhands.tools.str_replace_editor.exceptions`

Exception classes for the str_replace_editor tool.

**Classes:**

- [**EditorToolParameterInvalidError**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError) – Raised when a parameter is invalid for a tool command.
- [**EditorToolParameterMissingError**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError) – Raised when a required parameter is missing for a tool command.
- [**FileValidationError**](#openhands.tools.str_replace_editor.exceptions.FileValidationError) – Raised when a file fails validation checks (size, type, etc.).
- [**ToolError**](#openhands.tools.str_replace_editor.exceptions.ToolError) – Raised when a tool encounters an error.

##### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError`

```python
EditorToolParameterInvalidError(parameter, value, hint=None)
```

Bases: <code>[ToolError](#openhands.tools.str_replace_editor.exceptions.ToolError)</code>

Raised when a parameter is invalid for a tool command.

**Attributes:**

- [**message**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.message) –
- [**parameter**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.parameter) –
- [**value**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.value) –

Initialize EditorToolParameterInvalidError with parameter details.

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.message`

```python
message = f'Invalid `{parameter}` parameter: {value}. {hint}' if hint else f'Invalid `{parameter}` parameter: {value}.'
```

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.parameter`

```python
parameter = parameter
```

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterInvalidError.value`

```python
value = value
```

##### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError`

```python
EditorToolParameterMissingError(command, parameter)
```

Bases: <code>[ToolError](#openhands.tools.str_replace_editor.exceptions.ToolError)</code>

Raised when a required parameter is missing for a tool command.

**Attributes:**

- [**command**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.command) –
- [**message**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.message) –
- [**parameter**](#openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.parameter) –

Initialize EditorToolParameterMissingError with command and parameter.

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.command`

```python
command = command
```

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.message`

```python
message = f'Parameter `{parameter}` is required for command: {command}.'
```

###### `openhands.tools.str_replace_editor.exceptions.EditorToolParameterMissingError.parameter`

```python
parameter = parameter
```

##### `openhands.tools.str_replace_editor.exceptions.FileValidationError`

```python
FileValidationError(path, reason)
```

Bases: <code>[ToolError](#openhands.tools.str_replace_editor.exceptions.ToolError)</code>

Raised when a file fails validation checks (size, type, etc.).

**Attributes:**

- [**message**](#openhands.tools.str_replace_editor.exceptions.FileValidationError.message) –
- [**path**](#openhands.tools.str_replace_editor.exceptions.FileValidationError.path) –
- [**reason**](#openhands.tools.str_replace_editor.exceptions.FileValidationError.reason) –

Initialize FileValidationError with path and reason.

###### `openhands.tools.str_replace_editor.exceptions.FileValidationError.message`

```python
message = f'File validation failed for {path}: {reason}'
```

###### `openhands.tools.str_replace_editor.exceptions.FileValidationError.path`

```python
path = path
```

###### `openhands.tools.str_replace_editor.exceptions.FileValidationError.reason`

```python
reason = reason
```

##### `openhands.tools.str_replace_editor.exceptions.ToolError`

```python
ToolError(message)
```

Bases: <code>[Exception](#Exception)</code>

Raised when a tool encounters an error.

**Attributes:**

- [**message**](#openhands.tools.str_replace_editor.exceptions.ToolError.message) –

Initialize ToolError with a message.

###### `openhands.tools.str_replace_editor.exceptions.ToolError.message`

```python
message = message
```

#### `openhands.tools.str_replace_editor.file_editor`

```python
file_editor(command, path, file_text=None, view_range=None, old_str=None, new_str=None, insert_line=None)
```

Execute file editing operations using a global FileEditor instance.

#### `openhands.tools.str_replace_editor.impl`

File editor tool implementation and executor.

**Classes:**

- [**FileEditorExecutor**](#openhands.tools.str_replace_editor.impl.FileEditorExecutor) – Executor for file editor operations.

**Functions:**

- [**file_editor**](#openhands.tools.str_replace_editor.impl.file_editor) – Execute file editing operations using a global FileEditor instance.

##### `openhands.tools.str_replace_editor.impl.FileEditorExecutor`

```python
FileEditorExecutor(workspace_root=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for file editor operations.

**Functions:**

- [**close**](#openhands.tools.str_replace_editor.impl.FileEditorExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**editor**](#openhands.tools.str_replace_editor.impl.FileEditorExecutor.editor) –

Initialize the file editor executor.

###### `openhands.tools.str_replace_editor.impl.FileEditorExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

###### `openhands.tools.str_replace_editor.impl.FileEditorExecutor.editor`

```python
editor = FileEditor(workspace_root=workspace_root)
```

##### `openhands.tools.str_replace_editor.impl.file_editor`

```python
file_editor(command, path, file_text=None, view_range=None, old_str=None, new_str=None, insert_line=None)
```

Execute file editing operations using a global FileEditor instance.

#### `openhands.tools.str_replace_editor.str_replace_editor_tool`

```python
str_replace_editor_tool = Tool(name='str_replace_editor', action_type=StrReplaceEditorAction, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='str_replace_editor', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=False)))
```

#### `openhands.tools.str_replace_editor.utils`

Utility functions for the string replace editor tool.

**Modules:**

- [**config**](#openhands.tools.str_replace_editor.utils.config) – Configuration constants for the string replace editor tool.
- [**constants**](#openhands.tools.str_replace_editor.utils.constants) – Constants for the string replace editor tool.
- [**diff**](#openhands.tools.str_replace_editor.utils.diff) – Utilities for generating and visualizing diffs.
- [**encoding**](#openhands.tools.str_replace_editor.utils.encoding) – Encoding management for file operations.
- [**file_cache**](#openhands.tools.str_replace_editor.utils.file_cache) – File-based cache implementation with size limits and LRU eviction.
- [**history**](#openhands.tools.str_replace_editor.utils.history) – History management for file edits with disk-based storage and memory constraints.
- [**shell**](#openhands.tools.str_replace_editor.utils.shell) – Shell command utilities for the str_replace_editor tool.

##### `openhands.tools.str_replace_editor.utils.config`

Configuration constants for the string replace editor tool.

**Attributes:**

- [**MAX_RESPONSE_LEN_CHAR**](#openhands.tools.str_replace_editor.utils.config.MAX_RESPONSE_LEN_CHAR) (<code>[int](#int)</code>) –
- [**SNIPPET_CONTEXT_WINDOW**](#openhands.tools.str_replace_editor.utils.config.SNIPPET_CONTEXT_WINDOW) (<code>[int](#int)</code>) –

###### `openhands.tools.str_replace_editor.utils.config.MAX_RESPONSE_LEN_CHAR`

```python
MAX_RESPONSE_LEN_CHAR: int = 16000
```

###### `openhands.tools.str_replace_editor.utils.config.SNIPPET_CONTEXT_WINDOW`

```python
SNIPPET_CONTEXT_WINDOW: int = 4
```

##### `openhands.tools.str_replace_editor.utils.constants`

Constants for the string replace editor tool.

**Attributes:**

- [**BINARY_FILE_CONTENT_TRUNCATED_NOTICE**](#openhands.tools.str_replace_editor.utils.constants.BINARY_FILE_CONTENT_TRUNCATED_NOTICE) (<code>[str](#str)</code>) –
- [**CONTENT_TRUNCATED_NOTICE**](#openhands.tools.str_replace_editor.utils.constants.CONTENT_TRUNCATED_NOTICE) –
- [**DIRECTORY_CONTENT_TRUNCATED_NOTICE**](#openhands.tools.str_replace_editor.utils.constants.DIRECTORY_CONTENT_TRUNCATED_NOTICE) (<code>[str](#str)</code>) –
- [**MAX_RESPONSE_LEN_CHAR**](#openhands.tools.str_replace_editor.utils.constants.MAX_RESPONSE_LEN_CHAR) (<code>[int](#int)</code>) –
- [**TEXT_FILE_CONTENT_TRUNCATED_NOTICE**](#openhands.tools.str_replace_editor.utils.constants.TEXT_FILE_CONTENT_TRUNCATED_NOTICE) (<code>[str](#str)</code>) –

###### `openhands.tools.str_replace_editor.utils.constants.BINARY_FILE_CONTENT_TRUNCATED_NOTICE`

```python
BINARY_FILE_CONTENT_TRUNCATED_NOTICE: str = '<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. Please use Python libraries to view the entire file or search for specific content within the file.</NOTE>'
```

###### `openhands.tools.str_replace_editor.utils.constants.CONTENT_TRUNCATED_NOTICE`

```python
CONTENT_TRUNCATED_NOTICE = '<response clipped><NOTE>Due to the max output limit, only part of the full response has been shown to you.</NOTE>'
```

###### `openhands.tools.str_replace_editor.utils.constants.DIRECTORY_CONTENT_TRUNCATED_NOTICE`

```python
DIRECTORY_CONTENT_TRUNCATED_NOTICE: str = '<response clipped><NOTE>Due to the max output limit, only part of this directory has been shown to you. You should use `ls -la` instead to view large directories incrementally.</NOTE>'
```

###### `openhands.tools.str_replace_editor.utils.constants.MAX_RESPONSE_LEN_CHAR`

```python
MAX_RESPONSE_LEN_CHAR: int = 16000
```

###### `openhands.tools.str_replace_editor.utils.constants.TEXT_FILE_CONTENT_TRUNCATED_NOTICE`

```python
TEXT_FILE_CONTENT_TRUNCATED_NOTICE: str = '<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>'
```

##### `openhands.tools.str_replace_editor.utils.diff`

Utilities for generating and visualizing diffs.

**Classes:**

- [**EditGroup**](#openhands.tools.str_replace_editor.utils.diff.EditGroup) – Group of edits showing before and after changes.

**Functions:**

- [**get_edit_groups**](#openhands.tools.str_replace_editor.utils.diff.get_edit_groups) – Get the edit groups showing changes between old and new content.
- [**visualize_diff**](#openhands.tools.str_replace_editor.utils.diff.visualize_diff) – Visualize the diff of the string replacement edit.

###### `openhands.tools.str_replace_editor.utils.diff.EditGroup`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

Group of edits showing before and after changes.

**Attributes:**

- [**after_edits**](#openhands.tools.str_replace_editor.utils.diff.EditGroup.after_edits) (<code>[list](#list)\[[str](#str)\]</code>) –
- [**before_edits**](#openhands.tools.str_replace_editor.utils.diff.EditGroup.before_edits) (<code>[list](#list)\[[str](#str)\]</code>) –

####### `openhands.tools.str_replace_editor.utils.diff.EditGroup.after_edits`

```python
after_edits: list[str]
```

####### `openhands.tools.str_replace_editor.utils.diff.EditGroup.before_edits`

```python
before_edits: list[str]
```

###### `openhands.tools.str_replace_editor.utils.diff.get_edit_groups`

```python
get_edit_groups(old_content, new_content, n_context_lines=2)
```

Get the edit groups showing changes between old and new content.

**Parameters:**

- **old_content** (<code>[str](#str) | None</code>) – The original content to compare.
- **new_content** (<code>[str](#str) | None</code>) – The new content to compare against.
- **n_context_lines** (<code>[int](#int)</code>) – Number of context lines to show around each change.

**Returns:**

- <code>[list](#list)\[[EditGroup](#openhands.tools.str_replace_editor.utils.diff.EditGroup)\]</code> – A list of edit groups, where each group contains before/after edits.

###### `openhands.tools.str_replace_editor.utils.diff.visualize_diff`

```python
visualize_diff(path, old_content, new_content, n_context_lines=2, change_applied=True)
```

Visualize the diff of the string replacement edit.

Instead of showing the diff line by line, this function shows each hunk
of changes as a separate entity.

**Parameters:**

- **path** (<code>[str](#str)</code>) – The file path being edited.
- **old_content** (<code>[str](#str) | None</code>) – The original content before changes.
- **new_content** (<code>[str](#str) | None</code>) – The new content after changes.
- **n_context_lines** (<code>[int](#int)</code>) – Number of context lines to show before/after changes.
- **change_applied** (<code>[bool](#bool)</code>) – Whether changes are applied. If false, shows as
  attempted edit.

**Returns:**

- <code>[Text](#rich.text.Text)</code> – A string containing the formatted diff visualization.

##### `openhands.tools.str_replace_editor.utils.encoding`

Encoding management for file operations.

**Classes:**

- [**EncodingManager**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager) – Manages file encodings across multiple operations to ensure consistency.

**Functions:**

- [**with_encoding**](#openhands.tools.str_replace_editor.utils.encoding.with_encoding) – Handle file encoding for file operations.

###### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager`

```python
EncodingManager(max_cache_size=None)
```

Manages file encodings across multiple operations to ensure consistency.

**Functions:**

- [**detect_encoding**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager.detect_encoding) – Detect the encoding of a file without handling caching logic.
- [**get_encoding**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager.get_encoding) – Get encoding for a file, using cache or detecting if necessary.

**Attributes:**

- [**DEFAULT_MAX_CACHE_SIZE**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager.DEFAULT_MAX_CACHE_SIZE) –
- [**confidence_threshold**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager.confidence_threshold) –
- [**default_encoding**](#openhands.tools.str_replace_editor.utils.encoding.EncodingManager.default_encoding) –

Initialize the encoding detector with optional cache size limit.

####### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager.DEFAULT_MAX_CACHE_SIZE`

```python
DEFAULT_MAX_CACHE_SIZE = 1000
```

####### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager.confidence_threshold`

```python
confidence_threshold = 0.9
```

####### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager.default_encoding`

```python
default_encoding = 'utf-8'
```

####### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager.detect_encoding`

```python
detect_encoding(path)
```

Detect the encoding of a file without handling caching logic.

**Parameters:**

- **path** (<code>[Path](#pathlib.Path)</code>) – Path to the file

Returns:
The detected encoding or default encoding if detection fails

####### `openhands.tools.str_replace_editor.utils.encoding.EncodingManager.get_encoding`

```python
get_encoding(path)
```

Get encoding for a file, using cache or detecting if necessary.

**Parameters:**

- **path** (<code>[Path](#pathlib.Path)</code>) – Path to the file

Returns:
The encoding for the file

###### `openhands.tools.str_replace_editor.utils.encoding.with_encoding`

```python
with_encoding(method)
```

Handle file encoding for file operations.

This decorator automatically detects and applies the correct encoding
for file operations, ensuring consistency between read and write operations.

**Parameters:**

- **method** – The method to decorate

Returns:
The decorated method

##### `openhands.tools.str_replace_editor.utils.file_cache`

File-based cache implementation with size limits and LRU eviction.

**Classes:**

- [**FileCache**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache) – A file-based cache with size limits and LRU eviction.

**Attributes:**

- [**logger**](#openhands.tools.str_replace_editor.utils.file_cache.logger) –

###### `openhands.tools.str_replace_editor.utils.file_cache.FileCache`

```python
FileCache(directory, size_limit=None)
```

A file-based cache with size limits and LRU eviction.

**Functions:**

- [**clear**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.clear) – Clear all entries from the cache.
- [**delete**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.delete) – Delete a key from the cache.
- [**get**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.get) – Get a value from the cache.
- [**set**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.set) – Set a value in the cache.

**Attributes:**

- [**current_size**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.current_size) –
- [**directory**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.directory) –
- [**size_limit**](#openhands.tools.str_replace_editor.utils.file_cache.FileCache.size_limit) –

Initialize the file cache.

**Parameters:**

- **directory** (<code>[str](#str)</code>) – Directory to store cached files
- **size_limit** (<code>[Optional](#typing.Optional)\[[int](#int)\]</code>) – Maximum cache size in bytes (None for unlimited)

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.clear`

```python
clear()
```

Clear all entries from the cache.

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.current_size`

```python
current_size = 0
```

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.delete`

```python
delete(key)
```

Delete a key from the cache.

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.directory`

```python
directory = Path(directory)
```

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.get`

```python
get(key, default=None)
```

Get a value from the cache.

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.set`

```python
set(key, value)
```

Set a value in the cache.

####### `openhands.tools.str_replace_editor.utils.file_cache.FileCache.size_limit`

```python
size_limit = size_limit
```

###### `openhands.tools.str_replace_editor.utils.file_cache.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.tools.str_replace_editor.utils.history`

History management for file edits with disk-based storage and memory constraints.

**Classes:**

- [**FileHistoryManager**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager) – Manages file edit history with disk-based storage and memory constraints.

###### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager`

```python
FileHistoryManager(max_history_per_file=5, history_dir=None)
```

Manages file edit history with disk-based storage and memory constraints.

**Functions:**

- [**add_history**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.add_history) – Add a new history entry for a file.
- [**clear_history**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.clear_history) – Clear history for a given file.
- [**get_all_history**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.get_all_history) – Get all history entries for a file.
- [**get_metadata**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.get_metadata) – Get metadata for a file (for testing purposes).
- [**pop_last_history**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.pop_last_history) – Pop and return the most recent history entry for a file.

**Attributes:**

- [**cache**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.cache) –
- [**logger**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.logger) –
- [**max_history_per_file**](#openhands.tools.str_replace_editor.utils.history.FileHistoryManager.max_history_per_file) –

Initialize the history manager.

**Parameters:**

- **max_history_per_file** (<code>[int](#int)</code>) – Maximum number of history entries to keep per
  file (default: 5)
- **history_dir** (<code>[Optional](#typing.Optional)\[[Path](#pathlib.Path)\]</code>) – Directory to store history files. If None, uses a temp
  directory

<details class="notes" open>
<summary>Notes</summary>
- Each file's history is limited to the last N entries to conserve
  memory
- The file cache is limited to prevent excessive disk usage
- Older entries are automatically removed when limits are exceeded
</details>

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.add_history`

```python
add_history(file_path, content)
```

Add a new history entry for a file.

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.cache`

```python
cache = FileCache(str(history_dir))
```

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.clear_history`

```python
clear_history(file_path)
```

Clear history for a given file.

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.get_all_history`

```python
get_all_history(file_path)
```

Get all history entries for a file.

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.get_metadata`

```python
get_metadata(file_path)
```

Get metadata for a file (for testing purposes).

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.logger`

```python
logger = logging.getLogger(__name__)
```

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.max_history_per_file`

```python
max_history_per_file = max_history_per_file
```

####### `openhands.tools.str_replace_editor.utils.history.FileHistoryManager.pop_last_history`

```python
pop_last_history(file_path)
```

Pop and return the most recent history entry for a file.

##### `openhands.tools.str_replace_editor.utils.shell`

Shell command utilities for the str_replace_editor tool.

**Functions:**

- [**check_tool_installed**](#openhands.tools.str_replace_editor.utils.shell.check_tool_installed) – Check if a tool is installed.
- [**run_shell_cmd**](#openhands.tools.str_replace_editor.utils.shell.run_shell_cmd) – Run a shell command synchronously with a timeout.

###### `openhands.tools.str_replace_editor.utils.shell.check_tool_installed`

```python
check_tool_installed(tool_name)
```

Check if a tool is installed.

###### `openhands.tools.str_replace_editor.utils.shell.run_shell_cmd`

```python
run_shell_cmd(cmd, timeout=120.0, truncate_after=MAX_RESPONSE_LEN_CHAR, truncate_notice=CONTENT_TRUNCATED_NOTICE)
```

Run a shell command synchronously with a timeout.

**Parameters:**

- **cmd** (<code>[str](#str)</code>) – The shell command to run.
- **timeout** (<code>[float](#float) | None</code>) – The maximum time to wait for the command to complete.
- **truncate_after** (<code>[int](#int) | None</code>) – The maximum number of characters to return for stdout
  and stderr.
- **truncate_notice** (<code>[str](#str)</code>) – Notice to append when content is truncated.

**Returns:**

- <code>[tuple](#tuple)\[[int](#int), [str](#str), [str](#str)\]</code> – A tuple containing the return code, stdout, and stderr.

### `openhands.tools.str_replace_editor_tool`

```python
str_replace_editor_tool = Tool(name='str_replace_editor', action_type=StrReplaceEditorAction, description=TOOL_DESCRIPTION, annotations=(ToolAnnotations(title='str_replace_editor', readOnlyHint=False, destructiveHint=True, idempotentHint=False, openWorldHint=False)))
```

### `openhands.tools.task_tracker`

Task tracker tool for managing development tasks.

**Modules:**

- [**definition**](#openhands.tools.task_tracker.definition) – Task tracker tool definition and implementation.

**Classes:**

- [**TaskTrackerAction**](#openhands.tools.task_tracker.TaskTrackerAction) – An action where the agent writes or updates a task list for task management.
- [**TaskTrackerExecutor**](#openhands.tools.task_tracker.TaskTrackerExecutor) – Executor for the task tracker tool.
- [**TaskTrackerObservation**](#openhands.tools.task_tracker.TaskTrackerObservation) – Data class representing the result of a task tracking operation.
- [**TaskTrackerTool**](#openhands.tools.task_tracker.TaskTrackerTool) – A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Attributes:**

- [**task_tracker_tool**](#openhands.tools.task_tracker.task_tracker_tool) –

#### `openhands.tools.task_tracker.TaskTrackerAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

An action where the agent writes or updates a task list for task management.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.task_tracker.TaskTrackerAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.task_tracker.TaskTrackerAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.TaskTrackerAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.task_tracker.TaskTrackerAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.task_tracker.TaskTrackerAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.task_tracker.TaskTrackerAction.command) (<code>[Literal](#typing.Literal)['view', 'plan']</code>) –
- [**kind**](#openhands.tools.task_tracker.TaskTrackerAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.task_tracker.TaskTrackerAction.model_config) –
- [**security_risk**](#openhands.tools.task_tracker.TaskTrackerAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**task_list**](#openhands.tools.task_tracker.TaskTrackerAction.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.task_tracker.TaskTrackerAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task management styling.

##### `openhands.tools.task_tracker.TaskTrackerAction.command`

```python
command: Literal['view', 'plan'] = Field(default='view', description='The command to execute. `view` shows the current task list. `plan` creates or updates the task list based on provided requirements and progress. Always `view` the current list before making changes.')
```

##### `openhands.tools.task_tracker.TaskTrackerAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.task_tracker.TaskTrackerAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.task_tracker.TaskTrackerAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

##### `openhands.tools.task_tracker.TaskTrackerAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.task_tracker.TaskTrackerAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.task_tracker.TaskTrackerAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

##### `openhands.tools.task_tracker.TaskTrackerAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.task_tracker.TaskTrackerAction.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The full task list. Required parameter of `plan` command.')
```

##### `openhands.tools.task_tracker.TaskTrackerAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.task_tracker.TaskTrackerAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with task management styling.

#### `openhands.tools.task_tracker.TaskTrackerExecutor`

```python
TaskTrackerExecutor(save_dir=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for the task tracker tool.

**Functions:**

- [**close**](#openhands.tools.task_tracker.TaskTrackerExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**save_dir**](#openhands.tools.task_tracker.TaskTrackerExecutor.save_dir) –

Initialize TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.md

##### `openhands.tools.task_tracker.TaskTrackerExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

##### `openhands.tools.task_tracker.TaskTrackerExecutor.save_dir`

```python
save_dir = Path(save_dir) if save_dir else None
```

#### `openhands.tools.task_tracker.TaskTrackerObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

Data class representing the result of a task tracking operation.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.task_tracker.TaskTrackerObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.task_tracker.TaskTrackerObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.TaskTrackerObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.task_tracker.TaskTrackerObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.task_tracker.TaskTrackerObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.task_tracker.TaskTrackerObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.TextContent) | [ImageContent](#openhands.sdk.ImageContent)\]</code>) – Return the observation content for the agent.
- [**command**](#openhands.tools.task_tracker.TaskTrackerObservation.command) (<code>[str](#str)</code>) –
- [**content**](#openhands.tools.task_tracker.TaskTrackerObservation.content) (<code>[str](#str)</code>) –
- [**kind**](#openhands.tools.task_tracker.TaskTrackerObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.task_tracker.TaskTrackerObservation.model_config) –
- [**task_list**](#openhands.tools.task_tracker.TaskTrackerObservation.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.task_tracker.TaskTrackerObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task list formatting.

##### `openhands.tools.task_tracker.TaskTrackerObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return the observation content for the agent.

##### `openhands.tools.task_tracker.TaskTrackerObservation.command`

```python
command: str = Field(default='', description='The command that was executed')
```

##### `openhands.tools.task_tracker.TaskTrackerObservation.content`

```python
content: str = Field(default='', description='The formatted task list or status message')
```

##### `openhands.tools.task_tracker.TaskTrackerObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

##### `openhands.tools.task_tracker.TaskTrackerObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.task_tracker.TaskTrackerObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

##### `openhands.tools.task_tracker.TaskTrackerObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.task_tracker.TaskTrackerObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.task_tracker.TaskTrackerObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.task_tracker.TaskTrackerObservation.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The current task list')
```

##### `openhands.tools.task_tracker.TaskTrackerObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

##### `openhands.tools.task_tracker.TaskTrackerObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with task list formatting.

#### `openhands.tools.task_tracker.TaskTrackerTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[TaskTrackerAction](#openhands.tools.task_tracker.definition.TaskTrackerAction), [TaskTrackerObservation](#openhands.tools.task_tracker.definition.TaskTrackerObservation)\]</code>

A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Functions:**

- [**call**](#openhands.tools.task_tracker.TaskTrackerTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.task_tracker.TaskTrackerTool.create) – Initialize TaskTrackerTool with a TaskTrackerExecutor.
- [**model_validate**](#openhands.tools.task_tracker.TaskTrackerTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.TaskTrackerTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.task_tracker.TaskTrackerTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.task_tracker.TaskTrackerTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.task_tracker.TaskTrackerTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.task_tracker.TaskTrackerTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.task_tracker.TaskTrackerTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.task_tracker.TaskTrackerTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.task_tracker.TaskTrackerTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.task_tracker.TaskTrackerTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.task_tracker.TaskTrackerTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.task_tracker.TaskTrackerTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.task_tracker.TaskTrackerTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.task_tracker.TaskTrackerTool.model_config) –
- [**name**](#openhands.tools.task_tracker.TaskTrackerTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.task_tracker.TaskTrackerTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.task_tracker.TaskTrackerTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.task_tracker.TaskTrackerTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

##### `openhands.tools.task_tracker.TaskTrackerTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

##### `openhands.tools.task_tracker.TaskTrackerTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

##### `openhands.tools.task_tracker.TaskTrackerTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

##### `openhands.tools.task_tracker.TaskTrackerTool.create`

```python
create(save_dir=None)
```

Initialize TaskTrackerTool with a TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.json

##### `openhands.tools.task_tracker.TaskTrackerTool.description`

```python
description: str
```

##### `openhands.tools.task_tracker.TaskTrackerTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

##### `openhands.tools.task_tracker.TaskTrackerTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

##### `openhands.tools.task_tracker.TaskTrackerTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

##### `openhands.tools.task_tracker.TaskTrackerTool.meta`

```python
meta: dict[str, Any] | None = None
```

##### `openhands.tools.task_tracker.TaskTrackerTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

##### `openhands.tools.task_tracker.TaskTrackerTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

##### `openhands.tools.task_tracker.TaskTrackerTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

##### `openhands.tools.task_tracker.TaskTrackerTool.name`

```python
name: str
```

##### `openhands.tools.task_tracker.TaskTrackerTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

##### `openhands.tools.task_tracker.TaskTrackerTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

##### `openhands.tools.task_tracker.TaskTrackerTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

##### `openhands.tools.task_tracker.TaskTrackerTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

##### `openhands.tools.task_tracker.TaskTrackerTool.title`

```python
title: str
```

Get the title for the tool.

##### `openhands.tools.task_tracker.TaskTrackerTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

##### `openhands.tools.task_tracker.TaskTrackerTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

#### `openhands.tools.task_tracker.definition`

Task tracker tool definition and implementation.

**Classes:**

- [**TaskItem**](#openhands.tools.task_tracker.definition.TaskItem) – A single task item in the task tracker.
- [**TaskTrackerAction**](#openhands.tools.task_tracker.definition.TaskTrackerAction) – An action where the agent writes or updates a task list for task management.
- [**TaskTrackerExecutor**](#openhands.tools.task_tracker.definition.TaskTrackerExecutor) – Executor for the task tracker tool.
- [**TaskTrackerObservation**](#openhands.tools.task_tracker.definition.TaskTrackerObservation) – Data class representing the result of a task tracking operation.
- [**TaskTrackerTool**](#openhands.tools.task_tracker.definition.TaskTrackerTool) – A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Attributes:**

- [**TASK_TRACKER_DESCRIPTION**](#openhands.tools.task_tracker.definition.TASK_TRACKER_DESCRIPTION) –
- [**logger**](#openhands.tools.task_tracker.definition.logger) –
- [**task_tracker_tool**](#openhands.tools.task_tracker.definition.task_tracker_tool) –

##### `openhands.tools.task_tracker.definition.TASK_TRACKER_DESCRIPTION`

````python
TASK_TRACKER_DESCRIPTION = 'This tool provides structured task management capabilities for development workflows.\nIt enables systematic tracking of work items, progress monitoring, and efficient\norganization of complex development activities.\n\nThe tool maintains visibility into project status and helps communicate\nprogress effectively to users.\n\n## Application Guidelines\n\nUtilize this tool in the following situations:\n\n1. Multi-phase development work - When projects involve multiple sequential or\n   parallel activities\n2. Complex implementation tasks - Work requiring systematic planning and\n   coordination across multiple components\n3. Explicit user request for task organization - When users specifically ask\n   for structured task management\n4. Multiple concurrent requirements - When users present several work items\n   that need coordination\n5. Project initiation - Capture and organize user requirements at project start\n6. Work commencement - Update task status to in_progress before beginning\n   implementation. Maintain focus by limiting active work to one task\n7. Task completion - Update status to done and identify any additional work\n   that emerged during implementation\n\n## Situations Where Tool Usage Is Unnecessary\n\nAvoid using this tool when:\n\n1. Single atomic tasks that require no decomposition\n2. Trivial operations where tracking adds no organizational value\n3. Simple activities completable in minimal steps\n4. Pure information exchange or discussion\n\nNote: For single straightforward tasks, proceed with direct implementation\nrather than creating tracking overhead.\n\n## Usage Scenarios\n\n**Scenario A: Feature Development with Validation**\nUser request: "Build a user authentication system with login/logout functionality.\nDon\'t forget to include input validation and error handling!"\n\nResponse approach: I\'ll implement a user authentication system with comprehensive\nvalidation. Let me organize this work systematically.\n\n*Task breakdown includes:*\n1. Design authentication API endpoints and data models\n2. Implement user login/logout controllers with session management\n3. Add client-side form validation and error display\n4. Create backend input sanitization and security checks\n5. Implement comprehensive error handling for edge cases\n6. Perform integration testing and fix any issues\n\n**Scenario B: Codebase Refactoring**\nUser request: "I need to update all instances of the method \'fetchData\' to\n\'retrieveInformation\' throughout the entire project"\n\nResponse approach: Let me first analyze your codebase to identify all locations\nwhere \'fetchData\' appears.\n\n*After code analysis*\n\nI\'ve located 12 occurrences of \'fetchData\' across 6 files in your project.\nI\'ll create a systematic plan to update these references.\n\n*Organized task list includes specific file-by-file updates*\n\n**Scenario C: Multi-feature Development**\nUser request: "Set up a blog platform with these components: admin dashboard,\narticle management, comment system, and user profiles."\n\nResponse approach: I\'ll help build your blog platform. Let me break down these\ncomponents into manageable implementation phases.\n\n*Creates structured plan with each feature decomposed into specific development tasks*\n\n## Counter-examples - Direct Implementation Preferred\n\n**Counter-example A: Simple inquiry**\nUser request: "What\'s the syntax for a for loop in JavaScript?"\n\nResponse approach: Here\'s how to write a for loop in JavaScript:\n\n```javascript\nfor (let i = 0; i < array.length; i++) {\n    console.log(array[i]);\n}\n```\n\n*No task tracking needed - single informational response*\n\n**Counter-example B: Minor modification**\nUser request: "Please add a docstring to the processPayment function explaining\nits parameters."\n\nResponse approach: I\'ll add a docstring to explain the processPayment function.\n\n*Direct edit without task tracking for simple modification*\n\n## Status Management and Workflow\n\n1. **Status Values**: Track work using these states:\n   - todo: Not yet initiated\n   - in_progress: Currently active (maintain single focus)\n   - done: Successfully completed\n\n2. **Workflow Practices**:\n   - Update status dynamically as work progresses\n   - Mark completion immediately upon task finish\n   - Limit active work to ONE task at any given time\n   - Complete current activities before initiating new ones\n   - Remove obsolete tasks from tracking entirely\n\n3. **Completion Criteria**:\n   - Mark tasks as done only when fully achieved\n   - Keep status as in_progress if errors, blocks, or partial completion exist\n   - Create new tasks for discovered issues or dependencies\n   - Never mark done when:\n       - Test suites are failing\n       - Implementation remains incomplete\n       - Unresolved errors persist\n       - Required resources are unavailable\n\n4. **Task Organization**:\n   - Write precise, actionable descriptions\n   - Decompose complex work into manageable units\n   - Use descriptive, clear naming conventions\n\nWhen uncertain, favor using this tool. Proactive task management demonstrates\nsystematic approach and ensures comprehensive requirement fulfillment.'
````

##### `openhands.tools.task_tracker.definition.TaskItem`

Bases: <code>[BaseModel](#pydantic.BaseModel)</code>

A single task item in the task tracker.

**Attributes:**

- [**notes**](#openhands.tools.task_tracker.definition.TaskItem.notes) (<code>[str](#str)</code>) –
- [**status**](#openhands.tools.task_tracker.definition.TaskItem.status) (<code>[Literal](#typing.Literal)['todo', 'in_progress', 'done']</code>) –
- [**title**](#openhands.tools.task_tracker.definition.TaskItem.title) (<code>[str](#str)</code>) –

###### `openhands.tools.task_tracker.definition.TaskItem.notes`

```python
notes: str = Field('', description='Additional details or notes about the task.')
```

###### `openhands.tools.task_tracker.definition.TaskItem.status`

```python
status: Literal['todo', 'in_progress', 'done'] = Field('todo', description="The current status of the task. One of 'todo', 'in_progress', or 'done'.")
```

###### `openhands.tools.task_tracker.definition.TaskItem.title`

```python
title: str = Field(..., description='A brief title for the task.')
```

##### `openhands.tools.task_tracker.definition.TaskTrackerAction`

Bases: <code>[ActionBase](#openhands.sdk.tool.ActionBase)</code>

An action where the agent writes or updates a task list for task management.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.task_tracker.definition.TaskTrackerAction.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.task_tracker.definition.TaskTrackerAction.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.definition.TaskTrackerAction.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.task_tracker.definition.TaskTrackerAction.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.task_tracker.definition.TaskTrackerAction.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**command**](#openhands.tools.task_tracker.definition.TaskTrackerAction.command) (<code>[Literal](#typing.Literal)['view', 'plan']</code>) –
- [**kind**](#openhands.tools.task_tracker.definition.TaskTrackerAction.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.task_tracker.definition.TaskTrackerAction.model_config) –
- [**security_risk**](#openhands.tools.task_tracker.definition.TaskTrackerAction.security_risk) (<code>[SECURITY_RISK_LITERAL](#openhands.sdk.tool.security_prompt.SECURITY_RISK_LITERAL)</code>) –
- [**task_list**](#openhands.tools.task_tracker.definition.TaskTrackerAction.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.task_tracker.definition.TaskTrackerAction.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task management styling.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.command`

```python
command: Literal['view', 'plan'] = Field(default='view', description='The command to execute. `view` shows the current task list. `plan` creates or updates the task list based on provided requirements and progress. Always `view` the current list before making changes.')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.model_config`

```python
model_config = ConfigDict(extra='forbid')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.security_risk`

```python
security_risk: SECURITY_RISK_LITERAL = Field(default='UNKNOWN', description=SECURITY_RISK_DESC)
```

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The full task list. Required parameter of `plan` command.')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.task_tracker.definition.TaskTrackerAction.visualize`

```python
visualize: Text
```

Return Rich Text representation with task management styling.

##### `openhands.tools.task_tracker.definition.TaskTrackerExecutor`

```python
TaskTrackerExecutor(save_dir=None)
```

Bases: <code>[ToolExecutor](#openhands.sdk.tool.ToolExecutor)</code>

Executor for the task tracker tool.

**Functions:**

- [**close**](#openhands.tools.task_tracker.definition.TaskTrackerExecutor.close) – Close the executor and clean up resources.

**Attributes:**

- [**save_dir**](#openhands.tools.task_tracker.definition.TaskTrackerExecutor.save_dir) –

Initialize TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.md

###### `openhands.tools.task_tracker.definition.TaskTrackerExecutor.close`

```python
close()
```

Close the executor and clean up resources.

Default implementation does nothing. Subclasses should override
this method to perform cleanup (e.g., closing connections,
terminating processes, etc.).

###### `openhands.tools.task_tracker.definition.TaskTrackerExecutor.save_dir`

```python
save_dir = Path(save_dir) if save_dir else None
```

##### `openhands.tools.task_tracker.definition.TaskTrackerObservation`

Bases: <code>[ObservationBase](#openhands.sdk.tool.ObservationBase)</code>

Data class representing the result of a task tracking operation.

**Functions:**

- [**from_mcp_schema**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.from_mcp_schema) – Create a Schema subclass from an MCP/JSON Schema object.
- [**model_validate**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.model_validate_json) – Validate JSON using our custom model_validate method.
- [**target_subclass**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_schema**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.to_mcp_schema) – Convert to JSON schema format compatible with MCP.

**Attributes:**

- [**agent_observation**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.agent_observation) (<code>[list](#list)\[[TextContent](#openhands.sdk.TextContent) | [ImageContent](#openhands.sdk.ImageContent)\]</code>) – Return the observation content for the agent.
- [**command**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.command) (<code>[str](#str)</code>) –
- [**content**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.content) (<code>[str](#str)</code>) –
- [**kind**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**model_config**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.model_config) –
- [**task_list**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.task_list) (<code>[list](#list)\[[TaskItem](#openhands.tools.task_tracker.definition.TaskItem)\]</code>) –
- [**visualize**](#openhands.tools.task_tracker.definition.TaskTrackerObservation.visualize) (<code>[Text](#rich.text.Text)</code>) – Return Rich Text representation with task list formatting.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.agent_observation`

```python
agent_observation: list[TextContent | ImageContent]
```

Return the observation content for the agent.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.command`

```python
command: str = Field(default='', description='The command that was executed')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.content`

```python
content: str = Field(default='', description='The formatted task list or status message')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.from_mcp_schema`

```python
from_mcp_schema(model_name, schema)
```

Create a Schema subclass from an MCP/JSON Schema object.

For non-required fields, we annotate as `T | None`
so explicit nulls are allowed.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.model_config`

```python
model_config = ConfigDict(extra='allow')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.task_list`

```python
task_list: list[TaskItem] = Field(default_factory=list, description='The current task list')
```

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.to_mcp_schema`

```python
to_mcp_schema()
```

Convert to JSON schema format compatible with MCP.

###### `openhands.tools.task_tracker.definition.TaskTrackerObservation.visualize`

```python
visualize: Text
```

Return Rich Text representation with task list formatting.

##### `openhands.tools.task_tracker.definition.TaskTrackerTool`

Bases: <code>[Tool](#openhands.sdk.tool.Tool)\[[TaskTrackerAction](#openhands.tools.task_tracker.definition.TaskTrackerAction), [TaskTrackerObservation](#openhands.tools.task_tracker.definition.TaskTrackerObservation)\]</code>

A Tool subclass that automatically initializes a TaskTrackerExecutor.

**Functions:**

- [**call**](#openhands.tools.task_tracker.definition.TaskTrackerTool.call) – Validate input, execute, and coerce output.
- [**create**](#openhands.tools.task_tracker.definition.TaskTrackerTool.create) – Initialize TaskTrackerTool with a TaskTrackerExecutor.
- [**model_validate**](#openhands.tools.task_tracker.definition.TaskTrackerTool.model_validate) – Validate model using registered subclasses for deserialization.
- [**model_validate_json**](#openhands.tools.task_tracker.definition.TaskTrackerTool.model_validate_json) – Validate JSON using our custom model_validate method.
- [**set_executor**](#openhands.tools.task_tracker.definition.TaskTrackerTool.set_executor) – Create a new Tool instance with the given executor.
- [**target_subclass**](#openhands.tools.task_tracker.definition.TaskTrackerTool.target_subclass) – Get the subclass corresponding to a given kind name.
- [**to_mcp_tool**](#openhands.tools.task_tracker.definition.TaskTrackerTool.to_mcp_tool) – Convert tool to MCP tool format.
- [**to_openai_tool**](#openhands.tools.task_tracker.definition.TaskTrackerTool.to_openai_tool) – Convert an MCP tool to an OpenAI tool.

**Attributes:**

- [**action_type**](#openhands.tools.task_tracker.definition.TaskTrackerTool.action_type) (<code>[type](#type)\[[ActionBase](#openhands.sdk.tool.schema.ActionBase)\]</code>) –
- [**annotations**](#openhands.tools.task_tracker.definition.TaskTrackerTool.annotations) (<code>[ToolAnnotations](#openhands.sdk.tool.tool.ToolAnnotations) | None</code>) –
- [**description**](#openhands.tools.task_tracker.definition.TaskTrackerTool.description) (<code>[str](#str)</code>) –
- [**executor**](#openhands.tools.task_tracker.definition.TaskTrackerTool.executor) (<code>[ToolExecutor](#openhands.sdk.tool.tool.ToolExecutor) | None</code>) –
- [**input_schema**](#openhands.tools.task_tracker.definition.TaskTrackerTool.input_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\]</code>) – Get the input schema for the tool.
- [**kind**](#openhands.tools.task_tracker.definition.TaskTrackerTool.kind) (<code>[str](#str)</code>) – Property to create kind field from class name when serializing.
- [**meta**](#openhands.tools.task_tracker.definition.TaskTrackerTool.meta) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) –
- [**model_config**](#openhands.tools.task_tracker.definition.TaskTrackerTool.model_config) –
- [**name**](#openhands.tools.task_tracker.definition.TaskTrackerTool.name) (<code>[str](#str)</code>) –
- [**observation_type**](#openhands.tools.task_tracker.definition.TaskTrackerTool.observation_type) (<code>[type](#type)\[[ObservationBase](#openhands.sdk.tool.schema.ObservationBase)\] | None</code>) –
- [**output_schema**](#openhands.tools.task_tracker.definition.TaskTrackerTool.output_schema) (<code>[dict](#dict)\[[str](#str), [Any](#typing.Any)\] | None</code>) – Get the output schema for the tool.
- [**title**](#openhands.tools.task_tracker.definition.TaskTrackerTool.title) (<code>[str](#str)</code>) – Get the title for the tool.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.action_type`

```python
action_type: type[ActionBase] = Field(repr=False)
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.annotations`

```python
annotations: ToolAnnotations | None = None
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.call`

```python
call(action)
```

Validate input, execute, and coerce output.

We always return some ObservationBase subclass, but not always the
generic ObservationT.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.create`

```python
create(save_dir=None)
```

Initialize TaskTrackerTool with a TaskTrackerExecutor.

**Parameters:**

- **save_dir** (<code>[str](#str) | None</code>) – Optional directory to save tasks to. If provided, tasks will be
  persisted to save_dir/TASKS.json

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.description`

```python
description: str
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.executor`

```python
executor: ToolExecutor | None = Field(default=None, repr=False, exclude=True)
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.input_schema`

```python
input_schema: dict[str, Any]
```

Get the input schema for the tool.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.kind`

```python
kind: str
```

Property to create kind field from class name when serializing.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.meta`

```python
meta: dict[str, Any] | None = None
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.model_config`

```python
model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True)
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.model_validate`

```python
model_validate(obj, *, strict=None, from_attributes=None, context=None, **kwargs)
```

Validate model using registered subclasses for deserialization.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.model_validate_json`

```python
model_validate_json(json_data, *, strict=None, context=None, **kwargs)
```

Validate JSON using our custom model_validate method.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.name`

```python
name: str
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.observation_type`

```python
observation_type: type[ObservationBase] | None = Field(default=None, repr=False)
```

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.output_schema`

```python
output_schema: dict[str, Any] | None
```

Get the output schema for the tool.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.set_executor`

```python
set_executor(executor)
```

Create a new Tool instance with the given executor.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.target_subclass`

```python
target_subclass(kind)
```

Get the subclass corresponding to a given kind name.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.title`

```python
title: str
```

Get the title for the tool.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.to_mcp_tool`

```python
to_mcp_tool()
```

Convert tool to MCP tool format.

###### `openhands.tools.task_tracker.definition.TaskTrackerTool.to_openai_tool`

```python
to_openai_tool()
```

Convert an MCP tool to an OpenAI tool.

##### `openhands.tools.task_tracker.definition.logger`

```python
logger = get_logger(__name__)
```

##### `openhands.tools.task_tracker.definition.task_tracker_tool`

```python
task_tracker_tool = Tool(name='task_tracker', description=TASK_TRACKER_DESCRIPTION, action_type=TaskTrackerAction, observation_type=TaskTrackerObservation, annotations=(ToolAnnotations(readOnlyHint=False, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

#### `openhands.tools.task_tracker.task_tracker_tool`

```python
task_tracker_tool = Tool(name='task_tracker', description=TASK_TRACKER_DESCRIPTION, action_type=TaskTrackerAction, observation_type=TaskTrackerObservation, annotations=(ToolAnnotations(readOnlyHint=False, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

### `openhands.tools.task_tracker_tool`

```python
task_tracker_tool = Tool(name='task_tracker', description=TASK_TRACKER_DESCRIPTION, action_type=TaskTrackerAction, observation_type=TaskTrackerObservation, annotations=(ToolAnnotations(readOnlyHint=False, destructiveHint=False, idempotentHint=True, openWorldHint=False)))
```

### `openhands.tools.utils`

Shared utilities.
