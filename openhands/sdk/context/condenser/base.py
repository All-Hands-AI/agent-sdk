from abc import ABC, abstractmethod
from logging import getLogger
from typing import Annotated

from openhands.sdk.context.view import View
from openhands.sdk.event import LLMConvertibleEvent
from openhands.sdk.event.condenser import Condensation
from openhands.sdk.event.llm_convertible import ActionEvent, ObservationEvent
from openhands.sdk.utils.discriminated_union import (
    DiscriminatedUnionMixin,
    DiscriminatedUnionType,
)


logger = getLogger(__name__)


class CondenserBase(DiscriminatedUnionMixin, ABC):
    """Abstract condenser interface.

    Condensers take a list of `Event` objects and reduce them into a potentially smaller
    list.

    Agents can use condensers to reduce the amount of events they need to consider when
    deciding which action to take. To use a condenser, agents can call the
    `condensed_history` method on the current `State` being considered and use the
    results instead of the full history.

    If the condenser returns a `Condensation` instead of a `View`, the agent should
    return `Condensation.action` instead of producing its own action. On the next agent
    step the condenser will use that condensation event to produce a new `View`.
    """

    @abstractmethod
    def condense(self, view: View) -> View | Condensation:
        """Condense a sequence of events into a potentially smaller list.

        New condenser strategies should override this method to implement their own
        condensation logic. Call `self.add_metadata` in the implementation to record any
        relevant per-condensation diagnostic information.

        Args:
            view: A view of the history containing all events that should be condensed.

        Returns:
            View | Condensation: A condensed view of the events or an event indicating
            the history has been condensed.
        """

    def filter_unmatched_tool_calls(
        self, events: list[LLMConvertibleEvent]
    ) -> list[LLMConvertibleEvent]:
        """Filter out tool-call events that don't have a matching pair.

        This method removes ActionEvents that don't have corresponding ObservationEvents
        and ObservationEvents that don't have corresponding ActionEvents, based on their
        tool_call_id. Non-tool events are always kept.

        Args:
            events: List of events to filter.

        Returns:
            Filtered list of events with only matched tool call pairs and non-tool
            events.
        """
        action_tool_call_ids = self._get_action_tool_call_ids(events)
        observation_tool_call_ids = self._get_observation_tool_call_ids(events)

        return [
            event
            for event in events
            if self._should_keep_event(
                event, action_tool_call_ids, observation_tool_call_ids
            )
        ]

    def _get_action_tool_call_ids(self, events: list[LLMConvertibleEvent]) -> set[str]:
        """Collect tool_call_ids from ActionEvents."""
        return {
            event.tool_call_id
            for event in events
            if isinstance(event, ActionEvent) and event.tool_call_id
        }

    def _get_observation_tool_call_ids(
        self, events: list[LLMConvertibleEvent]
    ) -> set[str]:
        """Collect tool_call_ids from ObservationEvents."""
        return {
            event.tool_call_id
            for event in events
            if isinstance(event, ObservationEvent) and event.tool_call_id
        }

    def _should_keep_event(
        self,
        event: LLMConvertibleEvent,
        action_tool_call_ids: set[str],
        observation_tool_call_ids: set[str],
    ) -> bool:
        """Determine if an event should be kept based on tool call matching."""
        if isinstance(event, ObservationEvent):
            # Keep ObservationEvents only if they have a matching ActionEvent
            return event.tool_call_id in action_tool_call_ids

        elif isinstance(event, ActionEvent):
            # Keep ActionEvents only if they have a matching ObservationEvent
            return event.tool_call_id in observation_tool_call_ids

        else:
            # Keep all other event types
            return True


Condenser = Annotated[CondenserBase, DiscriminatedUnionType[CondenserBase]]
"""Type annotation for values that can be any implementation of CondenserBase.

In most situations, this is equivalent to CondenserBase. However, when used in Pydantic
BaseModels as a field annotation, it enables polymorphic deserialization by delaying the
discriminator resolution until runtime.
"""


class RollingCondenser(CondenserBase, ABC):
    """Base class for a specialized condenser strategy that applies condensation to a
    rolling history.

    The rolling history is generated by `View.from_events`, which analyzes all events in
    the history and produces a `View` object representing what will be sent to the LLM.

    If `should_condense` says so, the condenser is then responsible for generating a
    `Condensation` object from the `View` object. This will be added to the event
    history which should -- when given to `get_view` -- produce the condensed `View` to
    be passed to the LLM.
    """

    @abstractmethod
    def should_condense(self, view: View) -> bool:
        """Determine if a view should be condensed."""

    @abstractmethod
    def get_condensation(self, view: View) -> Condensation:
        """Get the condensation from a view."""

    def condense(self, view: View) -> View | Condensation:
        # If we trigger the condenser-specific condensation threshold, compute and
        # return the condensation.
        if self.should_condense(view):
            return self.get_condensation(view)

        # Otherwise we're safe to just return the view.
        else:
            return view
